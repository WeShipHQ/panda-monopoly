// lib.rs
#![allow(unexpected_cfgs)]
pub mod constants;
pub mod error;
pub mod instructions;
pub mod state;
pub mod utils;

use anchor_lang::prelude::*;
use ephemeral_rollups_sdk::anchor::ephemeral;

pub use constants::*;
pub use instructions::*;
pub use state::*;
pub use utils::*;

declare_id!("4vucUqMcXN4sgLsgnrXTUC9U7ACZ5DmoRBLbWt4vrnyR");

#[program]
#[ephemeral]
pub mod panda_monopoly {
    use super::*;

    // Platform instructions
    pub fn create_platform_config(
        ctx: Context<CreatePlatformConfig>,
        platform_id: Pubkey,
        fee_basis_points: u16,
        fee_vault: Pubkey,
    ) -> Result<()> {
        instructions::platform::create_platform_config_handler(
            ctx,
            platform_id,
            fee_basis_points,
            fee_vault,
        )
    }

    pub fn update_platform_config(
        ctx: Context<UpdatePlatformConfig>,
        fee_basis_points: Option<u16>,
        fee_vault: Option<Pubkey>,
    ) -> Result<()> {
        instructions::platform::update_platform_config_handler(ctx, fee_basis_points, fee_vault)
    }

    // Game management instructions
    pub fn initialize_game(ctx: Context<InitializeGame>, entry_fee: u64) -> Result<()> {
        instructions::initialize::initialize_game_handler(ctx, entry_fee)
    }

    pub fn join_game(ctx: Context<JoinGame>) -> Result<()> {
        instructions::initialize::join_game_handler(ctx)
    }

    pub fn start_game<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, StartGame<'info>>,
    ) -> Result<()> {
        instructions::initialize::start_game_handler(ctx)
    }

    // Game ending instruction
    pub fn end_game(ctx: Context<EndGame>) -> Result<()> {
        instructions::end_game::end_game_handler(ctx)
    }

    // Dice and movement instructions
    pub fn roll_dice(
        ctx: Context<RollDice>,
        use_vrf: bool,
        client_seed: u8,
        dice_roll: Option<[u8; 2]>,
    ) -> Result<()> {
        instructions::dice::roll_dice_handler(ctx, use_vrf, client_seed, dice_roll)
    }


    pub fn end_turn(ctx: Context<EndTurn>) -> Result<()> {
        instructions::end_turn::end_turn_handler(ctx)
    }

    // Bankruptcy instruction
    pub fn declare_bankruptcy<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, DeclareBankruptcy<'info>>,
    ) -> Result<()> {
        instructions::bankruptcy::declare_bankruptcy_handler(ctx)
    }

    // properties v2
    pub fn buy_property_v2(ctx: Context<BuyPropertyV2>, position: u8) -> Result<()> {
        instructions::property::buy_property_v2_handler(ctx, position)
    }

    // some other instructions
}

// state/mod.rs

use anchor_lang::prelude::*;

mod events;
pub use events::*;

use crate::{error::GameError, get_color_group_properties_enum, STARTING_MONEY};

#[account]
#[derive(InitSpace, Debug)]
pub struct PlatformConfig {
    pub id: Pubkey,
    pub fee_basis_points: u16, // 500 = 5%
    pub authority: Pubkey,
    pub fee_vault: Pubkey,
    pub total_games_created: u64,
    pub next_game_id: u64,
    pub bump: u8,
}

impl PlatformConfig {
    pub fn calculate_fee(&self, amount: u64) -> u64 {
        (amount * self.fee_basis_points as u64) / 10000
    }
}

#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq)]
pub enum GameStatus {
    WaitingForPlayers,
    InProgress,
    Finished,
}

#[derive(AnchorSerialize, AnchorDeserialize, Debug, InitSpace, Clone, PartialEq, Eq)]
pub enum TradeStatus {
    Pending,
    Accepted,
    Rejected,
    Cancelled,
    Expired,
}

#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq)]
pub enum ColorGroup {
    Brown,
    LightBlue,
    Pink,
    Orange,
    Red,
    Yellow,
    Green,
    DarkBlue,
    Railroad,
    Utility,
    Special,
}

#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq)]
pub enum PropertyType {
    // Property,
    Street,
    Railroad,
    Utility,
    Corner,
    Chance,
    CommunityChest,
    Tax,
    // Beach,
    // Festival,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, PartialEq, Eq)]
pub enum BuildingType {
    House,
    Hotel,
}

// New simplified trade structure for storing in GameState vector
#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone)]
pub struct TradeInfo {
    pub id: u8,                        // Unique trade ID within the game
    pub proposer: Pubkey,              // Trade proposer
    pub receiver: Pubkey,              // Trade receiver
    pub trade_type: TradeType,         // Type of trade
    pub proposer_money: u64,           // Money offered by proposer
    pub receiver_money: u64,           // Money requested from receiver
    pub proposer_property: Option<u8>, // Property offered by proposer
    pub receiver_property: Option<u8>, // Property requested from receiver
    pub status: TradeStatus,           // Current trade status
    pub created_at: i64,               // Creation timestamp
    pub expires_at: i64,               // Expiration timestamp
}

#[account]
#[derive(Debug, InitSpace)]
pub struct GameState {
    pub game_id: u64,
    pub config_id: Pubkey,
    pub creator: Pubkey,     // 32 bytes - game creator
    pub bump: u8,            // 1 byte - PDA bump seed
    pub max_players: u8,     // 1 byte - maximum players (2-8)
    pub current_players: u8, // 1 byte - current player count
    pub current_turn: u8,    // 1 byte - whose turn (player index)
    #[max_len(4)]
    pub players: Vec<Pubkey>, // 32 * 8 = 256 bytes max
    pub created_at: i64,     // 8 bytes - game creation timestamp
    pub game_status: GameStatus, // 1 byte - current game status
    pub bank_balance: u64,   // 8 bytes - bank's money
    pub free_parking_pool: u64, // 8 bytes - parking pool
    pub houses_remaining: u8, // 1 byte - houses left in bank (32 total)
    pub hotels_remaining: u8, // 1 byte - hotels left in bank (12 total)
    pub time_limit: Option<i64>, // 9 bytes - optional time limit
    pub winner: Option<Pubkey>, // 33 bytes - game winner
    pub turn_started_at: i64, // 8 bytes - when current turn started

    // Entry fee fields
    pub entry_fee: u64, // 8 bytes - entry fee amount (0 for free games)
    pub token_mint: Option<Pubkey>, // 33 bytes - token mint for entry fee
    pub token_vault: Option<Pubkey>, // 33 bytes - vault holding entry fees
    pub total_prize_pool: u64, // 8 bytes - total collected fees

    #[max_len(20)]
    pub active_trades: Vec<TradeInfo>, // Vector of active trades
    pub next_trade_id: u8, // Next trade ID to assign

    pub properties: [PropertyInfo; 40], // Fixed array: 40 Ã— 36 bytes = 1,440 bytes
}

impl GameState {
    pub fn cleanup_expired_trades(&mut self, current_time: i64) {
        self.active_trades.retain(|trade| {
            trade.expires_at > current_time && trade.status == TradeStatus::Pending
        });
    }

    pub fn find_trade_by_id(&self, trade_id: u8) -> Option<&TradeInfo> {
        self.active_trades.iter().find(|trade| trade.id == trade_id)
    }

    pub fn find_trade_by_id_mut(&mut self, trade_id: u8) -> Option<&mut TradeInfo> {
        self.active_trades
            .iter_mut()
            .find(|trade| trade.id == trade_id)
    }

    pub fn remove_trade_by_id(&mut self, trade_id: u8) -> bool {
        if let Some(pos) = self
            .active_trades
            .iter()
            .position(|trade| trade.id == trade_id)
        {
            self.active_trades.remove(pos);
            true
        } else {
            false
        }
    }

    pub fn can_add_trade(&self) -> bool {
        self.active_trades.len() < crate::constants::MAX_ACTIVE_TRADES
    }

    pub fn get_next_trade_id(&mut self) -> u8 {
        let id = self.next_trade_id;
        self.next_trade_id = self.next_trade_id.wrapping_add(1);
        id
    }

    // properties
    pub fn initialize_properties(&mut self) {
        self.properties = [PropertyInfo::default(); 40];
    }

    pub fn get_property(&self, position: u8) -> Result<&PropertyInfo> {
        self.properties
            .get(position as usize)
            .ok_or(error!(GameError::InvalidPropertyPosition))
    }

    pub fn get_property_mut(&mut self, position: u8) -> Result<&mut PropertyInfo> {
        self.properties
            .get_mut(position as usize)
            .ok_or(error!(GameError::InvalidPropertyPosition))
    }

    pub fn has_monopoly(&self, player: &Pubkey, color_group: ColorGroup) -> bool {
        let group_positions = get_color_group_properties_enum(color_group);

        group_positions.iter().all(|&pos| {
            self.properties
                .get(pos as usize)
                .map(|p| p.owner.as_ref() == Some(player))
                .unwrap_or(false)
        })
    }

    pub fn get_player_properties(&self, player: &Pubkey) -> Vec<u8> {
        self.properties
            .iter()
            .enumerate()
            .filter_map(|(idx, prop)| {
                if prop.owner.as_ref() == Some(player) {
                    Some(idx as u8)
                } else {
                    None
                }
            })
            .collect()
    }

    pub fn can_build_evenly(
        &self,
        player: &Pubkey,
        color_group: ColorGroup,
        position: u8,
        new_house_count: u8,
    ) -> bool {
        let group_positions = get_color_group_properties_enum(color_group);

        for &pos in &group_positions {
            if pos == position {
                continue; // Skip the property we're building on
            }

            if let Some(prop) = self.properties.get(pos as usize) {
                if prop.owner.as_ref() != Some(player) {
                    return false;
                }

                // New house count can't be more than 1 higher than other properties
                if new_house_count > prop.houses + 1 {
                    return false;
                }
            }
        }

        true
    }

    pub fn can_sell_evenly(
        &self,
        player: &Pubkey,
        color_group: ColorGroup,
        position: u8,
        new_house_count: u8,
    ) -> bool {
        let group_positions = get_color_group_properties_enum(color_group);

        for &pos in &group_positions {
            if pos == position {
                continue;
            }

            if let Some(prop) = self.properties.get(pos as usize) {
                if prop.owner.as_ref() != Some(player) {
                    return false;
                }

                // Can't sell if this would make us have less than others
                if new_house_count < prop.houses.saturating_sub(1) {
                    return false;
                }
            }
        }

        true
    }
}

#[account]
#[derive(Debug, InitSpace)]
pub struct PlayerState {
    pub wallet: Pubkey,    // 32 bytes - player's wallet
    pub game: Pubkey,      // 32 bytes - game account
    pub cash_balance: u64, // 8 bytes - player's cash
    pub position: u8,      // 1 byte - board position (0-39)
    pub in_jail: bool,     // 1 byte - jail status
    pub jail_turns: u8,    // 1 byte - turns in jail
    pub doubles_count: u8, // 1 byte - consecutive doubles
    pub is_bankrupt: bool, // 1 byte - bankruptcy status
    #[max_len(50)]
    pub properties_owned: Vec<u8>, // variable - owned property positions
    pub get_out_of_jail_cards: u8, // 1 byte - jail cards owned
    pub net_worth: u64,    // 8 bytes - total asset value
    pub last_rent_collected: i64, // 8 bytes - last rent collection time
    pub festival_boost_turns: u8, // 1 byte - remaining festival boost turns

    pub has_rolled_dice: bool,       // 1 byte - has rolled dice this turn
    pub last_dice_roll: [u8; 2],     // 2 bytes - last dice roll
    pub needs_property_action: bool, // Player landed on property
    pub pending_property_position: Option<u8>, // Which property
    pub needs_chance_card: bool,     // Needs to draw chance card
    pub needs_community_chest_card: bool, // Needs to draw community chest
    pub needs_bankruptcy_check: bool, // Insufficient funds detected
    // pub can_end_turn: bool,          // All actions completed
    pub needs_special_space_action: bool, // Player landed on special space
    pub pending_special_space_position: Option<u8>, // Which special space

    pub card_drawn_at: Option<i64>, // Timestamp when card was drawn
}

impl PlayerState {
    pub fn initialize_player_state(
        self: &mut PlayerState,
        wallet: Pubkey,
        game: Pubkey,
        clock: &Sysvar<Clock>,
    ) {
        self.wallet = wallet;
        self.game = game;
        self.cash_balance = STARTING_MONEY as u64;
        self.position = 0;
        self.in_jail = false;
        self.jail_turns = 0;
        self.doubles_count = 0;
        self.is_bankrupt = false;
        self.properties_owned = Vec::new();
        self.get_out_of_jail_cards = 0;
        self.net_worth = STARTING_MONEY as u64;
        self.last_rent_collected = clock.unix_timestamp;
        self.festival_boost_turns = 0;
        self.has_rolled_dice = false;
        self.last_dice_roll = [0, 0];
        self.needs_property_action = false;
        self.pending_property_position = None;
        self.needs_chance_card = false;
        self.needs_community_chest_card = false;
        self.needs_bankruptcy_check = false;
        // self.can_end_turn = false;
        self.needs_special_space_action = false;
        self.pending_special_space_position = None;
        self.card_drawn_at = None;
    }
}

impl PropertyState {}

#[derive(AnchorSerialize, AnchorDeserialize, Debug, InitSpace, Clone, PartialEq, Eq)]
pub enum TradeType {
    MoneyOnly,
    PropertyOnly,
    MoneyForProperty,
    PropertyForMoney,
}

#[account]
#[derive(Debug, InitSpace)]
pub struct TradeState {
    pub game: Pubkey,
    pub proposer: Pubkey,
    pub receiver: Pubkey,
    pub trade_type: TradeType,

    // Money amounts
    pub proposer_money: u64,
    pub receiver_money: u64,

    // Single property (since you want 1 item per trade)
    pub proposer_property: Option<u8>, // property position
    pub receiver_property: Option<u8>, // property position

    pub status: TradeStatus,
    pub created_at: i64,
    pub expires_at: i64,
    pub bump: u8,
}

impl TradeState {}

// ----- new struct
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, InitSpace, PartialEq, Eq)]
pub struct PropertyInfo {
    pub owner: Option<Pubkey>, // 33 bytes - who owns this property
    pub houses: u8,            // 1 byte - number of houses (0-4)
    pub has_hotel: bool,       // 1 byte - has hotel built
    pub is_mortgaged: bool,    // 1 byte - mortgage status
}

impl Default for PropertyInfo {
    fn default() -> Self {
        Self {
            owner: None,
            houses: 0,
            has_hotel: false,
            is_mortgaged: false,
        }
    }
}

impl PropertyInfo {
    pub fn initialize_all() -> Vec<PropertyInfo> {
        vec![PropertyInfo::default(); 40]
    }
}

// initialize.rs
use crate::constants::*;
use crate::error::GameError;
use crate::state::*;
use anchor_lang::prelude::*;
use anchor_spl::{
    associated_token::AssociatedToken,
    token_interface::{transfer_checked, Mint, TokenAccount, TokenInterface, TransferChecked},
};
use ephemeral_rollups_sdk::anchor::delegate;
use ephemeral_rollups_sdk::cpi::DelegateConfig;

#[derive(Accounts)]
pub struct InitializeGame<'info> {
    #[account(
        init,
        payer = creator,
        space = 8 + GameState::INIT_SPACE,
        seeds = [
            b"game",
            config.id.as_ref(),
            &config.next_game_id.to_le_bytes()
            ],
        bump
    )]
    pub game: Box<Account<'info, GameState>>,

    #[account(
        init,
        payer = creator,
        space = 8 + PlayerState::INIT_SPACE + 64,
        seeds = [b"player", game.key().as_ref(), creator.key().as_ref()],
        bump,
    )]
    pub player_state: Box<Account<'info, PlayerState>>,

    #[account(mut)]
    pub creator: Signer<'info>,

    #[account(
        mut,
        seeds = [b"platform", config.id.as_ref()],
        bump = config.bump,
    )]
    pub config: Box<Account<'info, PlatformConfig>>,

    // pub game_authority: Option<UncheckedAccount<'info>>,
    /// CHECK: game authority PDA
    #[account(
        seeds = [
            GAME_AUTHORITY_SEED.as_ref(),
        ],
        bump,
    )]
    pub game_authority: UncheckedAccount<'info>,

    #[account(
        mint::token_program = token_program,
    )]
    // pub token_mint: Option<InterfaceAccount<'info, Mint>>,
    pub token_mint: Box<InterfaceAccount<'info, Mint>>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = creator,
        associated_token::token_program = token_program
    )]
    // pub creator_token_account: Option<InterfaceAccount<'info, TokenAccount>>,
    pub creator_token_account: Box<InterfaceAccount<'info, TokenAccount>>,

    #[account(
        // init,
        // payer = creator,
        // associated_token::mint = token_mint,
        // associated_token::authority = game_authority,
        // associated_token::token_program = token_program
        init,
        seeds = [
            TOKEN_VAULT_SEED.as_ref(),
            token_mint.key().as_ref(),
            game.key().as_ref(),
        ],
        token::mint = token_mint,
        token::authority = game_authority,
        token::token_program = token_program,
        payer = creator,
        bump
    )]
    // pub token_vault: Option<InterfaceAccount<'info, TokenAccount>>,
    pub token_vault: Box<InterfaceAccount<'info, TokenAccount>>,

    // pub token_program: Option<Interface<'info, TokenInterface>>,
    pub token_program: Interface<'info, TokenInterface>,
    // pub associated_token_program: Option<Program<'info, AssociatedToken>>,
    pub associated_token_program: Program<'info, AssociatedToken>,

    pub system_program: Program<'info, System>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn initialize_game_handler(ctx: Context<InitializeGame>, entry_fee: u64) -> Result<()> {
    let config = &mut ctx.accounts.config;
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let clock = &ctx.accounts.clock;

    if entry_fee > 0 {
        // require!(
        //     ctx.accounts.game_authority.is_some()
        //         && ctx.accounts.token_mint.is_some()
        //         && ctx.accounts.creator_token_account.is_some()
        //         && ctx.accounts.token_vault.is_some()
        //         && ctx.accounts.token_program.is_some()
        //         && ctx.accounts.associated_token_program.is_some(),
        //     GameError::MissingTokenAccounts
        // );

        // let token_mint = ctx.accounts.token_mint.as_ref().unwrap();
        let token_mint = &ctx.accounts.token_mint;
        // let creator_token_account = ctx.accounts.creator_token_account.as_ref().unwrap();
        let creator_token_account = &ctx.accounts.creator_token_account;
        // let token_vault = ctx.accounts.token_vault.as_ref().unwrap();
        let token_vault = &ctx.accounts.token_vault;
        // let game_authority = ctx.accounts.game_authority.as_ref().unwrap();
        let game_authority = &ctx.accounts.game_authority;

        // Validate game authority PDA
        let (expected_game_authority, _) =
            Pubkey::find_program_address(&[GAME_AUTHORITY_SEED], ctx.program_id);

        require!(
            game_authority.key() == expected_game_authority,
            GameError::InvalidGameAuthority
        );

        require!(
            creator_token_account.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            creator_token_account.owner == ctx.accounts.creator.key(),
            GameError::InvalidTokenAccount
        );

        require!(
            token_vault.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            token_vault.owner == game_authority.key(),
            GameError::InvalidTokenAccount
        );

        // Transfer entry fee from creator to vault
        let transfer_accounts = TransferChecked {
            from: creator_token_account.to_account_info(),
            mint: token_mint.to_account_info(),
            to: token_vault.to_account_info(),
            authority: ctx.accounts.creator.to_account_info(),
        };

        let transfer_ctx = CpiContext::new(
            ctx.accounts
                .token_program
                .as_ref()
                // .unwrap()
                .to_account_info(),
            transfer_accounts,
        );

        transfer_checked(transfer_ctx, entry_fee, token_mint.decimals)?;

        game.token_mint = Some(token_mint.key());
        game.token_vault = Some(token_vault.key());
        game.total_prize_pool = entry_fee;
    } else {
        game.token_mint = None;
        game.token_vault = None;
        game.total_prize_pool = 0;
    }

    let game_id = config.next_game_id;
    config.next_game_id += 1;
    config.total_games_created += 1;

    // Initialize game state
    game.game_id = game_id;
    game.config_id = config.id;
    game.creator = ctx.accounts.creator.key();
    game.bump = ctx.bumps.game;
    game.game_status = GameStatus::WaitingForPlayers;
    game.current_turn = 0;
    game.current_players = 0; // Initial player count
    game.max_players = MAX_PLAYERS;
    game.players = vec![];
    game.houses_remaining = TOTAL_HOUSES;
    game.hotels_remaining = TOTAL_HOTELS;
    game.created_at = clock.unix_timestamp;
    game.bank_balance = 1_000_000; // Initial bank balance
    game.time_limit = None;
    game.winner = None;
    game.turn_started_at = clock.unix_timestamp;
    game.active_trades = vec![];
    game.next_trade_id = 0;
    game.entry_fee = entry_fee;

    game.initialize_properties();

    // Initialize player state
    player_state.initialize_player_state(ctx.accounts.creator.key(), game.key(), clock);

    // Add player to game
    game.players.push(player_state.wallet);
    game.current_players = game.players.len() as u8;

    msg!(
        "Game initialized by creator: {}",
        ctx.accounts.creator.key()
    );
    msg!("Game account: {}", game.key());
    msg!("Game created at timestamp: {}", game.created_at);

    Ok(())
}

#[derive(Accounts)]
pub struct JoinGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::WaitingForPlayers @ GameError::GameNotInProgress,
        constraint = game.current_players < MAX_PLAYERS @ GameError::MaxPlayersReached
    )]
    pub game: Box<Account<'info, GameState>>,

    #[account(
        init,
        payer = player,
        space = 8 + PlayerState::INIT_SPACE + 64,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Box<Account<'info, PlayerState>>,

    #[account(mut)]
    pub player: Signer<'info>,

    // pub game_authority: Option<UncheckedAccount<'info>>,
    /// CHECK: game authority PDA - only required for paid games
    #[account(
        seeds = [
            GAME_AUTHORITY_SEED.as_ref(),
        ],
        bump,
    )]
    pub game_authority: UncheckedAccount<'info>,

    #[account(
        mint::token_program = token_program,
    )]
    // pub token_mint: Option<InterfaceAccount<'info, Mint>>,
    pub token_mint: Box<InterfaceAccount<'info, Mint>>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = player,
        associated_token::token_program = token_program
    )]
    // pub player_token_account: Option<InterfaceAccount<'info, TokenAccount>>,
    pub player_token_account: Box<InterfaceAccount<'info, TokenAccount>>,

    #[account(
        mut,
        token::mint = token_mint,
        token::authority = game_authority,
        token::token_program = token_program,
    )]
    // pub token_vault: Option<InterfaceAccount<'info, TokenAccount>>,
    pub token_vault: Box<InterfaceAccount<'info, TokenAccount>>,

    // pub token_program: Option<Interface<'info, TokenInterface>>,
    pub token_program: Interface<'info, TokenInterface>,
    // pub associated_token_program: Option<Program<'info, AssociatedToken>>,
    pub associated_token_program: Program<'info, AssociatedToken>,

    pub system_program: Program<'info, System>,
    pub clock: Sysvar<'info, Clock>,
}

pub fn join_game_handler(ctx: Context<JoinGame>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    msg!("Join game: {}", game.key());
    msg!("Player: {}", player_pubkey);

    // Check if player already exists in game
    for existing_player in &game.players {
        msg!("Existing player: {}", existing_player);
        if *existing_player == player_pubkey {
            return Err(GameError::PlayerAlreadyExists.into());
        }
    }

    // Handle entry fee payment if game has entry fee
    if game.entry_fee > 0 {
        // require!(
        //     ctx.accounts.game_authority.is_some()
        //         && ctx.accounts.token_mint.is_some()
        //         && ctx.accounts.player_token_account.is_some()
        //         && ctx.accounts.token_vault.is_some()
        //         && ctx.accounts.token_program.is_some(),
        //     GameError::MissingTokenAccounts
        // );

        // let token_mint = ctx.accounts.token_mint.as_ref().unwrap();
        let token_mint = &ctx.accounts.token_mint;
        let player_token_account = &ctx.accounts.player_token_account;
        let token_vault = &ctx.accounts.token_vault;
        let game_authority = &ctx.accounts.game_authority;

        // Validate game authority PDA
        let (expected_game_authority, _) =
            Pubkey::find_program_address(&[GAME_AUTHORITY_SEED], ctx.program_id);

        require!(
            game_authority.key() == expected_game_authority,
            GameError::InvalidGameAuthority
        );

        // Validate token accounts
        require!(
            player_token_account.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            player_token_account.owner == ctx.accounts.player.key(),
            GameError::InvalidTokenAccount
        );

        require!(
            token_vault.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            token_vault.owner == game_authority.key(),
            GameError::InvalidTokenAccount
        );

        // Validate that the token accounts match the game's configuration
        require!(
            Some(token_mint.key()) == game.token_mint,
            GameError::InvalidTokenAccount
        );
        require!(
            Some(token_vault.key()) == game.token_vault,
            GameError::InvalidTokenAccount
        );

        // Transfer entry fee from player to vault
        let transfer_accounts = TransferChecked {
            from: player_token_account.to_account_info(),
            mint: token_mint.to_account_info(),
            to: token_vault.to_account_info(),
            authority: ctx.accounts.player.to_account_info(),
        };

        let transfer_ctx = CpiContext::new(
            ctx.accounts
                .token_program
                .as_ref()
                // .unwrap()
                .to_account_info(),
            transfer_accounts,
        );

        transfer_checked(transfer_ctx, game.entry_fee, token_mint.decimals)?;

        // Update total prize pool
        game.total_prize_pool = game
            .total_prize_pool
            .checked_add(game.entry_fee)
            .ok_or(GameError::ArithmeticOverflow)?;

        msg!(
            "Entry fee {} paid by player {}",
            game.entry_fee,
            player_pubkey
        );
        msg!("Total prize pool: {}", game.total_prize_pool);
    }
    // else {
    //     // For free games, ensure no token accounts are provided
    //     require!(
    //         ctx.accounts.game_authority.is_none()
    //             && ctx.accounts.token_mint.is_none()
    //             && ctx.accounts.player_token_account.is_none()
    //             && ctx.accounts.token_vault.is_none()
    //             && ctx.accounts.token_program.is_none(),
    //         GameError::UnexpectedTokenAccounts
    //     );
    // }

    // Initialize player state
    player_state.initialize_player_state(player_pubkey, game.key(), clock);

    // Add player to game
    game.players.push(player_pubkey);
    game.current_players = game.players.len() as u8;

    msg!(
        "Player {} joined game. Total players: {}",
        player_pubkey,
        game.current_players
    );

    // Auto-start game if we have minimum players and all slots filled
    if game.current_players >= MIN_PLAYERS {
        msg!("Minimum players reached. Game can be started.");
    }

    emit!(PlayerJoined {
        game: game.key(),
        player: player_pubkey,
        player_index: game.current_players - 1,
        total_players: game.current_players,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

#[delegate]
#[derive(Accounts)]
pub struct StartGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump,
        constraint = game.game_status == GameStatus::WaitingForPlayers @ GameError::GameNotInProgress,
        constraint = game.current_players >= MIN_PLAYERS @ GameError::MinPlayersNotMet,
        constraint = authority.key() == game.creator @ GameError::Unauthorized,
        del
    )]
    pub game: Box<Account<'info, GameState>>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn start_game_handler<'c: 'info, 'info>(
    ctx: Context<'_, '_, 'c, 'info, StartGame<'info>>,
) -> Result<()> {
    {
        let game = &mut ctx.accounts.game;
        let clock = &ctx.accounts.clock;

        // Change game status to in progress
        game.game_status = GameStatus::InProgress;
        game.current_turn = 0; // First player starts
        game.turn_started_at = clock.unix_timestamp;

        msg!("Game started! Player {} goes first.", game.players[0]);
        msg!("Total players in game: {}", game.current_players);
    }

    {
        msg!("Start delegate");

        let authority = &ctx.accounts.authority;
        let owner_program = &ctx.accounts.owner_program;
        let delegation_program = &ctx.accounts.delegation_program;
        let game = &ctx.accounts.game;
        let game_key = game.key();
        let players = &game.players;

        game.exit(&crate::ID)?;
        ctx.accounts.delegate_game(
            &ctx.accounts.authority,
            &[
                b"game",
                game.config_id.as_ref(),
                &game.game_id.to_le_bytes(),
            ],
            DelegateConfig {
                commit_frequency_ms: 30_000,
                validator: Some(pubkey!("MAS1Dt9qreoRMQ14YQuhg8UTZMMzDdKhmkZMECCzk57")),
            },
        )?;

        let remaining_accounts_iter = &mut ctx.remaining_accounts.iter();

        // delegate player accounts
        for player_pubkey in players.iter() {
            let player_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;
            player_account.exit(&crate::ID)?;

            let player_buffer_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;

            let player_delegation_record_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;

            let player_delegation_metadata_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;

            let del_accounts = ephemeral_rollups_sdk::cpi::DelegateAccounts {
                payer: &authority.to_account_info(),
                pda: &player_account.to_account_info(),
                owner_program: &owner_program.to_account_info(),
                buffer: player_buffer_account,
                delegation_record: player_delegation_record_account,
                delegation_metadata: player_delegation_metadata_account,
                delegation_program: &delegation_program.to_account_info(),
                system_program: &ctx.accounts.system_program.to_account_info(),
            };

            let seeds = &[b"player", game_key.as_ref(), player_pubkey.as_ref()];

            let config = DelegateConfig {
                commit_frequency_ms: 30_000,
                validator: Some(pubkey!("MAS1Dt9qreoRMQ14YQuhg8UTZMMzDdKhmkZMECCzk57")),
            };

            ephemeral_rollups_sdk::cpi::delegate_account(del_accounts, seeds, config)?;

            msg!("Player {} delegated", player_pubkey);
        }
    }

    msg!("Game started!");

    let game = &ctx.accounts.game;
    let clock = &ctx.accounts.clock;
    emit!(GameStarted {
        game: game.key(),
        game_id: game.game_id,
        total_players: game.current_players,
        first_player: game.players[0],
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

// end_game.rs
use crate::error::GameError;
use crate::state::*;
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct EndGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Box<Account<'info, GameState>>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn end_game_handler(ctx: Context<EndGame>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let clock = &ctx.accounts.clock;

    // Check if game should end (only one player remaining)
    let active_players = count_active_players(game);

    if active_players <= 1 {
        // End the game
        game.game_status = GameStatus::Finished;

        if active_players == 1 {
            // Find the remaining active player and declare them winner
            if let Some(winner_pubkey) = find_last_active_player(game) {
                game.winner = Some(winner_pubkey);
                msg!("Game ended. Winner: {}", winner_pubkey);

                emit!(GameEnded {
                    game_id: game.game_id,
                    winner: Some(winner_pubkey),
                    ended_at: clock.unix_timestamp,
                });
            }
        } else {
            // No players remaining (shouldn't happen in normal gameplay)
            msg!("Game ended with no remaining players");

            emit!(GameEnded {
                game_id: game.game_id,
                winner: None,
                ended_at: clock.unix_timestamp,
            });
        }

        msg!("Game {} has ended", game.game_id);
    } else {
        return Err(GameError::GameCannotEnd.into());
    }

    // Emit GameEnded event
    emit!(GameEnded {
        game_id: game.game_id,
        winner: game.winner,
        ended_at: clock.unix_timestamp,
    });

    Ok(())
}

/// Count the number of active (non-bankrupt, non-default) players
fn count_active_players(game: &GameState) -> u8 {
    game.players
        .iter()
        .filter(|&&player| player != Pubkey::default())
        .count() as u8
}

/// Find the last remaining active player
fn find_last_active_player(game: &GameState) -> Option<Pubkey> {
    game.players
        .iter()
        .find(|&&player| player != Pubkey::default())
        .copied()
}

/// Check if the game should end based on current state
pub fn check_game_end_condition(game: &GameState) -> bool {
    count_active_players(game) <= 1
}

// end_turn.rs
use crate::error::GameError;
use crate::state::*;
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct EndTurn<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Box<Account<'info, GameState>>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Box<Account<'info, PlayerState>>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn end_turn_handler(ctx: Context<EndTurn>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Find player index in game.players vector
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    // Verify it's the current player's turn
    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Verify player has rolled dice
    if !player_state.has_rolled_dice {
        return Err(GameError::HasNotRolledDice.into());
    }

    // Check if player has pending actions that must be completed
    if player_state.needs_property_action {
        return Err(GameError::MustHandleSpecialSpace.into());
    }

    if player_state.needs_chance_card {
        return Err(GameError::MustHandleSpecialSpace.into());
    }

    if player_state.needs_community_chest_card {
        return Err(GameError::MustHandleSpecialSpace.into());
    }

    if player_state.needs_bankruptcy_check {
        return Err(GameError::MustDeclareBankruptcy.into());
    }

    // Reset turn-specific flags
    player_state.has_rolled_dice = false;
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;
    player_state.needs_bankruptcy_check = false;
    // Advance to next player
    player_state.doubles_count = 0; // Reset doubles count
    let next_turn = (game.current_turn + 1) % game.current_players;
    game.current_turn = next_turn;
    game.turn_started_at = clock.unix_timestamp;

    msg!("Turn ended. Next turn: Player {}", next_turn);

    Ok(())
}


// bankruptcy.rs
use crate::constants::get_property_data;
use crate::error::GameError;
use crate::instructions::end_game::check_game_end_condition;
use crate::{state::*, PlayerBankrupt};
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct DeclareBankruptcy<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Box<Account<'info, GameState>>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump,
        constraint = !player_state.is_bankrupt @ GameError::BankruptcyAlreadyStarted
    )]
    pub player_state: Box<Account<'info, PlayerState>>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn declare_bankruptcy_handler(ctx: Context<DeclareBankruptcy>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Find player index in game.players vector
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    // Verify it's the player's turn or they need bankruptcy check
    // if game.current_turn != player_index as u8 && !player_state.needs_bankruptcy_check {
    //     return Err(GameError::NotPlayerTurn.into());
    // }

    // Mark player as bankrupt
    player_state.is_bankrupt = true;

    // Calculate total liquidation value from properties
    let mut total_liquidation_value = 0u64;
    let mut houses_returned = 0u8;
    let mut hotels_returned = 0u8;

    // Process all properties owned by the player
    for &position in &player_state.properties_owned.clone() {
        // Get property from GameState
        let property = game.get_property_mut(position)?;

        // Verify this property belongs to the bankrupt player
        if property.owner == Some(player_pubkey) {
            // Get static property data for costs
            let property_data = get_property_data(position)?;

            // Calculate building liquidation value
            let building_value = calculate_building_liquidation_value(property, property_data)?;
            total_liquidation_value = total_liquidation_value
                .checked_add(building_value)
                .ok_or(GameError::ArithmeticOverflow)?;

            // Return buildings to bank
            if property.houses > 0 {
                houses_returned = houses_returned
                    .checked_add(property.houses)
                    .ok_or(GameError::ArithmeticOverflow)?;
                property.houses = 0;
            }

            if property.has_hotel {
                hotels_returned = hotels_returned
                    .checked_add(1)
                    .ok_or(GameError::ArithmeticOverflow)?;
                property.has_hotel = false;
            }

            // Calculate mortgage value if not already mortgaged
            if !property.is_mortgaged {
                let mortgage_value = property_data.mortgage_value;
                total_liquidation_value = total_liquidation_value
                    .checked_add(mortgage_value)
                    .ok_or(GameError::ArithmeticOverflow)?;
            }

            // Clear ownership
            property.owner = None;
            property.is_mortgaged = false;
        }
    }

    // Return buildings to bank
    game.houses_remaining = game
        .houses_remaining
        .checked_add(houses_returned)
        .ok_or(GameError::ArithmeticOverflow)?;

    game.hotels_remaining = game
        .hotels_remaining
        .checked_add(hotels_returned)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Add liquidation value to bank
    game.bank_balance = game
        .bank_balance
        .checked_add(total_liquidation_value)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Clear bankruptcy check flag
    player_state.needs_bankruptcy_check = false;

    // Transfer all remaining cash to the bank
    let remaining_cash = player_state.cash_balance;
    game.bank_balance = game
        .bank_balance
        .checked_add(remaining_cash)
        .ok_or(GameError::ArithmeticOverflow)?;

    player_state.cash_balance = 0;
    player_state.net_worth = 0;

    // Clear all properties owned from player state
    player_state.properties_owned.clear();

    // Clear Get Out of Jail Free cards
    player_state.get_out_of_jail_cards = 0;

    // Clear all player flags and reset position
    reset_player_state_for_bankruptcy(player_state);

    // Remove player from active game
    remove_player_from_game(game, player_index as u8)?;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} declared bankruptcy. Liquidated ${} in assets, ${} cash transferred to bank. {} houses and {} hotels returned to bank.",
        player_pubkey,
        total_liquidation_value,
        remaining_cash,
        houses_returned,
        hotels_returned
    );

    // Check if game should end (only one player remaining)
    if check_game_end_condition(game) {
        game.game_status = GameStatus::Finished;

        // Find the remaining player and declare them winner
        if let Some(winner_pubkey) = game
            .players
            .iter()
            .find(|&&p| p != Pubkey::default())
            .copied()
        {
            game.winner = Some(winner_pubkey);
            msg!("Game ended. Winner: {}", winner_pubkey);

            emit!(GameEnded {
                game_id: game.game_id,
                winner: Some(winner_pubkey),
                ended_at: clock.unix_timestamp,
            });
        } else {
            // No players remaining (shouldn't happen in normal gameplay)
            msg!("Game ended with no remaining players");

            emit!(GameEnded {
                game_id: game.game_id,
                winner: None,
                ended_at: clock.unix_timestamp,
            });
        }
    } else {
        // Advance to next player's turn
        if game.current_turn >= game.current_players {
            game.current_turn = 0;
        }
    }

    emit!(PlayerBankrupt {
        game: game.key(),
        player: player_pubkey,
        liquidation_value: total_liquidation_value,
        cash_transferred: remaining_cash,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}

fn calculate_building_liquidation_value(
    property: &PropertyInfo,
    property_data: &crate::constants::PropertyData,
) -> Result<u64> {
    let mut value = 0u64;

    // Houses sell for half their cost
    if property.houses > 0 {
        let house_value = (property_data.house_cost / 2) * property.houses as u64;
        value = value
            .checked_add(house_value)
            .ok_or(GameError::ArithmeticOverflow)?;
    }

    // Hotels sell for half their cost (house_cost * 5 / 2)
    if property.has_hotel {
        let hotel_value = (property_data.house_cost * 5) / 2;
        value = value
            .checked_add(hotel_value)
            .ok_or(GameError::ArithmeticOverflow)?;
    }

    Ok(value)
}

fn reset_player_state_for_bankruptcy(player_state: &mut PlayerState) {
    player_state.has_rolled_dice = false;
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;
    player_state.doubles_count = 0;
    player_state.in_jail = false;
    player_state.jail_turns = 0;
    player_state.position = 0; // Reset to GO
    player_state.festival_boost_turns = 0;
    player_state.card_drawn_at = None;
}

fn remove_player_from_game(game: &mut GameState, player_index: u8) -> Result<()> {
    // Remove player from the players array by setting to default
    if (player_index as usize) < game.players.len() {
        game.players[player_index as usize] = Pubkey::default();
    }

    // Decrease current players count
    game.current_players = game
        .current_players
        .checked_sub(1)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Adjust current_turn if necessary
    if game.current_turn >= game.current_players && game.current_players > 0 {
        game.current_turn = 0;
    }

    msg!(
        "Player at index {} removed from game. Remaining players: {}",
        player_index,
        game.current_players
    );

    Ok(())
}

// property.rs

#[derive(Accounts)]
pub struct BuyPropertyV2<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Box<Account<'info, GameState>>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Box<Account<'info, PlayerState>>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn buy_property_v2_handler(ctx: Context<BuyPropertyV2>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    require!(
        game.current_turn == player_index as u8,
        GameError::NotPlayerTurn
    );

    // Validate player position
    require!(
        player_state.position == position,
        GameError::InvalidPropertyPosition
    );

    // Get static property data
    let property_data = get_property_data(position)?;

    // Validate property is purchasable
    require!(
        is_property_purchasable(position),
        GameError::PropertyNotPurchasable
    );

    let property = game.get_property_mut(position)?;

    require!(property.owner.is_none(), GameError::PropertyAlreadyOwned);

    require!(
        player_state.cash_balance >= property_data.price,
        GameError::InsufficientFunds
    );

    // Transfer ownership
    property.owner = Some(player_pubkey);

    // Deduct money
    player_state.cash_balance = player_state
        .cash_balance
        .checked_sub(property_data.price)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Update player's properties list
    if !player_state.properties_owned.contains(&position) {
        player_state.properties_owned.push(position);
    }

    // Update net worth
    player_state.net_worth = player_state
        .net_worth
        .checked_add(property_data.price)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Clear flags
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;

    // Update timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} purchased property {} for ${}",
        player_pubkey,
        position,
        property_data.price
    );

    emit!(PropertyPurchased {
        game: game.key(),
        player: player_pubkey,
        property_position: position,
        price: property_data.price,
        timestamp: clock.unix_timestamp,
    });

    Ok(())
}
