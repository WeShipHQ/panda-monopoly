// lib.rs
#![allow(unexpected_cfgs)]
pub mod constants;
pub mod error;
pub mod instructions;
pub mod state;
pub mod utils;

use anchor_lang::prelude::*;
use ephemeral_rollups_sdk::anchor::ephemeral;

pub use constants::*;
pub use instructions::*;
pub use state::*;
pub use utils::*;

declare_id!("4vucUqMcXN4sgLsgnrXTUC9U7ACZ5DmoRBLbWt4vrnyR");

#[program]
#[ephemeral]
pub mod panda_monopoly {
    use super::*;

    // Platform instructions
    pub fn create_platform_config(
        ctx: Context<CreatePlatformConfig>,
        platform_id: Pubkey,
        fee_basis_points: u16,
        fee_vault: Pubkey,
    ) -> Result<()> {
        instructions::platform::create_platform_config_handler(
            ctx,
            platform_id,
            fee_basis_points,
            fee_vault,
        )
    }

    pub fn update_platform_config(
        ctx: Context<UpdatePlatformConfig>,
        fee_basis_points: Option<u16>,
        fee_vault: Option<Pubkey>,
    ) -> Result<()> {
        instructions::platform::update_platform_config_handler(ctx, fee_basis_points, fee_vault)
    }

    // Game management instructions
    pub fn initialize_game(ctx: Context<InitializeGame>, entry_fee: u64) -> Result<()> {
        instructions::initialize::initialize_game_handler(ctx, entry_fee)
    }

    pub fn reset_game_handler<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, ResetGame<'info>>,
    ) -> Result<()> {
        instructions::initialize::reset_game_handler(ctx)
    }

    pub fn undelegate_game_handler<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, UndelegateGame<'info>>,
    ) -> Result<()> {
        instructions::initialize::undelegate_game_handler(ctx)
    }

    pub fn close_game_handler<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, CloseGame<'info>>,
    ) -> Result<()> {
        instructions::initialize::close_game_handler(ctx)
    }

    pub fn join_game(ctx: Context<JoinGame>) -> Result<()> {
        instructions::initialize::join_game_handler(ctx)
    }

    pub fn start_game<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, StartGame<'info>>,
    ) -> Result<()> {
        instructions::initialize::start_game_handler(ctx)
    }

    // Game ending instruction
    pub fn end_game(ctx: Context<EndGame>) -> Result<()> {
        instructions::end_game::end_game_handler(ctx)
    }

    // Dice and movement instructions
    pub fn roll_dice(ctx: Context<RollDice>, dice_roll: Option<[u8; 2]>) -> Result<()> {
        instructions::dice::roll_dice_handler(ctx, dice_roll)
    }

    pub fn roll_dice_vrf_handler(
        ctx: Context<RollDiceVrf>,
        seed: u8,
        dice_roll: Option<[u8; 2]>,
    ) -> Result<()> {
        instructions::dice::roll_dice_vrf_handler(ctx, seed, dice_roll)
    }

    pub fn callback_roll_dice(
        ctx: Context<CallbackRollDiceCtx>,
        randomness: [u8; 32],
    ) -> Result<()> {
        instructions::dice::callback_roll_dice(ctx, randomness)
    }

    pub fn draw_chance_card_vrf_handler(
        ctx: Context<DrawChanceCardVrf>,
        client_seed: u8,
        card_index: Option<u8>,
    ) -> Result<()> {
        instructions::special_spaces::draw_chance_card_vrf_handler(ctx, client_seed, card_index)
    }

    pub fn callback_draw_chance_card(
        ctx: Context<CallbackDrawChanceCardCtx>,
        randomness: [u8; 32],
    ) -> Result<()> {
        instructions::special_spaces::callback_draw_chance_card(ctx, randomness)
    }

    pub fn callback_draw_community_chest_card(
        ctx: Context<CallbackDrawCommunityChestCardCtx>,
        randomness: [u8; 32],
    ) -> Result<()> {
        instructions::special_spaces::callback_draw_community_chest_card(ctx, randomness)
    }

    pub fn end_turn(ctx: Context<EndTurn>) -> Result<()> {
        instructions::end_turn::end_turn_handler(ctx)
    }

    pub fn pay_jail_fine(ctx: Context<PayJailFine>) -> Result<()> {
        instructions::jail::pay_jail_fine_handler(ctx)
    }

    pub fn use_get_out_of_jail_card(ctx: Context<UseGetOutOfJailCard>) -> Result<()> {
        instructions::jail::use_get_out_of_jail_card_handler(ctx)
    }

    // Bankruptcy instruction
    pub fn declare_bankruptcy<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, DeclareBankruptcy<'info>>,
    ) -> Result<()> {
        instructions::bankruptcy::declare_bankruptcy_handler(ctx)
    }

    // Tax instructions
    pub fn pay_mev_tax_handler(ctx: Context<PayTax>) -> Result<()> {
        instructions::special_spaces::pay_mev_tax_handler(ctx)
    }

    pub fn pay_priority_fee_tax_handler(ctx: Context<PayTax>) -> Result<()> {
        instructions::special_spaces::pay_priority_fee_tax_handler(ctx)
    }

    pub fn draw_chance_card(ctx: Context<DrawChanceCard>, card_index: Option<u8>) -> Result<()> {
        instructions::special_spaces::draw_chance_card_handler(ctx, card_index)
    }

    pub fn draw_community_chest_card(
        ctx: Context<DrawCommunityChestCard>,
        client_seed: Option<u8>,
        card_index: Option<u8>,
    ) -> Result<()> {
        instructions::special_spaces::draw_community_chest_card_handler(
            ctx,
            client_seed,
            card_index,
        )
    }

    pub fn collect_free_parking(ctx: Context<CollectFreeParking>) -> Result<()> {
        instructions::special_spaces::collect_free_parking_handler(ctx)
    }

    pub fn visit_beach_resort(ctx: Context<VisitBeachResort>) -> Result<()> {
        instructions::special_spaces::visit_beach_resort_handler(ctx)
    }

    pub fn attend_festival(ctx: Context<AttendFestival>) -> Result<()> {
        instructions::special_spaces::attend_festival_handler(ctx)
    }

    // Property instructions
    pub fn init_property_handler(
        ctx: Context<InitProperty>,
        game_key: Pubkey,
        position: u8,
    ) -> Result<()> {
        instructions::property::init_property_handler(ctx, game_key, position)
    }

    pub fn buy_property(ctx: Context<BuyProperty>, position: u8) -> Result<()> {
        instructions::property::buy_property_handler(ctx, position)
    }

    pub fn decline_property(ctx: Context<DeclineProperty>, position: u8) -> Result<()> {
        instructions::property::decline_property_handler(ctx, position)
    }

    pub fn pay_rent(ctx: Context<PayRent>, position: u8) -> Result<()> {
        instructions::property::pay_rent_handler(ctx, position)
    }

    pub fn build_house(ctx: Context<BuildHouse>, position: u8) -> Result<()> {
        instructions::property::build_house_handler(ctx, position)
    }

    pub fn build_hotel(ctx: Context<BuildHotel>, position: u8) -> Result<()> {
        instructions::property::build_hotel_handler(ctx, position)
    }

    pub fn sell_building(
        ctx: Context<SellBuilding>,
        position: u8,
        building_type: BuildingType,
    ) -> Result<()> {
        instructions::property::sell_building_handler(ctx, position, building_type)
    }

    pub fn mortgage_property(ctx: Context<MortgageProperty>, position: u8) -> Result<()> {
        instructions::property::mortgage_property_handler(ctx, position)
    }

    pub fn unmortgage_property(ctx: Context<UnmortgageProperty>, position: u8) -> Result<()> {
        instructions::property::unmortgage_property_handler(ctx, position)
    }

    // Trading instructions
    pub fn create_trade(
        ctx: Context<CreateTrade>,
        trade_type: TradeType,
        proposer_money: u64,
        receiver_money: u64,
        proposer_property: Option<u8>,
        receiver_property: Option<u8>,
    ) -> Result<()> {
        instructions::trading::create_trade_handler(
            ctx,
            trade_type,
            proposer_money,
            receiver_money,
            proposer_property,
            receiver_property,
        )
    }

    pub fn accept_trade(ctx: Context<AcceptTrade>, trade_id: u8) -> Result<()> {
        instructions::trading::accept_trade_handler(ctx, trade_id)
    }

    pub fn reject_trade(ctx: Context<RejectTrade>, trade_id: u8) -> Result<()> {
        instructions::trading::reject_trade_handler(ctx, trade_id)
    }

    pub fn cancel_trade(ctx: Context<CancelTrade>, trade_id: u8) -> Result<()> {
        instructions::trading::cancel_trade_handler(ctx, trade_id)
    }

    pub fn cleanup_expired_trades(ctx: Context<CleanupExpiredTrades>) -> Result<()> {
        instructions::trading::cleanup_expired_trades_handler(ctx)
    }
}


// utils.rs
use anchor_lang::prelude::*;

use crate::{
    error::GameError, ColorGroup, GameState, PlayerState, PropertyState, PropertyType,
    JAIL_POSITION,
};

// Helper function for rent calculation
pub fn calculate_rent_for_property(
    property_state: &PropertyState,
    owner_state: &PlayerState,
    dice_result: [u8; 2],
) -> Result<u64> {
    match property_state.property_type {
        PropertyType::Street => {
            if property_state.has_hotel {
                Ok(property_state.rent_with_hotel as u64)
            } else if property_state.houses > 0 {
                let house_index = (property_state.houses - 1) as usize;
                if house_index < property_state.rent_with_houses.len() {
                    Ok(property_state.rent_with_houses[house_index] as u64)
                } else {
                    Err(GameError::InvalidHouseCount.into())
                }
            } else {
                // Check for monopoly to double rent
                if has_color_group_monopoly(owner_state, property_state.color_group) {
                    Ok(property_state.rent_with_color_group as u64)
                } else {
                    Ok(property_state.rent_base as u64)
                }
            }
        }
        PropertyType::Railroad => {
            // Count railroads owned by the owner
            let railroads_owned = count_railroads_owned(owner_state);
            let base_rent = property_state.rent_base as u64;

            match railroads_owned {
                1 => Ok(base_rent),
                2 => Ok(base_rent * 2),
                3 => Ok(base_rent * 4),
                4 => Ok(base_rent * 8),
                _ => Ok(base_rent),
            }
        }
        PropertyType::Utility => {
            // Count utilities owned by the owner
            let utilities_owned = count_utilities_owned(owner_state);
            let dice_sum = (dice_result[0] + dice_result[1]) as u64;

            let multiplier = if utilities_owned == 1 { 4 } else { 10 };
            Ok(dice_sum * multiplier)
        }
        _ => Ok(0), // No rent for other property types
    }
}

// Helper function to check if owner has monopoly on color group
fn has_color_group_monopoly(owner_state: &PlayerState, color_group: ColorGroup) -> bool {
    let properties_in_group = get_color_group_properties(color_group);

    properties_in_group
        .iter()
        .all(|&position| owner_state.properties_owned.contains(&position))
}

// Helper function to count railroads owned
fn count_railroads_owned(owner_state: &PlayerState) -> u8 {
    let railroad_positions = [5, 15, 25, 35]; // Railroad positions on the board

    railroad_positions
        .iter()
        .filter(|&&pos| owner_state.properties_owned.contains(&pos))
        .count() as u8
}

// Helper function to count utilities owned
fn count_utilities_owned(owner_state: &PlayerState) -> u8 {
    let utility_positions = [12, 28]; // Electric Company and Water Works

    utility_positions
        .iter()
        .filter(|&&pos| owner_state.properties_owned.contains(&pos))
        .count() as u8
}

// Helper function to get properties in a color group
fn get_color_group_properties(color_group: ColorGroup) -> Vec<u8> {
    match color_group {
        ColorGroup::Brown => vec![1, 3],
        ColorGroup::LightBlue => vec![6, 8, 9],
        ColorGroup::Pink => vec![11, 13, 14],
        ColorGroup::Orange => vec![16, 18, 19],
        ColorGroup::Red => vec![21, 23, 24],
        ColorGroup::Yellow => vec![26, 27, 29],
        ColorGroup::Green => vec![31, 32, 34],
        ColorGroup::DarkBlue => vec![37, 39],
        ColorGroup::Railroad => vec![5, 15, 25, 35],
        ColorGroup::Utility => vec![12, 28],
        ColorGroup::Special => vec![], // No properties in special group
    }
}

// Helper functions for building validation
pub fn has_monopoly_for_player(player_state: &PlayerState, color_group: ColorGroup) -> bool {
    let properties_in_group = get_color_group_properties(color_group);

    properties_in_group
        .iter()
        .all(|&pos| player_state.properties_owned.contains(&pos))
}

pub fn can_build_evenly_for_player(
    _player_state: &PlayerState,
    color_group: ColorGroup,
    _target_position: u8,
    _target_houses: u8,
) -> bool {
    let _properties_in_group = get_color_group_properties(color_group);

    // For this simplified version, we'll assume even building is allowed
    // In a full implementation, you'd need to check other properties in the group
    // This would require additional property state lookups
    true
}

pub fn can_sell_evenly_for_player(
    _player_state: &PlayerState,
    color_group: ColorGroup,
    _target_position: u8,
    _target_houses: u8,
) -> bool {
    let _properties_in_group = get_color_group_properties(color_group);

    // For this simplified version, we'll assume even selling is allowed
    // In a full implementation, you'd need to check other properties in the group
    // This would require additional property state lookups
    true
}

// Helper function to generate random card index
pub fn generate_card_index(
    recent_blockhashes: &UncheckedAccount,
    timestamp: i64,
    deck_size: usize,
) -> Result<usize> {
    // Get recent blockhash data for randomness
    let data = recent_blockhashes.try_borrow_data()?;

    // Use a combination of blockhash and timestamp for randomness
    let mut seed_bytes = [0u8; 32];

    // Take first 24 bytes from recent blockhash data
    if data.len() >= 24 {
        seed_bytes[..24].copy_from_slice(&data[..24]);
    }

    // Add timestamp to last 8 bytes
    let timestamp_bytes = timestamp.to_le_bytes();
    seed_bytes[24..].copy_from_slice(&timestamp_bytes);

    // Generate random index
    let random_value =
        u32::from_le_bytes([seed_bytes[0], seed_bytes[1], seed_bytes[2], seed_bytes[3]]);

    Ok((random_value as usize) % deck_size)
}

// Helper function for generating random seed (similar to dice roll generation)
pub fn generate_random_seed(recent_blockhashes: &UncheckedAccount, timestamp: i64) -> Result<u64> {
    let recent_blockhashes_data = recent_blockhashes.try_borrow_data()?;

    if recent_blockhashes_data.len() < 8 {
        return Err(GameError::RandomnessUnavailable.into());
    }

    let mut seed_bytes = [0u8; 8];
    seed_bytes.copy_from_slice(&recent_blockhashes_data[0..8]);

    let blockhash_seed = u64::from_le_bytes(seed_bytes);
    let timestamp_seed = timestamp as u64;

    Ok(blockhash_seed.wrapping_mul(timestamp_seed))
}

pub fn xorshift64star(seed: u64) -> u64 {
    let mut x = seed;
    x ^= x << 12;
    x ^= x >> 25;
    x ^= x << 27;
    x = (x as u128 * 0x2545F4914F6CDD1D) as u64;
    x
}

// Replace the existing send_player_to_jail function with this enhanced version
pub fn send_player_to_jail_and_end_turn(
    game: &mut GameState,
    player_state: &mut PlayerState,
    clock: &Sysvar<Clock>,
) {
    // Send player to jail
    player_state.position = JAIL_POSITION;
    player_state.in_jail = true;
    player_state.jail_turns = 0;
    player_state.doubles_count = 0;

    // Clear any pending actions since player is going to jail
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;

    // Automatically end turn
    player_state.has_rolled_dice = false;

    // Advance to next player
    let next_turn = (game.current_turn + 1) % game.current_players;
    game.current_turn = next_turn;
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player sent to jail and turn ended automatically. Next turn: Player {}",
        next_turn
    );
}

pub fn send_player_to_jail(player_state: &mut PlayerState) {
    player_state.position = JAIL_POSITION;
    player_state.in_jail = true;
    player_state.jail_turns = 0;
    player_state.doubles_count = 0;

    // Clear any pending actions since player is going to jail
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;
}

pub fn force_end_turn(game: &mut GameState, player_state: &mut PlayerState, clock: &Sysvar<Clock>) {
    // Reset turn-specific flags
    player_state.has_rolled_dice = false;
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;

    // Reset doubles count when turn ends
    player_state.doubles_count = 0;

    // Advance to next player
    let next_turn = (game.current_turn + 1) % game.current_players;
    game.current_turn = next_turn;
    game.turn_started_at = clock.unix_timestamp;

    msg!("Turn automatically ended. Next turn: Player {}", next_turn);
}

// error.rs
use anchor_lang::prelude::*;

#[error_code]
pub enum GameError {
    // Game State Errors
    #[msg("Game has not been initialized")]
    GameNotInitialized,

    #[msg("Game has already been initialized")]
    GameAlreadyInitialized,

    #[msg("Game is not in progress")]
    GameNotInProgress,

    #[msg("Game has already ended")]
    GameAlreadyEnded,

    #[msg("Game cannot end - multiple players still active")]
    GameCannotEnd,

    #[msg("Maximum number of players reached")]
    MaxPlayersReached,

    #[msg("Minimum number of players not met")]
    MinPlayersNotMet,

    #[msg("Game cannot start with current player count")]
    CannotStartGame,

    // Player Errors
    #[msg("Player not found in game")]
    PlayerNotFound,

    #[msg("Player already exists in game")]
    PlayerAlreadyExists,

    #[msg("Not player's turn")]
    NotPlayerTurn,

    #[msg("Player is in jail")]
    PlayerInJail,

    #[msg("Player is not in jail")]
    PlayerNotInJail,

    #[msg("Player is bankrupt")]
    PlayerBankrupt,

    #[msg("Player has insufficient funds")]
    InsufficientFunds,

    #[msg("Player already rolled dice this turn")]
    AlreadyRolledDice,

    #[msg("Player has not rolled dice yet")]
    HasNotRolledDice,

    #[msg("Player must pay rent before ending turn")]
    MustPayRent,

    #[msg("Player must handle special space before ending turn")]
    MustHandleSpecialSpace,

    // Property Errors
    #[msg("Property not found")]
    PropertyNotFound,

    #[msg("Property is not purchasable")]
    PropertyNotPurchasable,

    #[msg("Property already owned")]
    PropertyAlreadyOwned,

    #[msg("Property not owned by player")]
    PropertyNotOwnedByPlayer,

    #[msg("Property is mortgaged")]
    PropertyMortgaged,

    #[msg("Property is not mortgaged")]
    PropertyNotMortgaged,

    #[msg("Cannot mortgage property with buildings")]
    CannotMortgageWithBuildings,

    #[msg("Player does not own all properties in color group")]
    DoesNotOwnColorGroup,

    #[msg("Cannot build on this property type")]
    CannotBuildOnPropertyType,

    #[msg("Maximum houses reached on property")]
    MaxHousesReached,

    #[msg("Property already has hotel")]
    PropertyHasHotel,

    #[msg("Must build houses evenly across color group")]
    MustBuildEvenly,

    #[msg("Must sell houses evenly across color group")]
    MustSellEvenly,

    #[msg("No houses to sell on property")]
    NoHousesToSell,

    #[msg("No hotel to sell on property")]
    NoHotelToSell,

    #[msg("Not enough houses available in bank")]
    NotEnoughHousesInBank,

    #[msg("Not enough hotels available in bank")]
    NotEnoughHotelsInBank,

    // Movement and Dice Errors
    #[msg("Invalid dice roll")]
    InvalidDiceRoll,

    #[msg("Invalid board position")]
    InvalidBoardPosition,

    #[msg("Invalid property position")]
    InvalidPropertyPosition,

    #[msg("Player rolled doubles too many times")]
    TooManyDoubles,

    // Trade Errors
    #[msg("Trade not found")]
    TradeNotFound,

    #[msg("Trade already exists")]
    TradeAlreadyExists,

    #[msg("Cannot trade with yourself")]
    CannotTradeWithSelf,

    #[msg("Trade has expired")]
    TradeExpired,

    #[msg("Trade already accepted")]
    TradeAlreadyAccepted,

    #[msg("Trade already rejected")]
    TradeAlreadyRejected,

    #[msg("Not authorized to accept/reject trade")]
    NotAuthorizedForTrade,

    #[msg("Cannot trade mortgaged properties")]
    CannotTradeMortgagedProperties,

    #[msg("Invalid trade proposal")]
    InvalidTradeProposal,

    // Auction Errors
    #[msg("Auction not found")]
    AuctionNotFound,

    #[msg("Auction already exists")]
    AuctionAlreadyExists,

    #[msg("Auction has expired")]
    AuctionExpired,

    #[msg("Auction has already ended")]
    AuctionAlreadyEnded,

    #[msg("Bid amount too low")]
    BidTooLow,

    #[msg("Cannot bid on own auction")]
    CannotBidOnOwnAuction,

    #[msg("Player already highest bidder")]
    AlreadyHighestBidder,

    // Rent Errors
    #[msg("No rent owed")]
    NoRentOwed,

    #[msg("Rent already paid")]
    RentAlreadyPaid,

    #[msg("Cannot collect rent from own property")]
    CannotCollectRentFromOwnProperty,

    #[msg("Cannot collect rent on mortgaged property")]
    CannotCollectRentOnMortgagedProperty,

    // Jail Errors
    #[msg("Cannot pay jail fine when not in jail")]
    CannotPayJailFineWhenNotInJail,

    #[msg("Maximum jail turns exceeded")]
    MaxJailTurnsExceeded,

    #[msg("Must roll doubles or pay fine to leave jail")]
    MustRollDoublesOrPayFine,

    #[msg("Player has no Get Out of Jail cards")]
    NoGetOutOfJailCards,

    // Special Space Errors
    #[msg("Invalid special space action")]
    InvalidSpecialSpaceAction,

    #[msg("Chance card not implemented")]
    ChanceCardNotImplemented,

    #[msg("Community chest card not implemented")]
    CommunityChestCardNotImplemented,

    // Tax Errors
    #[msg("Tax amount calculation error")]
    TaxCalculationError,

    #[msg("Cannot pay tax with insufficient funds")]
    CannotPayTax,

    // Bankruptcy Errors
    #[msg("Player must declare bankruptcy")]
    MustDeclareBankruptcy,

    #[msg("Cannot declare bankruptcy with sufficient assets")]
    CannotDeclareBankruptcyWithAssets,

    #[msg("Bankruptcy process already started")]
    BankruptcyAlreadyStarted,

    #[msg("Bankruptcy check not required")]
    BankruptcyNotRequired,

    // Account and Authorization Errors
    #[msg("Unauthorized action")]
    Unauthorized,

    #[msg("Invalid account provided")]
    InvalidAccount,

    #[msg("Account already initialized")]
    AccountAlreadyInitialized,

    #[msg("Account not initialized")]
    AccountNotInitialized,

    #[msg("Invalid signer")]
    InvalidSigner,

    // Math Errors
    #[msg("Arithmetic overflow")]
    ArithmeticOverflow,

    #[msg("Arithmetic underflow")]
    ArithmeticUnderflow,

    #[msg("Division by zero")]
    DivisionByZero,

    #[msg("Invalid parameter")]
    InvalidParameter,

    #[msg("Invalid game configuration")]
    InvalidGameConfiguration,

    // Randomness Errors
    #[msg("Failed to generate random number")]
    RandomnessGenerationFailed,

    #[msg("Invalid randomness source")]
    InvalidRandomnessSource,

    #[msg("Randomness unavailable")]
    RandomnessUnavailable,

    // Time Errors
    #[msg("Invalid timestamp")]
    InvalidTimestamp,

    #[msg("Clock not available")]
    ClockNotAvailable,

    #[msg("Action timeout exceeded")]
    ActionTimeoutExceeded,

    // General Errors
    #[msg("Operation not allowed in current game state")]
    OperationNotAllowed,

    #[msg("Feature not implemented")]
    FeatureNotImplemented,

    #[msg("Internal error occurred")]
    InternalError,

    #[msg("Invalid input data")]
    InvalidInputData,

    #[msg("Resource not available")]
    ResourceNotAvailable,

    #[msg("Property not owned")]
    PropertyNotOwned,

    #[msg("Invalid property owner")]
    InvalidPropertyOwner,

    #[msg("Invalid house count")]
    InvalidHouseCount,

    #[msg("Property already mortgaged")]
    PropertyAlreadyMortgaged,

    #[msg("Dice roll error")]
    DiceRollError,

    #[msg("Trade is not pending")]
    TradeNotPending,

    #[msg("Not the trade target")]
    NotTradeTarget,

    #[msg("Not the trade proposer")]
    NotTradeProposer,

    #[msg("Invalid trade type")]
    InvalidTradeType,

    #[msg("Auction is not active")]
    AuctionNotActive,

    #[msg("Auction has ended")]
    AuctionEnded,

    #[msg("Auction is still active")]
    AuctionStillActive,

    #[msg("Too many active trades")]
    TooManyActiveTrades,

    // Token and Fee Errors
    #[msg("Missing required token accounts for entry fee")]
    MissingTokenAccounts,

    #[msg("Invalid game authority PDA")]
    InvalidGameAuthority,

    #[msg("Invalid token vault PDA")]
    InvalidTokenVault,

    #[msg("Invalid token account")]
    InvalidTokenAccount,

    #[msg("Entry fee transfer failed")]
    EntryFeeTransferFailed,

    #[msg("Token accounts provided for free game")]
    UnexpectedTokenAccounts,
}


// constants.rs
use anchor_lang::prelude::*;

// Entry fee and vault constants
pub const GAME_AUTHORITY_SEED: &[u8] = b"game_authority";
pub const TOKEN_VAULT_SEED: &[u8] = b"token_vault";
pub const WINNER_PERCENTAGE: u16 = 9500; // 95%
pub const PLATFORM_PERCENTAGE: u16 = 100; // 1%

// Game configuration constants
pub const MAX_PLAYERS: u8 = 4;
pub const MIN_PLAYERS: u8 = 2;
pub const BOARD_SIZE: u8 = 40;
pub const STARTING_MONEY: u32 = 1500;
pub const GO_SALARY: u32 = 200;
pub const JAIL_FINE: u32 = 50;
pub const MAX_JAIL_TURNS: u8 = 3;

pub const MEV_TAX: u32 = 200;
pub const PRIORITY_FEE_TAX: u32 = 75;

pub const MEV_TAX_POSITION: u8 = 4;
pub const PRIORITY_FEE_TAX_POSITION: u8 = 38;

// Update existing constants
pub const BANKRUPTCY_THRESHOLD: u32 = 0;

// Railroad rent
pub const RAILROAD_BASE_RENT: u32 = 25;
pub const MAX_HOUSES_PER_PROPERTY: u8 = 4;
pub const TOTAL_HOUSES: u8 = 32;
pub const TOTAL_HOTELS: u8 = 12;

// Trading and auction constants
pub const MAX_PROPERTIES_IN_TRADE: usize = 10;
pub const TRADE_EXPIRY_SECONDS: i64 = 3600; // 1 hour
pub const MAX_ACTIVE_TRADES: usize = 20; // Maximum trades stored in GameState vector
pub const AUCTION_DURATION_SECONDS: i64 = 300; // 5 minutes

// Special space positions
pub const GO_POSITION: u8 = 0; // Solana Genesis
pub const JAIL_POSITION: u8 = 10; // Validator Jail
pub const GO_TO_JAIL_POSITION: u8 = 30; // Go To Validator Jail
pub const FREE_PARKING_POSITION: u8 = 20; // Free Airdrop Parking
                                          // pub const BEACH_RESORT_POSITION: u8 = 20; // Replaces Free Parking
pub const FESTIVAL_POSITION: u8 = 10; // Additional special space

// Chance and Community Chest positions (now themed)
pub const CHANCE_POSITIONS: [u8; 3] = [7, 22, 36]; // Pump.fun Surprise
pub const COMMUNITY_CHEST_POSITIONS: [u8; 3] = [2, 17, 33]; // Airdrop Chest

// Beach Resort and Festival positions (custom spaces)

// Seed for randomness
pub const RANDOMNESS_SEED: &[u8] = b"panda_monopoly_v1";
pub const BEACH_RESORT_BONUS_PER_PROPERTY: u32 = 10;
// pub const FREE_PARKING_POSITION: u8 = 20;
// pub const JAIL_POSITION: u8 = 10;

// Property Group Colors
pub const BROWN_GROUP: [u8; 2] = [1, 3];
pub const LIGHT_BLUE_GROUP: [u8; 3] = [6, 8, 9];
pub const PINK_GROUP: [u8; 3] = [11, 13, 14];
pub const ORANGE_GROUP: [u8; 3] = [16, 18, 19];
pub const RED_GROUP: [u8; 3] = [21, 23, 24];
pub const YELLOW_GROUP: [u8; 3] = [26, 27, 29];
pub const GREEN_GROUP: [u8; 3] = [31, 32, 34];
pub const DARK_BLUE_GROUP: [u8; 2] = [37, 39];
pub const RAILROAD_GROUP: [u8; 4] = [5, 15, 25, 35];
pub const UTILITY_GROUP: [u8; 2] = [12, 28];

// Property Data Structure
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, PartialEq)]
pub struct PropertyData {
    pub position: u8,
    pub price: u64,
    pub rent: [u64; 6], // Base rent, 1 house, 2 houses, 3 houses, 4 houses, hotel
    pub house_cost: u64,
    pub mortgage_value: u64,
    pub color_group: u8,
    pub property_type: u8, // 0: Street, 1: Railroad, 2: Utility, 3: Special
}

// Board Layout - All 40 spaces
pub const BOARD_SPACES: [PropertyData; 40] = [
    // Position 0 - Solana Genesis (GO)
    PropertyData {
        position: 0,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 1 - BONK Avenue (Brown Property)
    PropertyData {
        position: 1,
        price: 60,
        rent: [2, 10, 30, 90, 160, 250],
        house_cost: 50,
        mortgage_value: 30,
        color_group: 1,   // Brown
        property_type: 0, // Street
    },
    // Position 2 - Airdrop Chest
    PropertyData {
        position: 2,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 3 - WIF Lane (Brown Property)
    PropertyData {
        position: 3,
        price: 60,
        rent: [4, 20, 60, 180, 320, 450],
        house_cost: 50,
        mortgage_value: 30,
        color_group: 1,   // Brown
        property_type: 0, // Street
    },
    // Position 4 - MEV Tax
    PropertyData {
        position: 4,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 5 - Wormhole Bridge (Railroad)
    PropertyData {
        position: 5,
        price: 200,
        rent: [25, 50, 100, 200, 0, 0],
        house_cost: 0,
        mortgage_value: 100,
        color_group: 9,   // Railroad
        property_type: 1, // Railroad
    },
    // Position 6 - JUP Street (Light Blue Property)
    PropertyData {
        position: 6,
        price: 100,
        rent: [6, 30, 90, 270, 400, 550],
        house_cost: 50,
        mortgage_value: 50,
        color_group: 2,   // Light Blue
        property_type: 0, // Street
    },
    // Position 7 - Pump.fun Surprise
    PropertyData {
        position: 7,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 8 - RAY Boulevard (Light Blue Property)
    PropertyData {
        position: 8,
        price: 100,
        rent: [6, 30, 90, 270, 400, 550],
        house_cost: 50,
        mortgage_value: 50,
        color_group: 2,   // Light Blue
        property_type: 0, // Street
    },
    // Position 9 - ORCA Way (Light Blue Property)
    PropertyData {
        position: 9,
        price: 120,
        rent: [8, 40, 100, 300, 450, 600],
        house_cost: 50,
        mortgage_value: 60,
        color_group: 2,   // Light Blue
        property_type: 0, // Street
    },
    // Position 10 - Validator Jail
    PropertyData {
        position: 10,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 11 - SAGA Place (Pink Property)
    PropertyData {
        position: 11,
        price: 140,
        rent: [10, 50, 150, 450, 625, 750],
        house_cost: 50,
        mortgage_value: 70,
        color_group: 3,   // Pink
        property_type: 0, // Street
    },
    // Position 12 - Pyth Oracle (Utility)
    PropertyData {
        position: 12,
        price: 150,
        rent: [4, 10, 0, 0, 0, 0],
        house_cost: 0,
        mortgage_value: 75,
        color_group: 10,  // Utility
        property_type: 2, // Utility
    },
    // Position 13 - TENSOR Avenue (Pink Property)
    PropertyData {
        position: 13,
        price: 140,
        rent: [10, 50, 150, 450, 625, 750],
        house_cost: 100,
        mortgage_value: 70,
        color_group: 3,   // Pink
        property_type: 0, // Street
    },
    // Position 14 - MAGIC EDEN Street (Pink Property)
    PropertyData {
        position: 14,
        price: 160,
        rent: [12, 60, 180, 500, 700, 900],
        house_cost: 100,
        mortgage_value: 80,
        color_group: 3,   // Pink
        property_type: 0, // Street
    },
    // Position 15 - Allbridge (Railroad)
    PropertyData {
        position: 15,
        price: 200,
        rent: [25, 50, 100, 200, 0, 0],
        house_cost: 0,
        mortgage_value: 100,
        color_group: 9,   // Railroad
        property_type: 1, // Railroad
    },
    // Position 16 - HELIO Place (Orange Property)
    PropertyData {
        position: 16,
        price: 180,
        rent: [14, 70, 200, 550, 750, 950],
        house_cost: 100,
        mortgage_value: 90,
        color_group: 4,   // Orange
        property_type: 0, // Street
    },
    // Position 17 - Airdrop Chest
    PropertyData {
        position: 17,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 18 - KAMINO Avenue (Orange Property)
    PropertyData {
        position: 18,
        price: 180,
        rent: [14, 70, 200, 550, 750, 950],
        house_cost: 100,
        mortgage_value: 90,
        color_group: 4,   // Orange
        property_type: 0, // Street
    },
    // Position 19 - DRIFT Street (Orange Property)
    PropertyData {
        position: 19,
        price: 200,
        rent: [16, 80, 240, 600, 800, 1000],
        house_cost: 100,
        mortgage_value: 100,
        color_group: 4,   // Orange
        property_type: 0, // Street
    },
    // Position 20 - Free Airdrop Parking
    PropertyData {
        position: 20,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 21 - MANGO Markets (Red Property)
    PropertyData {
        position: 21,
        price: 220,
        rent: [18, 90, 270, 650, 850, 1050],
        house_cost: 150,
        mortgage_value: 110,
        color_group: 5,   // Red
        property_type: 0, // Street
    },
    // Position 22 - Pump.fun Surprise
    PropertyData {
        position: 22,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 23 - HUBBLE Avenue (Red Property)
    PropertyData {
        position: 23,
        price: 220,
        rent: [18, 90, 270, 650, 850, 1050],
        house_cost: 150,
        mortgage_value: 110,
        color_group: 5,   // Red
        property_type: 0, // Street
    },
    // Position 24 - MARINADE Street (Red Property)
    PropertyData {
        position: 24,
        price: 240,
        rent: [20, 100, 300, 750, 950, 1100],
        house_cost: 150,
        mortgage_value: 120,
        color_group: 5,   // Red
        property_type: 0, // Street
    },
    // Position 25 - LayerZero Bridge (Railroad)
    PropertyData {
        position: 25,
        price: 200,
        rent: [25, 50, 100, 200, 0, 0],
        house_cost: 0,
        mortgage_value: 100,
        color_group: 9,   // Railroad
        property_type: 1, // Railroad
    },
    // Position 26 - BACKPACK Avenue (Yellow Property)
    PropertyData {
        position: 26,
        price: 260,
        rent: [22, 110, 330, 850, 1050, 1200],
        house_cost: 150,
        mortgage_value: 120,
        color_group: 6,   // Yellow
        property_type: 0, // Street
    },
    // Position 27 - PHANTOM Street (Yellow Property)
    PropertyData {
        position: 27,
        price: 260,
        rent: [22, 110, 330, 850, 1050, 1200],
        house_cost: 150,
        mortgage_value: 130,
        color_group: 6,   // Yellow
        property_type: 0, // Street
    },
    // Position 28 - Switchboard Oracle (Utility)
    PropertyData {
        position: 28,
        price: 150,
        rent: [4, 10, 0, 0, 0, 0],
        house_cost: 0,
        mortgage_value: 75,
        color_group: 10,  // Utility
        property_type: 2, // Utility
    },
    // Position 29 - SOLFLARE Gardens (Yellow Property)
    PropertyData {
        position: 29,
        price: 280,
        rent: [24, 120, 360, 900, 1100, 1300],
        house_cost: 150,
        mortgage_value: 140,
        color_group: 6,   // Yellow
        property_type: 0, // Street
    },
    // Position 30 - Go To Validator Jail
    PropertyData {
        position: 30,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 31 - ANATOLY Avenue (Green Property)
    PropertyData {
        position: 31,
        price: 300,
        rent: [26, 130, 390, 900, 1100, 1300],
        house_cost: 200,
        mortgage_value: 150,
        color_group: 7,   // Green
        property_type: 0, // Street
    },
    // Position 32 - RAJ Street (Green Property)
    PropertyData {
        position: 32,
        price: 300,
        rent: [26, 130, 390, 900, 1100, 1300],
        house_cost: 200,
        mortgage_value: 150,
        color_group: 7,   // Green
        property_type: 0, // Street
    },
    // Position 33 - Airdrop Chest
    PropertyData {
        position: 33,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 34 - FIREDANCER Avenue (Green Property)
    PropertyData {
        position: 34,
        price: 320,
        rent: [28, 150, 450, 1000, 1200, 1400],
        house_cost: 200,
        mortgage_value: 160,
        color_group: 7,   // Green
        property_type: 0, // Street
    },
    // Position 35 - deBridge (Railroad)
    PropertyData {
        position: 35,
        price: 200,
        rent: [25, 50, 100, 200, 0, 0],
        house_cost: 0,
        mortgage_value: 100,
        color_group: 9,   // Railroad
        property_type: 1, // Railroad
    },
    // Position 36 - Pump.fun Surprise
    PropertyData {
        position: 36,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 37 - SVM Place (Dark Blue Property)
    PropertyData {
        position: 37,
        price: 350,
        rent: [35, 175, 500, 1100, 1400, 1500],
        house_cost: 200,
        mortgage_value: 175,
        color_group: 8,   // Dark Blue
        property_type: 0, // Street
    },
    // Position 38 - Priority Fee Tax
    PropertyData {
        position: 38,
        price: 0,
        rent: [0; 6],
        house_cost: 0,
        mortgage_value: 0,
        color_group: 0,
        property_type: 3, // Special
    },
    // Position 39 - SAGA Boardwalk (Dark Blue Property)
    PropertyData {
        position: 39,
        price: 400,
        rent: [50, 200, 600, 1200, 1600, 2000],
        house_cost: 200,
        mortgage_value: 200,
        color_group: 8,   // Dark Blue
        property_type: 0, // Street
    },
];

// Helper functions
pub fn get_property_data(position: u8) -> Option<&'static PropertyData> {
    if position < BOARD_SIZE {
        Some(&BOARD_SPACES[position as usize])
    } else {
        None
    }
}

pub fn is_property_purchasable(position: u8) -> bool {
    if let Some(property) = get_property_data(position) {
        property.price > 0
    } else {
        false
    }
}

pub fn get_color_group_properties_enum(color_group: crate::state::ColorGroup) -> Vec<u8> {
    use crate::state::ColorGroup;
    match color_group {
        ColorGroup::Brown => BROWN_GROUP.to_vec(),
        ColorGroup::LightBlue => LIGHT_BLUE_GROUP.to_vec(),
        ColorGroup::Pink => PINK_GROUP.to_vec(),
        ColorGroup::Orange => ORANGE_GROUP.to_vec(),
        ColorGroup::Red => RED_GROUP.to_vec(),
        ColorGroup::Yellow => YELLOW_GROUP.to_vec(),
        ColorGroup::Green => GREEN_GROUP.to_vec(),
        ColorGroup::DarkBlue => DARK_BLUE_GROUP.to_vec(),
        ColorGroup::Railroad => RAILROAD_GROUP.to_vec(),
        ColorGroup::Utility => UTILITY_GROUP.to_vec(),
        ColorGroup::Special => vec![], // Special spaces don't form groups
    }
}

pub fn get_color_group_properties(color_group: u8) -> Vec<u8> {
    match color_group {
        1 => BROWN_GROUP.to_vec(),
        2 => LIGHT_BLUE_GROUP.to_vec(),
        3 => PINK_GROUP.to_vec(),
        4 => ORANGE_GROUP.to_vec(),
        5 => RED_GROUP.to_vec(),
        6 => YELLOW_GROUP.to_vec(),
        7 => GREEN_GROUP.to_vec(),
        8 => DARK_BLUE_GROUP.to_vec(),
        9 => RAILROAD_GROUP.to_vec(),
        10 => UTILITY_GROUP.to_vec(),
        _ => vec![],
    }
}

pub fn calculate_railroad_rent(railroads_owned: u8) -> u64 {
    match railroads_owned {
        1 => 25,
        2 => 50,
        3 => 100,
        4 => 200,
        _ => 0,
    }
}

pub fn calculate_utility_rent(dice_roll: u8, utilities_owned: u8) -> u64 {
    let multiplier = if utilities_owned == 1 { 4 } else { 10 };
    (dice_roll as u64) * multiplier
}

// Card effect types for Solana-themed cards
#[derive(Clone, Copy, PartialEq)]
pub enum CardEffectType {
    Money,
    Move,
    GoToJail,
    GetOutOfJailFree,
    PayPerProperty,
    CollectFromPlayers,
    MoveToNearest, // For moving to nearest memecoin/railroad/utility
    RepairFree,    // For free repairs
}

impl From<CardEffectType> for u8 {
    fn from(effect_type: CardEffectType) -> Self {
        match effect_type {
            CardEffectType::Money => 0,
            CardEffectType::Move => 1,
            CardEffectType::GoToJail => 2,
            CardEffectType::GetOutOfJailFree => 3,
            CardEffectType::PayPerProperty => 4,
            CardEffectType::CollectFromPlayers => 5,
            CardEffectType::MoveToNearest => 6,
            CardEffectType::RepairFree => 7,
        }
    }
}

// Chance card structure (Pump.fun Surprise)
#[derive(Clone)]
pub struct ChanceCard {
    pub id: u8,
    pub effect_type: CardEffectType,
    pub amount: i32,
}

// Community Chest card structure (Airdrop Chest)
#[derive(Clone)]
pub struct CommunityChestCard {
    pub id: u8,
    pub effect_type: CardEffectType,
    pub amount: i32,
}

// Festival effect structure
#[derive(Clone)]
pub struct FestivalEffect {
    pub id: u8,
    pub amount: u32,
    pub is_positive: bool,
}

// Pump.fun Surprise Cards (Chance cards)
pub const CHANCE_CARDS: [ChanceCard; 5] = [
    ChanceCard {
        id: 1, // "Memecoin Pump!"
        effect_type: CardEffectType::MoveToNearest,
        amount: 1, // Move to nearest memecoin (BONK or WIF)
    },
    ChanceCard {
        id: 2, // "Rug Pull Alert!"
        effect_type: CardEffectType::Money,
        amount: -50,
    },
    ChanceCard {
        id: 3, // "Flash Loan Win"
        effect_type: CardEffectType::Money,
        amount: 100,
    },
    ChanceCard {
        id: 4, // "Congestion Jam"
        effect_type: CardEffectType::Move,
        amount: -3,
    },
    ChanceCard {
        id: 5, // "Dev Unlock"
        effect_type: CardEffectType::GetOutOfJailFree,
        amount: 0,
    },
];

// Airdrop Chest Cards (Community Chest cards)
pub const COMMUNITY_CHEST_CARDS: [CommunityChestCard; 5] = [
    CommunityChestCard {
        id: 1, // "Retroactive Airdrop!"
        effect_type: CardEffectType::CollectFromPlayers,
        amount: 50,
    },
    CommunityChestCard {
        id: 2, // "Staking Rewards"
        effect_type: CardEffectType::Money,
        amount: 100,
    },
    CommunityChestCard {
        id: 3, // "NFT Floor Sweep"
        effect_type: CardEffectType::Move,
        amount: 21, // Move to Free Airdrop Parking (position 21)
    },
    CommunityChestCard {
        id: 4, // "DAO Vote Win"
        effect_type: CardEffectType::RepairFree,
        amount: 0,
    },
    CommunityChestCard {
        id: 5, // "Wallet Drain Fee"
        effect_type: CardEffectType::Money,
        amount: -50,
    },
];

// Festival effects (keeping original structure but updating for Solana theme)
pub const FESTIVAL_EFFECTS: [FestivalEffect; 4] = [
    FestivalEffect {
        id: 1, // "Validator Performance Bonus"
        amount: 100,
        is_positive: true,
    },
    FestivalEffect {
        id: 2, // "Successful DeFi Yield"
        amount: 150,
        is_positive: true,
    },
    FestivalEffect {
        id: 3, // "NFT Royalty Income"
        amount: 75,
        is_positive: true,
    },
    FestivalEffect {
        id: 4, // "Ecosystem Grant Awarded"
        amount: 200,
        is_positive: true,
    },
    //     FestivalEffect {
    //         id: 5, // "Smart Contract Bug"
    //         amount: 50,
    //         is_positive: false,
    //     },
    //     FestivalEffect {
    //         id: 6, // "Network Congestion Fee"
    //         amount: 75,
    //         is_positive: false,
    //     },
    //     FestivalEffect {
    //         id: 7, // "Transaction Failed"
    //         amount: 25,
    //         is_positive: false,
    //     },
    //     FestivalEffect {
    //         id: 8, // "MEV Bot Frontrun"
    //         amount: 100,
    //         is_positive: false,
    //     },
    // ];
    // pub const CHANCE_CARDS: [ChanceCard; 16] = [
    //     ChanceCard {
    //         description: "Advance to GO (Collect $200)",
    //         effect_type: CardEffectType::Move,
    //         amount: 0,
    //     },
    //     ChanceCard {
    //         description: "Advance to Illinois Avenue",
    //         effect_type: CardEffectType::Move,
    //         amount: 24,
    //     },
    //     ChanceCard {
    //         description: "Advance to St. Charles Place",
    //         effect_type: CardEffectType::Move,
    //         amount: 11,
    //     },
    //     ChanceCard {
    //         description: "Advance token to nearest Utility",
    //         effect_type: CardEffectType::Move,
    //         amount: 12, // Electric Company
    //     },
    //     ChanceCard {
    //         description: "Advance token to nearest Railroad",
    //         effect_type: CardEffectType::Move,
    //         amount: 5, // Reading Railroad
    //     },
    //     ChanceCard {
    //         description: "Bank pays you dividend of $50",
    //         effect_type: CardEffectType::Money,
    //         amount: 50,
    //     },
    //     ChanceCard {
    //         description: "Get Out of Jail Free",
    //         effect_type: CardEffectType::GetOutOfJailFree,
    //         amount: 0,
    //     },
    //     ChanceCard {
    //         description: "Go Back 3 Spaces",
    //         effect_type: CardEffectType::Move,
    //         amount: -3,
    //     },
    //     ChanceCard {
    //         description: "Go to Jail",
    //         effect_type: CardEffectType::GoToJail,
    //         amount: 0,
    //     },
    //     ChanceCard {
    //         description: "Make general repairs on all your property",
    //         effect_type: CardEffectType::PayPerProperty,
    //         amount: 25, // $25 per house, $100 per hotel
    //     },
    //     ChanceCard {
    //         description: "Speeding fine $15",
    //         effect_type: CardEffectType::Money,
    //         amount: -15,
    //     },
    //     ChanceCard {
    //         description: "Take a trip to Reading Railroad",
    //         effect_type: CardEffectType::Move,
    //         amount: 5,
    //     },
    //     ChanceCard {
    //         description: "Take a walk on the Boardwalk",
    //         effect_type: CardEffectType::Move,
    //         amount: 39,
    //     },
    //     ChanceCard {
    //         description: "You have been elected Chairman of the Board",
    //         effect_type: CardEffectType::CollectFromPlayers,
    //         amount: 50,
    //     },
    //     ChanceCard {
    //         description: "Your building loan matures",
    //         effect_type: CardEffectType::Money,
    //         amount: 150,
    //     },
    //     ChanceCard {
    //         description: "You have won a crossword competition",
    //         effect_type: CardEffectType::Money,
    //         amount: 100,
    //     },
];

// // Community Chest cards
// pub const COMMUNITY_CHEST_CARDS: [CommunityChestCard; 16] = [
//     CommunityChestCard {
//         description: "Advance to GO (Collect $200)",
//         effect_type: CardEffectType::Move,
//         amount: 0,
//     },
//     CommunityChestCard {
//         description: "Bank error in your favor",
//         effect_type: CardEffectType::Money,
//         amount: 200,
//     },
//     CommunityChestCard {
//         description: "Doctor's fee",
//         effect_type: CardEffectType::Money,
//         amount: -50,
//     },
//     CommunityChestCard {
//         description: "From sale of stock you get $50",
//         effect_type: CardEffectType::Money,
//         amount: 50,
//     },
//     CommunityChestCard {
//         description: "Get Out of Jail Free",
//         effect_type: CardEffectType::GetOutOfJailFree,
//         amount: 0,
//     },
//     CommunityChestCard {
//         description: "Go to Jail",
//         effect_type: CardEffectType::GoToJail,
//         amount: 0,
//     },
//     CommunityChestCard {
//         description: "Holiday fund matures",
//         effect_type: CardEffectType::Money,
//         amount: 100,
//     },
//     CommunityChestCard {
//         description: "Income tax refund",
//         effect_type: CardEffectType::Money,
//         amount: 20,
//     },
//     CommunityChestCard {
//         description: "It is your birthday",
//         effect_type: CardEffectType::CollectFromPlayers,
//         amount: 10,
//     },
//     CommunityChestCard {
//         description: "Life insurance matures",
//         effect_type: CardEffectType::Money,
//         amount: 100,
//     },
//     CommunityChestCard {
//         description: "Pay hospital fees",
//         effect_type: CardEffectType::Money,
//         amount: -100,
//     },
//     CommunityChestCard {
//         description: "Pay school fees",
//         effect_type: CardEffectType::Money,
//         amount: -50,
//     },
//     CommunityChestCard {
//         description: "Receive $25 consultancy fee",
//         effect_type: CardEffectType::Money,
//         amount: 25,
//     },
//     CommunityChestCard {
//         description: "You are assessed for street repair",
//         effect_type: CardEffectType::PayPerProperty,
//         amount: 40, // $40 per house, $115 per hotel
//     },
//     CommunityChestCard {
//         description: "You have won second prize in a beauty contest",
//         effect_type: CardEffectType::Money,
//         amount: 10,
//     },
//     CommunityChestCard {
//         description: "You inherit $100",
//         effect_type: CardEffectType::Money,
//         amount: 100,
//     },
// ];

// // Festival effects
// pub const FESTIVAL_EFFECTS: [FestivalEffect; 8] = [
//     FestivalEffect {
//         description: "Great performance! Earn tips",
//         amount: 100,
//         is_positive: true,
//     },
//     FestivalEffect {
//         description: "Win dance competition",
//         amount: 150,
//         is_positive: true,
//     },
//     FestivalEffect {
//         description: "Food vendor success",
//         amount: 75,
//         is_positive: true,
//     },
//     FestivalEffect {
//         description: "Crowd loves your act",
//         amount: 200,
//         is_positive: true,
//     },
//     FestivalEffect {
//         description: "Equipment malfunction",
//         amount: 50,
//         is_positive: false,
//     },
//     FestivalEffect {
//         description: "Rain ruins your setup",
//         amount: 75,
//         is_positive: false,
//     },
//     FestivalEffect {
//         description: "Permit fees",
//         amount: 25,
//         is_positive: false,
//     },
//     FestivalEffect {
//         description: "Security deposit",
//         amount: 100,
//         is_positive: false,
//     },
// ];


// state/mod.rs
use anchor_lang::prelude::*;

mod events;
pub use events::*;

use crate::STARTING_MONEY;

#[account]
#[derive(InitSpace, Debug)]
pub struct PlatformConfig {
    pub id: Pubkey,
    pub fee_basis_points: u16, // 500 = 5%
    pub authority: Pubkey,
    pub fee_vault: Pubkey,
    pub total_games_created: u64,
    pub next_game_id: u64,
    pub bump: u8,
}

impl PlatformConfig {
    pub fn calculate_fee(&self, amount: u64) -> u64 {
        (amount * self.fee_basis_points as u64) / 10000
    }
}

#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq)]
pub enum GameStatus {
    WaitingForPlayers,
    InProgress,
    Finished,
}

#[derive(AnchorSerialize, AnchorDeserialize, Debug, InitSpace, Clone, PartialEq, Eq)]
pub enum TradeStatus {
    Pending,
    Accepted,
    Rejected,
    Cancelled,
    Expired,
}

#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq)]
pub enum ColorGroup {
    Brown,
    LightBlue,
    Pink,
    Orange,
    Red,
    Yellow,
    Green,
    DarkBlue,
    Railroad,
    Utility,
    Special,
}

#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq)]
pub enum PropertyType {
    Property,
    Street,
    Railroad,
    Utility,
    Corner,
    Chance,
    CommunityChest,
    Tax,
    Beach,
    Festival,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, PartialEq, Eq)]
pub enum BuildingType {
    House,
    Hotel,
}

// New simplified trade structure for storing in GameState vector
#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone)]
pub struct TradeInfo {
    pub id: u8,                        // Unique trade ID within the game
    pub proposer: Pubkey,              // Trade proposer
    pub receiver: Pubkey,              // Trade receiver
    pub trade_type: TradeType,         // Type of trade
    pub proposer_money: u64,           // Money offered by proposer
    pub receiver_money: u64,           // Money requested from receiver
    pub proposer_property: Option<u8>, // Property offered by proposer
    pub receiver_property: Option<u8>, // Property requested from receiver
    pub status: TradeStatus,           // Current trade status
    pub created_at: i64,               // Creation timestamp
    pub expires_at: i64,               // Expiration timestamp
}

#[account]
#[derive(Debug, InitSpace)]
pub struct GameState {
    pub game_id: u64,
    pub config_id: Pubkey,
    pub creator: Pubkey,   // 32 bytes - game creator
    pub bump: u8,            // 1 byte - PDA bump seed
    pub max_players: u8,     // 1 byte - maximum players (2-8)
    pub current_players: u8, // 1 byte - current player count
    pub current_turn: u8,    // 1 byte - whose turn (player index)
    #[max_len(4)]
    pub players: Vec<Pubkey>, // 32 * 8 = 256 bytes max
    pub created_at: i64,     // 8 bytes - game creation timestamp
    pub game_status: GameStatus, // 1 byte - current game status
    pub bank_balance: u64,   // 8 bytes - bank's money
    pub free_parking_pool: u64, // 8 bytes - parking pool
    pub houses_remaining: u8, // 1 byte - houses left in bank (32 total)
    pub hotels_remaining: u8, // 1 byte - hotels left in bank (12 total)
    pub time_limit: Option<i64>, // 9 bytes - optional time limit
    pub winner: Option<Pubkey>, // 33 bytes - game winner
    pub turn_started_at: i64, // 8 bytes - when current turn started

    // Entry fee fields
    pub entry_fee: u64, // 8 bytes - entry fee amount (0 for free games)
    pub token_mint: Option<Pubkey>, // 33 bytes - token mint for entry fee
    pub token_vault: Option<Pubkey>, // 33 bytes - vault holding entry fees
    pub total_prize_pool: u64, // 8 bytes - total collected fees

    #[max_len(20)]
    pub active_trades: Vec<TradeInfo>, // Vector of active trades
    pub next_trade_id: u8, // Next trade ID to assign

                           // #[max_len(40)]
                           // pub active_properties: Vec<PropertyState>, // Vector of active properties
                           // pub next_property_id: u8, // Next property ID to assign
}

impl GameState {
    pub fn cleanup_expired_trades(&mut self, current_time: i64) {
        self.active_trades.retain(|trade| {
            trade.expires_at > current_time && trade.status == TradeStatus::Pending
        });
    }

    pub fn find_trade_by_id(&self, trade_id: u8) -> Option<&TradeInfo> {
        self.active_trades.iter().find(|trade| trade.id == trade_id)
    }

    pub fn find_trade_by_id_mut(&mut self, trade_id: u8) -> Option<&mut TradeInfo> {
        self.active_trades
            .iter_mut()
            .find(|trade| trade.id == trade_id)
    }

    pub fn remove_trade_by_id(&mut self, trade_id: u8) -> bool {
        if let Some(pos) = self
            .active_trades
            .iter()
            .position(|trade| trade.id == trade_id)
        {
            self.active_trades.remove(pos);
            true
        } else {
            false
        }
    }

    pub fn can_add_trade(&self) -> bool {
        self.active_trades.len() < crate::constants::MAX_ACTIVE_TRADES
    }

    pub fn get_next_trade_id(&mut self) -> u8 {
        let id = self.next_trade_id;
        self.next_trade_id = self.next_trade_id.wrapping_add(1);
        id
    }
}

#[account]
#[derive(Debug, InitSpace)]
pub struct PlayerState {
    pub wallet: Pubkey,    // 32 bytes - player's wallet
    pub game: Pubkey,      // 32 bytes - game account
    pub cash_balance: u64, // 8 bytes - player's cash
    pub position: u8,      // 1 byte - board position (0-39)
    pub in_jail: bool,     // 1 byte - jail status
    pub jail_turns: u8,    // 1 byte - turns in jail
    pub doubles_count: u8, // 1 byte - consecutive doubles
    pub is_bankrupt: bool, // 1 byte - bankruptcy status
    #[max_len(50)]
    pub properties_owned: Vec<u8>, // variable - owned property positions
    pub get_out_of_jail_cards: u8, // 1 byte - jail cards owned
    pub net_worth: u64,    // 8 bytes - total asset value
    pub last_rent_collected: i64, // 8 bytes - last rent collection time
    pub festival_boost_turns: u8, // 1 byte - remaining festival boost turns

    pub has_rolled_dice: bool,       // 1 byte - has rolled dice this turn
    pub last_dice_roll: [u8; 2],     // 2 bytes - last dice roll
    pub needs_property_action: bool, // Player landed on property
    pub pending_property_position: Option<u8>, // Which property
    pub needs_chance_card: bool,     // Needs to draw chance card
    pub needs_community_chest_card: bool, // Needs to draw community chest
    pub needs_bankruptcy_check: bool, // Insufficient funds detected
    // pub can_end_turn: bool,          // All actions completed
    pub needs_special_space_action: bool, // Player landed on special space
    pub pending_special_space_position: Option<u8>, // Which special space

    pub card_drawn_at: Option<i64>, // Timestamp when card was drawn
}

impl PlayerState {
    pub fn initialize_player_state(
        self: &mut PlayerState,
        wallet: Pubkey,
        game: Pubkey,
        clock: &Sysvar<Clock>,
    ) {
        self.wallet = wallet;
        self.game = game;
        self.cash_balance = STARTING_MONEY as u64;
        self.position = 0;
        self.in_jail = false;
        self.jail_turns = 0;
        self.doubles_count = 0;
        self.is_bankrupt = false;
        self.properties_owned = Vec::new();
        self.get_out_of_jail_cards = 0;
        self.net_worth = STARTING_MONEY as u64;
        self.last_rent_collected = clock.unix_timestamp;
        self.festival_boost_turns = 0;
        self.has_rolled_dice = false;
        self.last_dice_roll = [0, 0];
        self.needs_property_action = false;
        self.pending_property_position = None;
        self.needs_chance_card = false;
        self.needs_community_chest_card = false;
        self.needs_bankruptcy_check = false;
        // self.can_end_turn = false;
        self.needs_special_space_action = false;
        self.pending_special_space_position = None;
        self.card_drawn_at = None;
    }
}

#[account]
#[derive(Debug, InitSpace)]
pub struct PropertyState {
    pub position: u8,                // 1 byte - board position (0-39)
    pub game: Pubkey,                // 32 bytes - game account
    pub owner: Option<Pubkey>,       // 33 bytes - property owner
    pub price: u16,                  // 2 bytes - purchase price
    pub color_group: ColorGroup,     // 1 byte - property color group
    pub property_type: PropertyType, // 1 byte - type of space
    pub houses: u8,                  // 1 byte - number of houses (0-4)
    pub has_hotel: bool,             // 1 byte - hotel status
    pub is_mortgaged: bool,          // 1 byte - mortgage status
    pub rent_base: u16,              // 2 bytes - base rent
    pub rent_with_color_group: u16,  // 2 bytes - rent with monopoly
    pub rent_with_houses: [u16; 4],  // 8 bytes - rent with 1-4 houses
    pub rent_with_hotel: u16,        // 2 bytes - rent with hotel
    pub house_cost: u16,             // 2 bytes - cost to build house
    pub mortgage_value: u16,         // 2 bytes - mortgage value
    pub last_rent_paid: i64,         // 8 bytes - last rent payment time
    pub init: bool,                  // 1 byte - init status
}

impl PropertyState {}

#[derive(AnchorSerialize, AnchorDeserialize, Debug, InitSpace, Clone, PartialEq, Eq)]
pub enum TradeType {
    MoneyOnly,
    PropertyOnly,
    MoneyForProperty,
    PropertyForMoney,
}

#[account]
#[derive(Debug, InitSpace)]
pub struct TradeState {
    pub game: Pubkey,
    pub proposer: Pubkey,
    pub receiver: Pubkey,
    pub trade_type: TradeType,

    // Money amounts
    pub proposer_money: u64,
    pub receiver_money: u64,

    // Single property (since you want 1 item per trade)
    pub proposer_property: Option<u8>, // property position
    pub receiver_property: Option<u8>, // property position

    pub status: TradeStatus,
    pub created_at: i64,
    pub expires_at: i64,
    pub bump: u8,
}

impl TradeState {}

#[account]
#[derive(Debug, InitSpace)]
pub struct AuctionState {
    pub game: Pubkey,
    pub property_position: u8,
    pub current_bid: u64,
    pub highest_bidder: Option<Pubkey>,
    pub started_at: i64,
    pub ends_at: i64,
    pub is_active: bool,
    pub bump: u8,
}

// state/events.rs
use anchor_lang::prelude::*;
use crate::state::TradeType;

#[event]
pub struct ChanceCardDrawn {
    pub player: Pubkey,
    pub game: Pubkey,
    pub card_index: u8,
    pub effect_type: u8, // 0=Money, 1=Move, 2=GoToJail, 3=GetOutOfJailFree, 4=PayPerProperty, 5=CollectFromPlayers
    pub amount: i32,
    pub timestamp: i64,
}

#[event]
pub struct CommunityChestCardDrawn {
    pub player: Pubkey,
    pub game: Pubkey,
    pub card_index: u8,
    pub effect_type: u8, // 0=Money, 1=Move, 2=GoToJail, 3=GetOutOfJailFree, 4=PayPerProperty, 5=CollectFromPlayers
    pub amount: i32,
    pub timestamp: i64,
}

#[event]
pub struct PlayerPassedGo {
    pub player: Pubkey,
    pub game_id: u64,
    pub salary_collected: u64,
    pub new_position: u8,
    pub timestamp: i64,
}

// Game ending event
#[event]
pub struct GameEnded {
    pub game_id: u64,
    pub winner: Option<Pubkey>,
    pub ended_at: i64,
}

// New trade events for vector-based trading
#[event]
pub struct TradeCreated {
    pub game: Pubkey,
    pub trade_id: u8,
    pub proposer: Pubkey,
    pub receiver: Pubkey,
    pub trade_type: TradeType,
    pub proposer_money: u64,
    pub receiver_money: u64,
    pub proposer_property: Option<u8>,
    pub receiver_property: Option<u8>,
    pub expires_at: i64,
}

#[event]
pub struct TradeAccepted {
    pub game: Pubkey,
    pub trade_id: u8,
    pub proposer: Pubkey,
    pub receiver: Pubkey,
    pub accepter: Pubkey,
}

#[event]
pub struct TradeRejected {
    pub game: Pubkey,
    pub trade_id: u8,
    pub proposer: Pubkey,
    pub receiver: Pubkey,
    pub rejecter: Pubkey,
}

#[event]
pub struct TradeCancelled {
    pub game: Pubkey,
    pub trade_id: u8,
    pub proposer: Pubkey,
    pub receiver: Pubkey,
    pub canceller: Pubkey,
}

#[event]
pub struct TradesCleanedUp {
    pub game: Pubkey,
    pub trades_removed: u8,
    pub remaining_trades: u8,
}


// instructions/bankruptcy.rs
use crate::error::GameError;
use crate::instructions::end_game::check_game_end_condition;
use crate::state::*;
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct DeclareBankruptcy<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump,
        constraint = !player_state.is_bankrupt @ GameError::BankruptcyAlreadyStarted
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn declare_bankruptcy_handler<'c: 'info, 'info>(
    ctx: Context<'_, '_, 'c, 'info, DeclareBankruptcy<'info>>,
) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Find player index in game.players vector
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    // Verify it's the player's turn or they need bankruptcy check
    if game.current_turn != player_index as u8 && !player_state.needs_bankruptcy_check {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Mark player as bankrupt
    player_state.is_bankrupt = true;

    // Calculate total liquidation value from properties
    let mut total_liquidation_value = 0u64;
    let mut houses_returned = 0u8;
    let mut hotels_returned = 0u8;

    // Get all property accounts from remaining accounts
    let remaining_accounts = &mut ctx.remaining_accounts.iter();

    for _i in 0..player_state.properties_owned.len() {
        let property_account_info = next_account_info(remaining_accounts)?;

        // let mut property_data = property_account_info.try_borrow_mut_data()?;

        let mut property_state: Account<PropertyState> =
            Account::try_from_unchecked(property_account_info)?;

        // Verify this property belongs to the bankrupt player
        if property_state.owner == Some(player_pubkey) {
            // Calculate building liquidation value
            let building_value = calculate_building_liquidation_value(&property_state)?;
            total_liquidation_value = total_liquidation_value
                .checked_add(building_value)
                .ok_or(GameError::ArithmeticOverflow)?;

            // Return buildings to bank
            if property_state.houses > 0 {
                houses_returned = houses_returned
                    .checked_add(property_state.houses)
                    .ok_or(GameError::ArithmeticOverflow)?;
                property_state.houses = 0;
            }

            if property_state.has_hotel {
                hotels_returned = hotels_returned
                    .checked_add(1)
                    .ok_or(GameError::ArithmeticOverflow)?;
                property_state.has_hotel = false;
            }

            // Calculate mortgage value if not already mortgaged
            if !property_state.is_mortgaged {
                let mortgage_value = property_state.mortgage_value as u64;
                total_liquidation_value = total_liquidation_value
                    .checked_add(mortgage_value)
                    .ok_or(GameError::ArithmeticOverflow)?;
            }

            // Clear ownership
            property_state.owner = None;
            property_state.is_mortgaged = false;
        }
    }

    // Return buildings to bank
    game.houses_remaining = game
        .houses_remaining
        .checked_add(houses_returned)
        .ok_or(GameError::ArithmeticOverflow)?;

    game.hotels_remaining = game
        .hotels_remaining
        .checked_add(hotels_returned)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Add liquidation value to bank
    game.bank_balance = game
        .bank_balance
        .checked_add(total_liquidation_value)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Clear bankruptcy check flag
    player_state.needs_bankruptcy_check = false;

    // Transfer all remaining cash to the bank
    let remaining_cash = player_state.cash_balance;
    game.bank_balance = game
        .bank_balance
        .checked_add(remaining_cash)
        .ok_or(GameError::ArithmeticOverflow)?;

    player_state.cash_balance = 0;
    player_state.net_worth = 0;

    // Clear all properties owned from player state
    player_state.properties_owned.clear();

    // Clear Get Out of Jail Free cards
    player_state.get_out_of_jail_cards = 0;

    // Clear all player flags and reset position
    reset_player_state_for_bankruptcy(player_state);

    // Remove player from active game
    remove_player_from_game(game, player_index as u8)?;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} declared bankruptcy. Liquidated ${} in assets, ${} cash transferred to bank. {} houses and {} hotels returned to bank.",
        player_pubkey,
        total_liquidation_value,
        remaining_cash,
        houses_returned,
        hotels_returned
    );

    // Check if game should end (only one player remaining)
    if check_game_end_condition(game) {
        game.game_status = GameStatus::Finished;

        // Find the remaining player and declare them winner
        if let Some(winner_pubkey) = game
            .players
            .iter()
            .find(|&&p| p != Pubkey::default())
            .copied()
        {
            game.winner = Some(winner_pubkey);
            msg!("Game ended. Winner: {}", winner_pubkey);

            emit!(GameEnded {
                game_id: game.game_id,
                winner: Some(winner_pubkey),
                ended_at: clock.unix_timestamp,
            });
        } else {
            // No players remaining (shouldn't happen in normal gameplay)
            msg!("Game ended with no remaining players");

            emit!(GameEnded {
                game_id: game.game_id,
                winner: None,
                ended_at: clock.unix_timestamp,
            });
        }
    } else {
        // Advance to next player's turn
        if game.current_turn >= game.current_players {
            game.current_turn = 0;
        }
    }

    Ok(())
}

fn calculate_building_liquidation_value(property_state: &PropertyState) -> Result<u64> {
    let mut value = 0u64;

    // Houses sell for half their cost
    if property_state.houses > 0 {
        let house_value = (property_state.house_cost as u64 / 2) * property_state.houses as u64;
        value = value
            .checked_add(house_value)
            .ok_or(GameError::ArithmeticOverflow)?;
    }

    // Hotels sell for half their cost (house_cost * 5 / 2)
    if property_state.has_hotel {
        let hotel_value = (property_state.house_cost as u64 * 5) / 2;
        value = value
            .checked_add(hotel_value)
            .ok_or(GameError::ArithmeticOverflow)?;
    }

    Ok(value)
}

fn reset_player_state_for_bankruptcy(player_state: &mut PlayerState) {
    player_state.has_rolled_dice = false;
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;
    player_state.doubles_count = 0;
    player_state.in_jail = false;
    player_state.jail_turns = 0;
    player_state.position = 0; // Reset to GO
    player_state.festival_boost_turns = 0;
    player_state.card_drawn_at = None;
}

fn remove_player_from_game(game: &mut GameState, player_index: u8) -> Result<()> {
    // Remove player from the players array by setting to default
    if (player_index as usize) < game.players.len() {
        game.players[player_index as usize] = Pubkey::default();
    }

    // Decrease current players count
    game.current_players = game
        .current_players
        .checked_sub(1)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Adjust current_turn if necessary
    if game.current_turn >= game.current_players && game.current_players > 0 {
        game.current_turn = 0;
    }

    msg!(
        "Player at index {} removed from game. Remaining players: {}",
        player_index,
        game.current_players
    );

    Ok(())
}


// instructions/dice.rs
use crate::error::GameError;
use crate::{constants::*, xorshift64star, ID};
use crate::{force_end_turn, send_player_to_jail_and_end_turn, state::*};
use anchor_lang::prelude::*;
use ephemeral_vrf_sdk::anchor::vrf;
use ephemeral_vrf_sdk::instructions::create_request_randomness_ix;
use ephemeral_vrf_sdk::types::SerializableAccountMeta;

#[derive(Accounts)]
pub struct RollDice<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    /// CHECK: This is the recent blockhashes sysvar
    #[account(address = anchor_lang::solana_program::sysvar::recent_blockhashes::ID)]
    pub recent_blockhashes: UncheckedAccount<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn roll_dice_handler(ctx: Context<RollDice>, dice_roll: Option<[u8; 2]>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if player_state.has_rolled_dice {
        return Err(GameError::AlreadyRolledDice.into());
    }

    if player_state.in_jail {
        return handle_jail_dice_roll(game, player_state, clock, &ctx.accounts.recent_blockhashes);
    }

    // Generate secure random dice roll using recent blockhash
    let dice_roll = dice_roll.unwrap_or_else(|| {
        generate_dice_roll(&ctx.accounts.recent_blockhashes, clock.unix_timestamp).unwrap()
    });

    player_state.last_dice_roll = dice_roll;
    game.turn_started_at = clock.unix_timestamp;

    let is_doubles = dice_roll[0] == dice_roll[1];
    if is_doubles {
        player_state.doubles_count += 1;

        // Three doubles in a row sends player to jail
        if player_state.doubles_count >= 3 {
            send_player_to_jail_and_end_turn(game, player_state, clock);

            msg!(
                "Player {} rolled three doubles and goes to jail! Turn ended automatically.",
                player_pubkey
            );
            return Ok(());
        }

        msg!(
            "Player {} rolled doubles ({}, {})! Gets another turn.",
            player_pubkey,
            dice_roll[0],
            dice_roll[1]
        );
    } else {
        // Reset doubles count if not doubles
        player_state.doubles_count = 0;
        player_state.has_rolled_dice = true;
    }

    msg!(
        "Player {} rolled: {} and {}",
        player_pubkey,
        dice_roll[0],
        dice_roll[1]
    );

    let dice_sum = dice_roll[0] + dice_roll[1];
    let old_position = player_state.position;
    let new_position = (old_position + dice_sum) % BOARD_SIZE;

    // Check if player passed GO
    if new_position < old_position {
        player_state.cash_balance += GO_SALARY as u64;

        emit!(PlayerPassedGo {
            player: player_pubkey,
            game_id: game.game_id,
            salary_collected: GO_SALARY as u64,
            new_position,
            timestamp: clock.unix_timestamp,
        });

        msg!(
            "Player {} passed GO and collected ${}",
            player_pubkey,
            GO_SALARY
        );
    }

    player_state.position = new_position;

    handle_space_landing(game, player_state, new_position, clock)?;

    msg!(
        "Player {} rolled: {} and {} - moved from {} to {}",
        player_pubkey,
        dice_roll[0],
        dice_roll[1],
        old_position,
        new_position
    );

    Ok(())
}

fn generate_dice_roll(recent_blockhashes: &UncheckedAccount, timestamp: i64) -> Result<[u8; 2]> {
    // Get recent blockhash data for randomness
    let data = recent_blockhashes.try_borrow_data()?;

    // Create a more diverse seed by combining multiple entropy sources
    let mut seed = 0u64;

    // Use blockhash data (take 8 bytes and convert to u64)
    if data.len() >= 8 {
        seed ^= u64::from_le_bytes([
            data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7],
        ]);
    }

    // Mix in timestamp
    seed ^= timestamp as u64;

    // Mix in more blockhash data from different positions if available
    if data.len() >= 16 {
        seed ^= u64::from_le_bytes([
            data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15],
        ]);
    }

    // Ensure seed is never zero (xorshift doesn't work with 0)
    if seed == 0 {
        seed = 0x123456789ABCDEF0u64;
    }

    // Generate first random number for dice1
    let rand1 = xorshift64star(seed);
    // Generate second random number for dice2 (use first result as seed)
    let rand2 = xorshift64star(rand1);

    // Convert to dice values (1-6)
    let dice1 = ((rand1 % 6) + 1) as u8;
    let dice2 = ((rand2 % 6) + 1) as u8;

    Ok([dice1, dice2])
}

fn handle_jail_dice_roll(
    game: &mut GameState,
    player_state: &mut PlayerState,
    clock: &Sysvar<Clock>,
    recent_blockhashes: &UncheckedAccount,
) -> Result<()> {
    player_state.jail_turns += 1;

    let dice_roll = generate_dice_roll(recent_blockhashes, clock.unix_timestamp)?;
    player_state.last_dice_roll = dice_roll;
    player_state.has_rolled_dice = true;

    let is_doubles = dice_roll[0] == dice_roll[1];
    let mut player_escaped = false;

    if is_doubles {
        player_state.in_jail = false;
        player_state.jail_turns = 0;
        player_state.doubles_count = 0;
        player_escaped = true;

        msg!("Player rolled doubles and escaped jail!");
    } else if player_state.jail_turns >= MAX_JAIL_TURNS {
        // Must pay fine after max turns
        if player_state.cash_balance >= JAIL_FINE as u64 {
            player_state.cash_balance -= JAIL_FINE as u64;
            player_state.in_jail = false;
            player_state.jail_turns = 0;
            player_escaped = true;

            msg!("Player paid jail fine and is released!");
        } else {
            // Player can't afford jail fine - declare bankruptcy and end turn
            player_state.cash_balance = 0;
            player_state.is_bankrupt = true;
            player_state.in_jail = false; // Remove from jail since they're bankrupt
            player_state.jail_turns = 0;

            force_end_turn(game, player_state, clock);

            msg!("Player cannot afford jail fine and is declared bankrupt. Turn ended automatically.");
            return Ok(());
        }
    } else {
        msg!("Player remains in jail. Turn {}/3", player_state.jail_turns);
        force_end_turn(game, player_state, clock);
        return Ok(());
    }

    if player_escaped {
        // Calculate movement
        let dice_sum = dice_roll[0] + dice_roll[1];
        let old_position = player_state.position;
        let new_position = (old_position + dice_sum) % BOARD_SIZE;

        if new_position < old_position {
            player_state.cash_balance += GO_SALARY as u64;

            emit!(PlayerPassedGo {
                player: player_state.wallet,
                game_id: game.game_id,
                salary_collected: GO_SALARY as u64,
                new_position,
                timestamp: clock.unix_timestamp,
            });

            msg!("Player passed GO and collected ${}", GO_SALARY);
        }

        player_state.position = new_position;

        handle_space_landing(game, player_state, new_position, clock)?;

        msg!(
            "Player escaped jail and moved from {} to {}",
            old_position,
            new_position
        );
    }

    game.turn_started_at = clock.unix_timestamp;
    Ok(())
}

fn handle_space_landing(
    game: &mut GameState,
    player_state: &mut PlayerState,
    position: u8,
    clock: &Sysvar<Clock>,
) -> Result<()> {
    let property_data = get_property_data(position);

    match property_data {
        Some(data) => {
            match data.property_type {
                0 | 1 | 2 => {
                    if player_state.properties_owned.contains(&position) {
                        return Ok(());
                    }

                    player_state.needs_property_action = true;
                    player_state.pending_property_position = Some(position);
                    msg!("Player landed on unowned property at position {}", position);
                }
                3 => {
                    // Special space
                    handle_special_space(game, player_state, position, clock)?;
                }
                _ => {}
            }
        }
        None => return Err(GameError::InvalidBoardPosition.into()),
    }

    Ok(())
}

fn handle_special_space(
    game: &mut GameState,
    player_state: &mut PlayerState,
    position: u8,
    clock: &Sysvar<Clock>,
) -> Result<()> {
    match position {
        GO_POSITION => {
            // Already handled in movement
        }
        JAIL_POSITION => {
            // Just visiting jail, no action needed
        }
        GO_TO_JAIL_POSITION => {
            send_player_to_jail_and_end_turn(game, player_state, clock);
        }
        MEV_TAX_POSITION | PRIORITY_FEE_TAX_POSITION => {
            player_state.needs_special_space_action = true;
            player_state.pending_special_space_position = Some(position);
        }
        pos if CHANCE_POSITIONS.contains(&pos) => {
            player_state.needs_chance_card = true;
        }
        pos if COMMUNITY_CHEST_POSITIONS.contains(&pos) => {
            player_state.needs_community_chest_card = true;
        }
        FREE_PARKING_POSITION => {
            // Free parking - no action
        }
        _ => {}
    }
    Ok(())
}

#[vrf]
#[derive(Accounts)]
pub struct RollDiceVrf<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,

    /// CHECK: The oracle queue
    #[account(mut, address = ephemeral_vrf_sdk::consts::DEFAULT_EPHEMERAL_QUEUE)]
    pub oracle_queue: AccountInfo<'info>,
}

pub fn roll_dice_vrf_handler(
    ctx: Context<RollDiceVrf>,
    client_seed: u8,
    dice_roll: Option<[u8; 2]>,
) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if player_state.has_rolled_dice {
        return Err(GameError::AlreadyRolledDice.into());
    }

    if dice_roll.is_none() {
        msg!("Requesting randomness...");

        let ix = create_request_randomness_ix(
            ephemeral_vrf_sdk::instructions::RequestRandomnessParams {
                payer: ctx.accounts.player.key(),
                oracle_queue: ctx.accounts.oracle_queue.key(),
                callback_program_id: ID,
                callback_discriminator: crate::instruction::CallbackRollDice::DISCRIMINATOR
                    .to_vec(),
                caller_seed: [client_seed; 32],
                accounts_metas: Some(vec![
                    // game
                    SerializableAccountMeta {
                        pubkey: ctx.accounts.game.key(),
                        is_signer: false,
                        is_writable: true,
                    },
                    // player state
                    SerializableAccountMeta {
                        pubkey: ctx.accounts.player_state.key(),
                        is_signer: false,
                        is_writable: true,
                    },
                    // clock
                    SerializableAccountMeta {
                        pubkey: ctx.accounts.clock.key(),
                        is_signer: false,
                        is_writable: false,
                    },
                ]),
                ..Default::default()
            },
        );

        ctx.accounts
            .invoke_signed_vrf(&ctx.accounts.player.to_account_info(), &ix)?;
    } else {
        // for test - handle the dice roll directly
        let dice_roll = dice_roll.unwrap();

        player_state.last_dice_roll = dice_roll;
        game.turn_started_at = clock.unix_timestamp;

        let is_doubles = dice_roll[0] == dice_roll[1];
        if is_doubles {
            player_state.doubles_count += 1;

            // Three doubles in a row sends player to jail
            if player_state.doubles_count >= 3 {
                send_player_to_jail_and_end_turn(game, player_state, clock);

                msg!(
                    "Player {} rolled three doubles and goes to jail! Turn ended automatically.",
                    player_pubkey
                );
                return Ok(());
            }

            msg!(
                "Player {} rolled doubles ({}, {})! Gets another turn.",
                player_pubkey,
                dice_roll[0],
                dice_roll[1]
            );
        } else {
            // Reset doubles count if not doubles
            player_state.doubles_count = 0;
            player_state.has_rolled_dice = true;
        }

        msg!(
            "Player {} rolled: {} and {}",
            player_pubkey,
            dice_roll[0],
            dice_roll[1]
        );

        let dice_sum = dice_roll[0] + dice_roll[1];
        let old_position = player_state.position;
        let new_position = (old_position + dice_sum) % BOARD_SIZE;

        // Check if player passed GO
        if new_position < old_position {
            player_state.cash_balance += GO_SALARY as u64;

            emit!(PlayerPassedGo {
                player: player_pubkey,
                game_id: game.game_id,
                salary_collected: GO_SALARY as u64,
                new_position,
                timestamp: clock.unix_timestamp,
            });

            msg!(
                "Player {} passed GO and collected ${}",
                player_pubkey,
                GO_SALARY
            );
        }

        player_state.position = new_position;

        handle_space_landing(game, player_state, new_position, clock)?;

        msg!(
            "Player {} rolled: {} and {} - moved from {} to {}",
            player_pubkey,
            dice_roll[0],
            dice_roll[1],
            old_position,
            new_position
        );
    }

    Ok(())
}

#[derive(Accounts)]
pub struct CallbackRollDiceCtx<'info> {
    /// This check ensure that the vrf_program_identity (which is a PDA) is a singer
    /// enforcing the callback is executed by the VRF program trough CPI
    #[account(address = ephemeral_vrf_sdk::consts::VRF_PROGRAM_IDENTITY)]
    pub vrf_program_identity: Signer<'info>,

    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", player_state.game.as_ref(), player_state.wallet.as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn callback_roll_dice(ctx: Context<CallbackRollDiceCtx>, randomness: [u8; 32]) -> Result<()> {
    let roll_1 = ephemeral_vrf_sdk::rnd::random_u8_with_range(&randomness, 1, 6);
    let roll_2 = ephemeral_vrf_sdk::rnd::random_u8_with_range(&randomness, 1, 6);
    msg!("Roll: {} - {}", roll_1, roll_2);

    let dice_roll = [roll_1, roll_2];

    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let clock = &ctx.accounts.clock;
    let player_pubkey = player_state.wallet;

    // Handle jail logic first if player is in jail
    if player_state.in_jail {
        return handle_jail_dice_roll_vrf(game, player_state, clock, dice_roll);
    }

    player_state.last_dice_roll = dice_roll;
    game.turn_started_at = clock.unix_timestamp;

    let is_doubles = dice_roll[0] == dice_roll[1];
    if is_doubles {
        player_state.doubles_count += 1;

        // Three doubles in a row sends player to jail
        if player_state.doubles_count >= 3 {
            send_player_to_jail_and_end_turn(game, player_state, clock);

            msg!(
                "Player {} rolled three doubles and goes to jail! Turn ended automatically.",
                player_pubkey
            );
            return Ok(());
        }

        msg!(
            "Player {} rolled doubles ({}, {})! Gets another turn.",
            player_pubkey,
            dice_roll[0],
            dice_roll[1]
        );
    } else {
        // Reset doubles count if not doubles
        player_state.doubles_count = 0;
        player_state.has_rolled_dice = true;
    }

    msg!(
        "Player {} rolled: {} and {}",
        player_pubkey,
        dice_roll[0],
        dice_roll[1]
    );

    let dice_sum = dice_roll[0] + dice_roll[1];
    let old_position = player_state.position;
    let new_position = (old_position + dice_sum) % BOARD_SIZE;

    // Check if player passed GO
    if new_position < old_position {
        player_state.cash_balance += GO_SALARY as u64;

        emit!(PlayerPassedGo {
            player: player_pubkey,
            game_id: game.game_id,
            salary_collected: GO_SALARY as u64,
            new_position,
            timestamp: clock.unix_timestamp,
        });

        msg!(
            "Player {} passed GO and collected ${}",
            player_pubkey,
            GO_SALARY
        );
    }

    player_state.position = new_position;

    handle_space_landing(game, player_state, new_position, clock)?;

    msg!(
        "Player {} rolled: {} and {} - moved from {} to {}",
        player_pubkey,
        dice_roll[0],
        dice_roll[1],
        old_position,
        new_position
    );

    Ok(())
}

fn handle_jail_dice_roll_vrf(
    game: &mut GameState,
    player_state: &mut PlayerState,
    clock: &Sysvar<Clock>,
    dice_roll: [u8; 2],
) -> Result<()> {
    player_state.jail_turns += 1;
    player_state.last_dice_roll = dice_roll;
    player_state.has_rolled_dice = true;

    let is_doubles = dice_roll[0] == dice_roll[1];
    let mut player_escaped = false;

    if is_doubles {
        player_state.in_jail = false;
        player_state.jail_turns = 0;
        player_state.doubles_count = 0;
        player_escaped = true;

        msg!("Player rolled doubles and escaped jail!");
    } else if player_state.jail_turns >= MAX_JAIL_TURNS {
        // Must pay fine after max turns
        if player_state.cash_balance >= JAIL_FINE as u64 {
            player_state.cash_balance -= JAIL_FINE as u64;
            player_state.in_jail = false;
            player_state.jail_turns = 0;
            player_escaped = true;

            msg!("Player paid jail fine and is released!");
        } else {
            // Player can't afford jail fine - declare bankruptcy and end turn
            player_state.cash_balance = 0;
            player_state.is_bankrupt = true;
            player_state.in_jail = false; // Remove from jail since they're bankrupt
            player_state.jail_turns = 0;

            force_end_turn(game, player_state, clock);

            msg!("Player cannot afford jail fine and is declared bankrupt. Turn ended automatically.");
            return Ok(());
        }
    } else {
        msg!("Player remains in jail. Turn {}/3", player_state.jail_turns);
        force_end_turn(game, player_state, clock);
        return Ok(());
    }

    if player_escaped {
        // Calculate movement
        let dice_sum = dice_roll[0] + dice_roll[1];
        let old_position = player_state.position;
        let new_position = (old_position + dice_sum) % BOARD_SIZE;

        if new_position < old_position {
            player_state.cash_balance += GO_SALARY as u64;

            emit!(PlayerPassedGo {
                player: player_state.wallet,
                game_id: game.game_id,
                salary_collected: GO_SALARY as u64,
                new_position,
                timestamp: clock.unix_timestamp,
            });

            msg!("Player passed GO and collected ${}", GO_SALARY);
        }

        player_state.position = new_position;

        handle_space_landing(game, player_state, new_position, clock)?;

        msg!(
            "Player escaped jail and moved from {} to {}",
            old_position,
            new_position
        );
    }

    game.turn_started_at = clock.unix_timestamp;
    Ok(())
}


// instructions/end_game.rs
use crate::error::GameError;
use crate::state::*;
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct EndGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn end_game_handler(ctx: Context<EndGame>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let clock = &ctx.accounts.clock;

    // Check if game should end (only one player remaining)
    let active_players = count_active_players(game);
    
    if active_players <= 1 {
        // End the game
        game.game_status = GameStatus::Finished;
        
        if active_players == 1 {
            // Find the remaining active player and declare them winner
            if let Some(winner_pubkey) = find_last_active_player(game) {
                game.winner = Some(winner_pubkey);
                msg!("Game ended. Winner: {}", winner_pubkey);
                
                emit!(GameEnded {
                    game_id: game.game_id,
                    winner: Some(winner_pubkey),
                    ended_at: clock.unix_timestamp,
                });
            }
        } else {
            // No players remaining (shouldn't happen in normal gameplay)
            msg!("Game ended with no remaining players");
            
            emit!(GameEnded {
                game_id: game.game_id,
                winner: None,
                ended_at: clock.unix_timestamp,
            });
        }
        
        msg!("Game {} has ended", game.game_id);
    } else {
        return Err(GameError::GameCannotEnd.into());
    }

    Ok(())
}

/// Count the number of active (non-bankrupt, non-default) players
fn count_active_players(game: &GameState) -> u8 {
    game.players
        .iter()
        .filter(|&&player| player != Pubkey::default())
        .count() as u8
}

/// Find the last remaining active player
fn find_last_active_player(game: &GameState) -> Option<Pubkey> {
    game.players
        .iter()
        .find(|&&player| player != Pubkey::default())
        .copied()
}

/// Check if the game should end based on current state
pub fn check_game_end_condition(game: &GameState) -> bool {
    count_active_players(game) <= 1
}

// instructions/end_turn.rs
use crate::error::GameError;
use crate::state::*;
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct EndTurn<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn end_turn_handler(ctx: Context<EndTurn>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Find player index in game.players vector
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    // Verify it's the current player's turn
    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Verify player has rolled dice
    if !player_state.has_rolled_dice {
        return Err(GameError::HasNotRolledDice.into());
    }

    // Check if player has pending actions that must be completed
    if player_state.needs_property_action {
        return Err(GameError::MustHandleSpecialSpace.into());
    }

    if player_state.needs_chance_card {
        return Err(GameError::MustHandleSpecialSpace.into());
    }

    if player_state.needs_community_chest_card {
        return Err(GameError::MustHandleSpecialSpace.into());
    }

    if player_state.needs_bankruptcy_check {
        return Err(GameError::MustDeclareBankruptcy.into());
    }

    // Reset turn-specific flags
    player_state.has_rolled_dice = false;
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;
    player_state.needs_bankruptcy_check = false;
    // Advance to next player
    player_state.doubles_count = 0; // Reset doubles count
    let next_turn = (game.current_turn + 1) % game.current_players;
    game.current_turn = next_turn;
    game.turn_started_at = clock.unix_timestamp;

    msg!("Turn ended. Next turn: Player {}", next_turn);

    Ok(())
}


// instructions/initialize.rs
use crate::constants::*;
use crate::error::GameError;
use crate::state::*;
use anchor_lang::prelude::*;
use anchor_spl::{
    associated_token::AssociatedToken,
    token_interface::{transfer_checked, Mint, TokenAccount, TokenInterface, TransferChecked},
};
use ephemeral_rollups_sdk::anchor::{commit, delegate};
use ephemeral_rollups_sdk::cpi::DelegateConfig;
use ephemeral_rollups_sdk::ephem::commit_and_undelegate_accounts;

#[derive(Accounts)]
pub struct InitializeGame<'info> {
    #[account(
        init,
        payer = creator,
        space = 8 + GameState::INIT_SPACE,
        seeds = [
            b"game",
            config.id.as_ref(),
            &config.next_game_id.to_le_bytes()
            ],
        bump
    )]
    pub game: Account<'info, GameState>,

    #[account(
        init,
        payer = creator,
        space = 8 + PlayerState::INIT_SPACE + 64,
        seeds = [b"player", game.key().as_ref(), creator.key().as_ref()],
        bump,
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub creator: Signer<'info>,

    #[account(
        mut,
        seeds = [b"platform", config.id.as_ref()],
        bump = config.bump,
    )]
    pub config: Account<'info, PlatformConfig>,

    /// CHECK: game authority PDA
    pub game_authority: Option<UncheckedAccount<'info>>,

    #[account(
        mint::token_program = token_program,
    )]
    pub token_mint: Option<InterfaceAccount<'info, Mint>>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = creator,
        associated_token::token_program = token_program
    )]
    pub creator_token_account: Option<InterfaceAccount<'info, TokenAccount>>,

    #[account(
        init,
        payer = creator,
        associated_token::mint = token_mint,
        associated_token::authority = game_authority,
        associated_token::token_program = token_program
    )]
    pub token_vault: Option<InterfaceAccount<'info, TokenAccount>>,

    pub token_program: Option<Interface<'info, TokenInterface>>,
    pub associated_token_program: Option<Program<'info, AssociatedToken>>,

    pub system_program: Program<'info, System>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn initialize_game_handler(ctx: Context<InitializeGame>, entry_fee: u64) -> Result<()> {
    let config = &mut ctx.accounts.config;
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let clock = &ctx.accounts.clock;

    if entry_fee > 0 {
        require!(
            ctx.accounts.game_authority.is_some()
                && ctx.accounts.token_mint.is_some()
                && ctx.accounts.creator_token_account.is_some()
                && ctx.accounts.token_vault.is_some()
                && ctx.accounts.token_program.is_some()
                && ctx.accounts.associated_token_program.is_some(),
            GameError::MissingTokenAccounts
        );

        let token_mint = ctx.accounts.token_mint.as_ref().unwrap();
        let creator_token_account = ctx.accounts.creator_token_account.as_ref().unwrap();
        let token_vault = ctx.accounts.token_vault.as_ref().unwrap();
        let game_authority = ctx.accounts.game_authority.as_ref().unwrap();

        // Validate game authority PDA
        let (expected_game_authority, _) =
            Pubkey::find_program_address(&[GAME_AUTHORITY_SEED], ctx.program_id);

        require!(
            game_authority.key() == expected_game_authority,
            GameError::InvalidGameAuthority
        );

        require!(
            creator_token_account.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            creator_token_account.owner == ctx.accounts.creator.key(),
            GameError::InvalidTokenAccount
        );

        require!(
            token_vault.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            token_vault.owner == game_authority.key(),
            GameError::InvalidTokenAccount
        );

        // Transfer entry fee from creator to vault
        let transfer_accounts = TransferChecked {
            from: creator_token_account.to_account_info(),
            mint: token_mint.to_account_info(),
            to: token_vault.to_account_info(),
            authority: ctx.accounts.creator.to_account_info(),
        };

        let transfer_ctx = CpiContext::new(
            ctx.accounts
                .token_program
                .as_ref()
                .unwrap()
                .to_account_info(),
            transfer_accounts,
        );

        transfer_checked(transfer_ctx, entry_fee, token_mint.decimals)?;

        game.token_mint = Some(token_mint.key());
        game.token_vault = Some(token_vault.key());
        game.total_prize_pool = entry_fee;
    } else {
        game.token_mint = None;
        game.token_vault = None;
        game.total_prize_pool = 0;
    }

    let game_id = config.next_game_id;
    config.next_game_id += 1;
    config.total_games_created += 1;

    // Initialize game state
    game.game_id = game_id;
    game.config_id = config.id;
    game.creator = ctx.accounts.creator.key();
    game.bump = ctx.bumps.game;
    game.game_status = GameStatus::WaitingForPlayers;
    game.current_turn = 0;
    game.current_players = 0; // Initial player count
    game.max_players = MAX_PLAYERS;
    game.players = vec![];
    game.houses_remaining = TOTAL_HOUSES;
    game.hotels_remaining = TOTAL_HOTELS;
    game.created_at = clock.unix_timestamp;
    game.bank_balance = 1_000_000; // Initial bank balance
    game.time_limit = None;
    game.winner = None;
    game.turn_started_at = clock.unix_timestamp;
    game.active_trades = vec![];
    game.next_trade_id = 0;
    game.entry_fee = entry_fee;

    // Initialize player state
    player_state.initialize_player_state(ctx.accounts.creator.key(), game.key(), clock);

    // Add player to game
    game.players.push(player_state.wallet);
    game.current_players = game.players.len() as u8;

    msg!(
        "Game initialized by creator: {}",
        ctx.accounts.creator.key()
    );
    msg!("Game account: {}", game.key());
    msg!("Game created at timestamp: {}", game.created_at);

    Ok(())
}

#[derive(Accounts)]
pub struct JoinGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::WaitingForPlayers @ GameError::GameNotInProgress,
        constraint = game.current_players < MAX_PLAYERS @ GameError::MaxPlayersReached
    )]
    pub game: Account<'info, GameState>,

    #[account(
        init,
        payer = player,
        space = 8 + PlayerState::INIT_SPACE + 64,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    /// CHECK: game authority PDA - only required for paid games
    pub game_authority: Option<UncheckedAccount<'info>>,

    #[account(
        mint::token_program = token_program,
    )]
    pub token_mint: Option<InterfaceAccount<'info, Mint>>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = player,
        associated_token::token_program = token_program
    )]
    pub player_token_account: Option<InterfaceAccount<'info, TokenAccount>>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = game_authority,
        associated_token::token_program = token_program
    )]
    pub token_vault: Option<InterfaceAccount<'info, TokenAccount>>,

    pub token_program: Option<Interface<'info, TokenInterface>>,
    pub associated_token_program: Option<Program<'info, AssociatedToken>>,

    pub system_program: Program<'info, System>,
    pub clock: Sysvar<'info, Clock>,
}

pub fn join_game_handler(ctx: Context<JoinGame>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    msg!("Join game: {}", game.key());
    msg!("Player: {}", player_pubkey);

    // Check if player already exists in game
    for existing_player in &game.players {
        msg!("Existing player: {}", existing_player);
        if *existing_player == player_pubkey {
            return Err(GameError::PlayerAlreadyExists.into());
        }
    }

    // Handle entry fee payment if game has entry fee
    if game.entry_fee > 0 {
        require!(
            ctx.accounts.game_authority.is_some()
                && ctx.accounts.token_mint.is_some()
                && ctx.accounts.player_token_account.is_some()
                && ctx.accounts.token_vault.is_some()
                && ctx.accounts.token_program.is_some(),
            GameError::MissingTokenAccounts
        );

        let token_mint = ctx.accounts.token_mint.as_ref().unwrap();
        let player_token_account = ctx.accounts.player_token_account.as_ref().unwrap();
        let token_vault = ctx.accounts.token_vault.as_ref().unwrap();
        let game_authority = ctx.accounts.game_authority.as_ref().unwrap();

        // Validate game authority PDA
        let (expected_game_authority, _) =
            Pubkey::find_program_address(&[GAME_AUTHORITY_SEED], ctx.program_id);

        require!(
            game_authority.key() == expected_game_authority,
            GameError::InvalidGameAuthority
        );

        // Validate token accounts
        require!(
            player_token_account.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            player_token_account.owner == ctx.accounts.player.key(),
            GameError::InvalidTokenAccount
        );

        require!(
            token_vault.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            token_vault.owner == game_authority.key(),
            GameError::InvalidTokenAccount
        );

        // Validate that the token accounts match the game's configuration
        require!(
            Some(token_mint.key()) == game.token_mint,
            GameError::InvalidTokenAccount
        );
        require!(
            Some(token_vault.key()) == game.token_vault,
            GameError::InvalidTokenAccount
        );

        // Transfer entry fee from player to vault
        let transfer_accounts = TransferChecked {
            from: player_token_account.to_account_info(),
            mint: token_mint.to_account_info(),
            to: token_vault.to_account_info(),
            authority: ctx.accounts.player.to_account_info(),
        };

        let transfer_ctx = CpiContext::new(
            ctx.accounts
                .token_program
                .as_ref()
                .unwrap()
                .to_account_info(),
            transfer_accounts,
        );

        transfer_checked(transfer_ctx, game.entry_fee, token_mint.decimals)?;

        // Update total prize pool
        game.total_prize_pool = game
            .total_prize_pool
            .checked_add(game.entry_fee)
            .ok_or(GameError::ArithmeticOverflow)?;

        msg!(
            "Entry fee {} paid by player {}",
            game.entry_fee,
            player_pubkey
        );
        msg!("Total prize pool: {}", game.total_prize_pool);
    } 
    // else {
    //     // For free games, ensure no token accounts are provided
    //     require!(
    //         ctx.accounts.game_authority.is_none()
    //             && ctx.accounts.token_mint.is_none()
    //             && ctx.accounts.player_token_account.is_none()
    //             && ctx.accounts.token_vault.is_none()
    //             && ctx.accounts.token_program.is_none(),
    //         GameError::UnexpectedTokenAccounts
    //     );
    // }

    // Initialize player state
    player_state.initialize_player_state(player_pubkey, game.key(), clock);

    // Add player to game
    game.players.push(player_pubkey);
    game.current_players = game.players.len() as u8;

    msg!(
        "Player {} joined game. Total players: {}",
        player_pubkey,
        game.current_players
    );

    // Auto-start game if we have minimum players and all slots filled
    if game.current_players >= MIN_PLAYERS {
        msg!("Minimum players reached. Game can be started.");
    }

    Ok(())
}

#[delegate]
#[derive(Accounts)]
pub struct StartGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump,
        constraint = game.game_status == GameStatus::WaitingForPlayers @ GameError::GameNotInProgress,
        constraint = game.current_players >= MIN_PLAYERS @ GameError::MinPlayersNotMet,
        constraint = authority.key() == game.creator @ GameError::Unauthorized,
        del
    )]
    pub game: Account<'info, GameState>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn start_game_handler<'c: 'info, 'info>(
    ctx: Context<'_, '_, 'c, 'info, StartGame<'info>>,
) -> Result<()> {
    {
        let game = &mut ctx.accounts.game;
        let clock = &ctx.accounts.clock;

        // Change game status to in progress
        game.game_status = GameStatus::InProgress;
        game.current_turn = 0; // First player starts
        game.turn_started_at = clock.unix_timestamp;

        msg!("Game started! Player {} goes first.", game.players[0]);
        msg!("Total players in game: {}", game.current_players);
    }

    {
        msg!("Start delegate");

        let authority = &ctx.accounts.authority;
        let owner_program = &ctx.accounts.owner_program;
        let delegation_program = &ctx.accounts.delegation_program;
        let game = &ctx.accounts.game;
        let game_key = game.key();
        let players = &game.players;

        game.exit(&crate::ID)?;
        ctx.accounts.delegate_game(
            &ctx.accounts.authority,
            &[
                b"game",
                game.config_id.as_ref(),
                &game.game_id.to_le_bytes(),
            ],
            DelegateConfig {
                commit_frequency_ms: 30_000,
                validator: Some(pubkey!("MAS1Dt9qreoRMQ14YQuhg8UTZMMzDdKhmkZMECCzk57")),
            },
        )?;

        let remaining_accounts_iter = &mut ctx.remaining_accounts.iter();

        // delegate player accounts
        for player_pubkey in players.iter() {
            let player_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;
            player_account.exit(&crate::ID)?;

            let player_buffer_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;

            let player_delegation_record_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;

            let player_delegation_metadata_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;

            let del_accounts = ephemeral_rollups_sdk::cpi::DelegateAccounts {
                payer: &authority.to_account_info(),
                pda: &player_account.to_account_info(),
                owner_program: &owner_program.to_account_info(),
                buffer: player_buffer_account,
                delegation_record: player_delegation_record_account,
                delegation_metadata: player_delegation_metadata_account,
                delegation_program: &delegation_program.to_account_info(),
                system_program: &ctx.accounts.system_program.to_account_info(),
            };

            let seeds = &[b"player", game_key.as_ref(), player_pubkey.as_ref()];

            let config = DelegateConfig {
                commit_frequency_ms: 30_000,
                validator: Some(pubkey!("MAS1Dt9qreoRMQ14YQuhg8UTZMMzDdKhmkZMECCzk57")),
            };

            ephemeral_rollups_sdk::cpi::delegate_account(del_accounts, seeds, config)?;

            msg!("Player {} delegated", player_pubkey);
        }
    }

    msg!("Game started!");

    Ok(())
}

#[commit]
#[derive(Accounts)]
pub struct UndelegateGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress,
        constraint = game.current_players >= MIN_PLAYERS @ GameError::MinPlayersNotMet,
        constraint = authority.key() == game.creator @ GameError::Unauthorized,
    )]
    pub game: Account<'info, GameState>,

    #[account(mut)]
    pub authority: Signer<'info>,
}

pub fn undelegate_game_handler<'c: 'info, 'info>(
    ctx: Context<'_, '_, 'c, 'info, UndelegateGame<'info>>,
) -> Result<()> {
    {
        let game = &mut ctx.accounts.game;
        // Change game status to in progress
        game.game_status = GameStatus::Finished;

        msg!("Game closed!");
    }

    {
        msg!("Start undelegate");

        let game = &ctx.accounts.game;
        let players = &game.players;

        game.exit(&crate::ID)?;
        commit_and_undelegate_accounts(
            &ctx.accounts.authority,
            vec![&game.to_account_info()],
            &ctx.accounts.magic_context,
            &ctx.accounts.magic_program,
        )?;

        let remaining_accounts_iter = &mut ctx.remaining_accounts.iter();

        // delegate player accounts
        for player_pubkey in players.iter() {
            let player_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;
            player_account.exit(&crate::ID)?;

            commit_and_undelegate_accounts(
                &ctx.accounts.authority,
                vec![&player_account.to_account_info()],
                &ctx.accounts.magic_context,
                &ctx.accounts.magic_program,
            )?;

            msg!("Player {} undelegated", player_pubkey);
        }
    }

    msg!("Game undelegated!");

    Ok(())
}

#[derive(Accounts)]
pub struct CloseGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress,
        constraint = game.current_players >= MIN_PLAYERS @ GameError::MinPlayersNotMet,
        constraint = authority.key() == game.creator @ GameError::Unauthorized,
        close = authority
    )]
    pub game: Account<'info, GameState>,

    #[account(mut)]
    pub authority: Signer<'info>,
}

pub fn close_game_handler<'c: 'info, 'info>(
    ctx: Context<'_, '_, 'c, 'info, CloseGame<'info>>,
) -> Result<()> {
    {
        msg!("Start close_game_handler");

        let remaining_accounts_iter = &mut ctx.remaining_accounts.iter();

        let game = &ctx.accounts.game;
        let authority = &ctx.accounts.authority;
        let players = &game.players;
        // delegate player accounts
        for player_pubkey in players.iter() {
            let player_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;

            let pda_balance_before = player_account.get_lamports();

            msg!(
                "Player {} balance before: {}",
                player_pubkey,
                pda_balance_before
            );

            player_account.sub_lamports(pda_balance_before)?;
            authority.add_lamports(pda_balance_before)?;

            msg!("Player {} close", player_pubkey);
        }
    }

    msg!("Game closed!");

    Ok(())
}

#[derive(Accounts)]
pub struct ResetGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress,
        constraint = game.current_players >= MIN_PLAYERS @ GameError::MinPlayersNotMet,
        constraint = authority.key() == game.creator @ GameError::Unauthorized,
    )]
    pub game: Account<'info, GameState>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn reset_game_handler<'c: 'info, 'info>(
    ctx: Context<'_, '_, 'c, 'info, ResetGame<'info>>,
) -> Result<()> {
    {
        let game = &mut ctx.accounts.game;
        let clock = &ctx.accounts.clock;

        // Change game status to in progress
        game.game_status = GameStatus::InProgress;
        game.current_turn = 0; // First player starts
        game.houses_remaining = TOTAL_HOUSES; // First player starts
        game.hotels_remaining = TOTAL_HOTELS; // First player starts
        game.bank_balance = 1_000_000; // First player starts
        game.winner = None; // First player starts
        game.active_trades = vec![]; // First player starts
        game.next_trade_id = 0; // First player starts
        game.turn_started_at = clock.unix_timestamp;
    }

    {
        let remaining_accounts_iter = &mut ctx.remaining_accounts.iter();
        let game = &ctx.accounts.game;
        let clock = &ctx.accounts.clock;

        for _player_pubkey in game.players.iter() {
            let data_account_info = next_account_info(remaining_accounts_iter)?;
            require_eq!(data_account_info.is_writable, true);
            msg!(
                "Player data account: {} and {}",
                data_account_info.key(),
                _player_pubkey
            );

            let mut player_account = Account::<PlayerState>::try_from(data_account_info)?;

            player_account.cash_balance = STARTING_MONEY as u64;
            player_account.position = 0;
            player_account.in_jail = false;
            player_account.jail_turns = 0;
            player_account.doubles_count = 0;
            player_account.is_bankrupt = false;
            player_account.properties_owned = Vec::new();
            player_account.get_out_of_jail_cards = 0;
            player_account.net_worth = STARTING_MONEY as u64;
            player_account.last_rent_collected = clock.unix_timestamp;
            player_account.festival_boost_turns = 0;
            player_account.has_rolled_dice = false;
            player_account.last_dice_roll = [0, 0];
            player_account.needs_property_action = false;
            player_account.pending_property_position = None;
            player_account.needs_chance_card = false;
            player_account.needs_community_chest_card = false;
            player_account.needs_bankruptcy_check = false;
            player_account.needs_special_space_action = false;
            player_account.pending_special_space_position = None;
            player_account.card_drawn_at = None;

            player_account.exit(&crate::ID)?;

            msg!("Player {} reset", _player_pubkey);
        }
    }

    msg!("Game resetted!");

    Ok(())
}


// instructions/jail.rs
use crate::error::GameError;
use crate::{constants::*, force_end_turn, state::*};
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct PayJailFine<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn pay_jail_fine_handler(ctx: Context<PayJailFine>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if !player_state.in_jail {
        return Err(GameError::PlayerNotInJail.into());
    }

    // Check if player has enough money
    if player_state.cash_balance < JAIL_FINE as u64 {
        player_state.needs_bankruptcy_check = true;
        return Ok(());
    }

    // Pay fine and release from jail
    player_state.cash_balance -= JAIL_FINE as u64;
    player_state.in_jail = false;
    player_state.jail_turns = 0;

    // End the turn after paying the fine
    force_end_turn(game, player_state, clock);

    msg!(
        "Player {} paid ${} jail fine and is released! Turn ended.",
        player_pubkey,
        JAIL_FINE
    );

    Ok(())
}

#[derive(Accounts)]
pub struct UseGetOutOfJailCard<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn use_get_out_of_jail_card_handler(ctx: Context<UseGetOutOfJailCard>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if !player_state.in_jail {
        return Err(GameError::PlayerNotInJail.into());
    }

    // Check if player has get out of jail cards
    if player_state.get_out_of_jail_cards == 0 {
        return Err(GameError::NoGetOutOfJailCards.into());
    }

    // Use the card and release from jail
    player_state.get_out_of_jail_cards -= 1;
    player_state.in_jail = false;
    player_state.jail_turns = 0;

    // End the turn after using the card
    force_end_turn(game, player_state, clock);

    msg!(
        "Player {} used a Get Out of Jail card and is released! Turn ended. Cards remaining: {}",
        player_pubkey,
        player_state.get_out_of_jail_cards
    );

    Ok(())
}

// instructions/mod.rs
// pub mod auction;
pub mod bankruptcy;
pub mod dice;
pub mod end_game;
pub mod end_turn;
pub mod initialize;
pub mod jail;
pub mod property;
pub mod special_spaces;
pub mod trading;
pub mod platform;

// pub use auction::*;
pub use bankruptcy::*;
pub use dice::*;
pub use end_game::*;
pub use end_turn::*;
pub use initialize::*;
pub use jail::*;
pub use property::*;
pub use special_spaces::*;
pub use trading::*;
pub use platform::*;


// instructions/platform.rs
use anchor_lang::prelude::*;

use crate::PlatformConfig;

#[derive(Accounts)]
#[instruction(platform_id: Pubkey)]
pub struct CreatePlatformConfig<'info> {
    #[account(mut)]
    pub admin: Signer<'info>,

    #[account(
        init_if_needed,
        seeds = [b"platform", platform_id.as_ref()],
        bump,
        payer = admin,
        space = 8 + PlatformConfig::INIT_SPACE
    )]
    pub config: Account<'info, PlatformConfig>,

    pub system_program: Program<'info, System>,
}

pub fn create_platform_config_handler(
    ctx: Context<CreatePlatformConfig>,
    platform_id: Pubkey,
    fee_basis_points: u16,
    fee_vault: Pubkey,
) -> Result<()> {
    let config = &mut ctx.accounts.config;

    config.id = platform_id;
    config.fee_basis_points = fee_basis_points;
    config.fee_vault = fee_vault;
    config.bump = ctx.bumps.config;
    config.authority = ctx.accounts.admin.key();
    config.total_games_created = 0;
    config.next_game_id = 1;

    Ok(())
}

#[derive(Accounts)]
pub struct UpdatePlatformConfig<'info> {
    #[account(mut, constraint = config.authority == admin.key())]
    pub admin: Signer<'info>,

    #[account(
        mut,
        seeds = [b"platform", config.id.as_ref()],
        bump = config.bump,
    )]
    pub config: Account<'info, PlatformConfig>,
}

pub fn update_platform_config_handler(
    ctx: Context<UpdatePlatformConfig>,
    fee_basis_points: Option<u16>,
    fee_vault: Option<Pubkey>,
) -> Result<()> {
    let config = &mut ctx.accounts.config;

    if let Some(fee) = fee_basis_points {
        config.fee_basis_points = fee;
    }

    if let Some(fee_vault) = fee_vault {
        config.fee_vault = fee_vault;
    }

    Ok(())
}


// instructions/property.rs
use crate::constants::*;
use crate::error::GameError;
use crate::state::*;
use crate::utils::*;
use anchor_lang::prelude::*;
use ephemeral_rollups_sdk::cpi::DelegateConfig;

#[derive(Accounts)]
#[instruction(game_key: Pubkey, position: u8)]
pub struct InitProperty<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + PropertyState::INIT_SPACE,
        seeds = [b"property", game_key.as_ref(), position.to_le_bytes().as_ref()],
        bump
    )]
    pub property_state: Account<'info, PropertyState>,

    /// CHECK: Validate by CPI
    #[account(mut)]
    pub property_buffer_account: UncheckedAccount<'info>,

    /// CHECK: Validate by CPI
    #[account(mut)]
    pub property_delegation_record_account: UncheckedAccount<'info>,

    /// CHECK: Validate by CPI
    #[account(mut)]
    pub property_delegation_metadata_account: UncheckedAccount<'info>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,

    /// CHECK: Validate by CPI
    pub delegation_program: UncheckedAccount<'info>,

    /// CHECK: Validate by CPI
    pub owner_program: UncheckedAccount<'info>,
}

pub fn init_property_handler(
    ctx: Context<InitProperty>,
    game_key: Pubkey,
    position: u8,
) -> Result<()> {
    msg!("Init property {} for game {}", position, game_key);
    msg!("property: {}", ctx.accounts.property_state.key());

    {
        let property = &mut ctx.accounts.property_state;
        property.position = position;
        property.game = game_key;
        property.init = false;
    }

    {
        let property = &ctx.accounts.property_state;
        property.exit(&crate::ID)?;

        let del_accounts = ephemeral_rollups_sdk::cpi::DelegateAccounts {
            payer: &ctx.accounts.authority.to_account_info(),
            pda: &property.to_account_info(),
            owner_program: &ctx.accounts.owner_program.to_account_info(),
            buffer: &ctx.accounts.property_buffer_account.to_account_info(),
            delegation_record: &ctx
                .accounts
                .property_delegation_record_account
                .to_account_info(),
            delegation_metadata: &ctx
                .accounts
                .property_delegation_metadata_account
                .to_account_info(),
            delegation_program: &ctx.accounts.delegation_program.to_account_info(),
            system_program: &ctx.accounts.system_program.to_account_info(),
        };

        let pos_seed = property.position.to_le_bytes();
        let seeds = &[b"property", property.game.as_ref(), pos_seed.as_ref()];

        msg!("seeds: {:?}", seeds);

        let config = DelegateConfig {
            commit_frequency_ms: 30_000,
            validator: Some(pubkey!("MAS1Dt9qreoRMQ14YQuhg8UTZMMzDdKhmkZMECCzk57")),
        };

        ephemeral_rollups_sdk::cpi::delegate_account(del_accounts, seeds, config)?;

        msg!("Property {} delegated");
    }

    Ok(())
}

#[derive(Accounts)]
pub struct BuyProperty<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", property_state.game.as_ref(), property_state.position.to_le_bytes().as_ref()],
        bump
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub system_program: Program<'info, System>,
    pub clock: Sysvar<'info, Clock>,
}

pub fn buy_property_handler(ctx: Context<BuyProperty>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if player_state.position != position {
        return Err(GameError::InvalidPropertyPosition.into());
    }

    if !is_property_purchasable(position) {
        return Err(GameError::PropertyNotPurchasable.into());
    }

    let property_data = get_property_data(position).ok_or(GameError::InvalidPropertyPosition)?;

    // Check if property is already owned
    if property_state.owner.is_some() {
        return Err(GameError::PropertyAlreadyOwned.into());
    }

    if player_state.cash_balance < property_data.price {
        return Err(GameError::InsufficientFunds.into());
    }

    // Initialize property state if needed
    if !property_state.init {
        // Not initialized
        property_state.init = true;
        property_state.price = property_data.price as u16;
        property_state.color_group = match property_data.color_group {
            1 => ColorGroup::Brown,
            2 => ColorGroup::LightBlue,
            3 => ColorGroup::Pink,
            4 => ColorGroup::Orange,
            5 => ColorGroup::Red,
            6 => ColorGroup::Yellow,
            7 => ColorGroup::Green,
            8 => ColorGroup::DarkBlue,
            9 => ColorGroup::Railroad,
            10 => ColorGroup::Utility,
            _ => ColorGroup::Special,
        };
        property_state.property_type = match property_data.property_type {
            0 => PropertyType::Street,
            1 => PropertyType::Railroad,
            2 => PropertyType::Utility,
            _ => PropertyType::Property,
        };
        property_state.houses = 0;
        property_state.has_hotel = false;
        property_state.is_mortgaged = false;
        property_state.rent_base = property_data.rent[0] as u16;
        property_state.rent_with_color_group = (property_data.rent[0] * 2) as u16;
        property_state.rent_with_houses = [
            property_data.rent[1] as u16,
            property_data.rent[2] as u16,
            property_data.rent[3] as u16,
            property_data.rent[4] as u16,
        ];
        property_state.rent_with_hotel = property_data.rent[5] as u16;
        property_state.house_cost = property_data.house_cost as u16;
        property_state.mortgage_value = property_data.mortgage_value as u16;
        property_state.last_rent_paid = 0;
    }

    // Transfer ownership
    property_state.owner = Some(player_pubkey);

    // Deduct money from player
    player_state.cash_balance = player_state
        .cash_balance
        .checked_sub(property_data.price)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Add property to player's owned properties
    if !player_state.properties_owned.contains(&position) {
        player_state.properties_owned.push(position);
    }

    // Update player's net worth
    player_state.net_worth = player_state
        .net_worth
        .checked_add(property_data.price)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Clear property action flag
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;

    // Update timestamps
    game.turn_started_at = clock.unix_timestamp;

    // In the buy_property_handler function, remove or update the msg! that references property_data.name:
    msg!(
        "Player {} purchased property at position {} for ${}",
        player_pubkey,
        position,
        property_data.price
    );

    Ok(())
}

// ---------------------------------------------------------------------------

#[derive(Accounts)]
pub struct DeclineProperty<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn decline_property_handler(ctx: Context<DeclineProperty>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Validate player is at the property position
    if player_state.position != position {
        return Err(GameError::InvalidPropertyPosition.into());
    }

    // Validate player has a pending property action
    if !player_state.needs_property_action {
        return Err(GameError::InvalidSpecialSpaceAction.into());
    }

    // Validate the pending property position matches
    if player_state.pending_property_position != Some(position) {
        return Err(GameError::InvalidPropertyPosition.into());
    }

    // Validate position is a purchasable property
    if !is_property_purchasable(position) {
        return Err(GameError::PropertyNotPurchasable.into());
    }

    // Get property data for logging
    let property_data = get_property_data(position).ok_or(GameError::InvalidPropertyPosition)?;

    // Clear property action flags
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;

    // Allow player to end turn after declining
    // player_state.can_end_turn = true;

    // Update timestamps
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} declined to purchase property at position {} (${}) - property may go to auction",
        player_pubkey,
        position,
        property_data.price
    );

    // Note: In a full implementation, this would trigger an auction
    // The auction system would be implemented separately with its own instruction

    Ok(())
}

// ---------------------------------------------------------------------------

#[derive(Accounts)]
#[instruction(position: u8)]
pub struct PayRent<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), payer.key().as_ref()],
        bump
    )]
    pub payer_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), property_owner.key().as_ref()],
        bump
    )]
    pub owner_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub payer: Signer<'info>,

    /// CHECK: Property owner account - validated by property_state.owner
    pub property_owner: UncheckedAccount<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn pay_rent_handler(ctx: Context<PayRent>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let payer_state = &mut ctx.accounts.payer_state;
    let owner_state = &mut ctx.accounts.owner_state;
    let property_state = &mut ctx.accounts.property_state;
    let payer_pubkey = ctx.accounts.payer.key();
    let property_owner_pubkey = ctx.accounts.property_owner.key();
    let clock = &ctx.accounts.clock;

    let payer_index = game
        .players
        .iter()
        .position(|&p| p == payer_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != payer_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if payer_state.position != position {
        return Err(GameError::InvalidPropertyPosition.into());
    }

    let property_owner = property_state.owner.ok_or(GameError::PropertyNotOwned)?;
    if property_owner != property_owner_pubkey {
        return Err(GameError::InvalidPropertyOwner.into());
    }

    // Can't pay rent to yourself
    if payer_pubkey == property_owner {
        return Ok(());
    }

    // Check if property is mortgaged (no rent if mortgaged)
    if property_state.is_mortgaged {
        return Ok(()); // No rent payment needed
    }

    let rent_amount =
        calculate_rent_for_property(&property_state, &owner_state, payer_state.last_dice_roll)?;

    // Check if payer has enough money
    if payer_state.cash_balance < rent_amount {
        // Set bankruptcy check flag
        payer_state.needs_bankruptcy_check = true;
        return Err(GameError::InsufficientFunds.into());
    }

    // Transfer rent from payer to owner
    payer_state.cash_balance = payer_state
        .cash_balance
        .checked_sub(rent_amount)
        .ok_or(GameError::ArithmeticUnderflow)?;

    owner_state.cash_balance = owner_state
        .cash_balance
        .checked_add(rent_amount)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Update net worth
    payer_state.net_worth = payer_state
        .net_worth
        .checked_sub(rent_amount)
        .ok_or(GameError::ArithmeticUnderflow)?;

    owner_state.net_worth = owner_state
        .net_worth
        .checked_add(rent_amount)
        .ok_or(GameError::ArithmeticOverflow)?;

    // FIXME
    payer_state.needs_property_action = false;

    // Update property rent tracking
    property_state.last_rent_paid = clock.unix_timestamp;
    owner_state.last_rent_collected = clock.unix_timestamp;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} paid ${} rent to {} for property at position {}",
        payer_pubkey,
        rent_amount,
        property_owner,
        position
    );

    Ok(())
}

// ---------------------------------------------------------------------------
#[derive(Accounts)]
#[instruction(position: u8)]
pub struct BuildHouse<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump,
        constraint = property_state.owner == Some(player.key()) @ GameError::PropertyNotOwnedByPlayer,
        constraint = !property_state.is_mortgaged @ GameError::PropertyMortgaged,
        constraint = property_state.property_type == PropertyType::Street @ GameError::CannotBuildOnPropertyType,
        constraint = property_state.houses < MAX_HOUSES_PER_PROPERTY @ GameError::MaxHousesReached,
        constraint = !property_state.has_hotel @ GameError::PropertyHasHotel
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn build_house_handler(ctx: Context<BuildHouse>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Get property data
    // let property_data = get_property_data(position).ok_or(GameError::InvalidPropertyPosition)?;

    // Check monopoly requirement
    if !has_monopoly_for_player(player_state, property_state.color_group) {
        return Err(GameError::DoesNotOwnColorGroup.into());
    }

    // Check even building rule
    if !can_build_evenly_for_player(
        player_state,
        property_state.color_group,
        position,
        property_state.houses + 1,
    ) {
        return Err(GameError::MustBuildEvenly.into());
    }

    // Check if enough houses available
    if game.houses_remaining == 0 {
        return Err(GameError::NotEnoughHousesInBank.into());
    }

    // Check if player has enough money
    if player_state.cash_balance < property_state.house_cost as u64 {
        return Err(GameError::InsufficientFunds.into());
    }

    // Deduct money from player
    player_state.cash_balance = player_state
        .cash_balance
        .checked_sub(property_state.house_cost as u64)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Add house to property
    property_state.houses += 1;

    // Update game state
    game.houses_remaining -= 1;
    game.turn_started_at = clock.unix_timestamp;

    // Update player's net worth
    player_state.net_worth = player_state
        .net_worth
        .checked_add(property_state.house_cost as u64)
        .ok_or(GameError::ArithmeticOverflow)?;

    msg!(
        "Player {} built a house on property {} for ${}",
        player_pubkey,
        position,
        property_state.house_cost
    );

    Ok(())
}

// ---------------------------------------------------------------------------

#[derive(Accounts)]
#[instruction(position: u8)]
pub struct BuildHotel<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump,
        constraint = property_state.owner == Some(player.key()) @ GameError::PropertyNotOwnedByPlayer,
        constraint = !property_state.is_mortgaged @ GameError::PropertyMortgaged,
        constraint = property_state.property_type == PropertyType::Street @ GameError::CannotBuildOnPropertyType,
        constraint = property_state.houses == MAX_HOUSES_PER_PROPERTY @ GameError::InvalidHouseCount,
        constraint = !property_state.has_hotel @ GameError::PropertyHasHotel
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn build_hotel_handler(ctx: Context<BuildHotel>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Check monopoly requirement
    if !has_monopoly_for_player(player_state, property_state.color_group) {
        return Err(GameError::DoesNotOwnColorGroup.into());
    }

    // Check if enough hotels available
    if game.hotels_remaining == 0 {
        return Err(GameError::NotEnoughHotelsInBank.into());
    }

    // Check if player has enough money
    if player_state.cash_balance < property_state.house_cost as u64 {
        return Err(GameError::InsufficientFunds.into());
    }

    // Deduct money from player
    player_state.cash_balance = player_state
        .cash_balance
        .checked_sub(property_state.house_cost as u64)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Convert houses to hotel
    property_state.houses = 0;
    property_state.has_hotel = true;

    // Update game state - return houses to bank and take a hotel
    game.houses_remaining += MAX_HOUSES_PER_PROPERTY;
    game.hotels_remaining -= 1;
    game.turn_started_at = clock.unix_timestamp;

    // Update player's net worth
    player_state.net_worth = player_state
        .net_worth
        .checked_add(property_state.house_cost as u64)
        .ok_or(GameError::ArithmeticOverflow)?;

    msg!(
        "Player {} built a hotel on property {} for ${}",
        player_pubkey,
        position,
        property_state.house_cost
    );

    Ok(())
}

// ---------------------------------------------------------------------------

#[derive(Accounts)]
#[instruction(position: u8, building_type: BuildingType)]
pub struct SellBuilding<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump,
        constraint = property_state.owner == Some(player.key()) @ GameError::PropertyNotOwnedByPlayer,
        constraint = property_state.property_type == PropertyType::Street @ GameError::CannotBuildOnPropertyType
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn sell_building_handler(
    ctx: Context<SellBuilding>,
    position: u8,
    building_type: BuildingType,
) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    let sale_price = property_state.house_cost as u64 / 2; // Sell at half price

    match building_type {
        BuildingType::House => {
            // Check if property has houses to sell
            if property_state.houses == 0 {
                return Err(GameError::NoHousesToSell.into());
            }

            // Check even selling rule
            if !can_sell_evenly_for_player(
                player_state,
                property_state.color_group,
                position,
                property_state.houses - 1,
            ) {
                return Err(GameError::MustSellEvenly.into());
            }

            // Sell house
            property_state.houses -= 1;
            game.houses_remaining += 1;

            msg!(
                "Player {} sold a house from property {} for ${}",
                player_pubkey,
                position,
                sale_price
            );
        }
        BuildingType::Hotel => {
            // Check if property has hotel to sell
            if !property_state.has_hotel {
                return Err(GameError::NoHotelToSell.into());
            }

            // Check if there are enough houses in bank to convert hotel back
            if game.houses_remaining < MAX_HOUSES_PER_PROPERTY {
                return Err(GameError::NotEnoughHousesInBank.into());
            }

            // Sell hotel and convert back to houses
            property_state.has_hotel = false;
            property_state.houses = MAX_HOUSES_PER_PROPERTY;
            game.hotels_remaining += 1;
            game.houses_remaining -= MAX_HOUSES_PER_PROPERTY;

            msg!(
                "Player {} sold a hotel from property {} for ${}",
                player_pubkey,
                position,
                sale_price
            );
        }
    }

    // Add money to player
    player_state.cash_balance = player_state
        .cash_balance
        .checked_add(sale_price)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Update player's net worth
    player_state.net_worth = player_state
        .net_worth
        .checked_sub(sale_price)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Update timestamp
    game.turn_started_at = clock.unix_timestamp;

    Ok(())
}

// ---------------------------------------------------------------------------

#[derive(Accounts)]
#[instruction(position: u8)]
pub struct MortgageProperty<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump,
        constraint = property_state.owner == Some(player.key()) @ GameError::PropertyNotOwnedByPlayer,
        constraint = !property_state.is_mortgaged @ GameError::PropertyAlreadyMortgaged,
        constraint = property_state.houses == 0 @ GameError::CannotMortgageWithBuildings,
        constraint = !property_state.has_hotel @ GameError::CannotMortgageWithBuildings
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn mortgage_property_handler(ctx: Context<MortgageProperty>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Validate position is a mortgageable property
    if !is_property_purchasable(position) {
        return Err(GameError::PropertyNotPurchasable.into());
    }

    // Calculate mortgage value (half of purchase price)
    let mortgage_value = property_state.mortgage_value as u64;

    // Update property state
    property_state.is_mortgaged = true;
    property_state.last_rent_paid = clock.unix_timestamp;

    // Update player cash balance
    player_state.cash_balance += mortgage_value;
    player_state.net_worth -= mortgage_value; // Reduce net worth by mortgage value

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} mortgaged property at position {} for ${}",
        player_pubkey,
        position,
        mortgage_value
    );

    Ok(())
}

#[derive(Accounts)]
#[instruction(position: u8)]
pub struct UnmortgageProperty<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump,
        constraint = property_state.owner == Some(player.key()) @ GameError::PropertyNotOwnedByPlayer,
        constraint = property_state.is_mortgaged @ GameError::PropertyNotMortgaged
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn unmortgage_property_handler(ctx: Context<UnmortgageProperty>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Validate position is a mortgageable property
    if !is_property_purchasable(position) {
        return Err(GameError::PropertyNotPurchasable.into());
    }

    // Calculate unmortgage cost (mortgage value + 10% interest)
    let mortgage_value = property_state.mortgage_value as u64;
    let interest = mortgage_value / 10; // 10% interest
    let unmortgage_cost = mortgage_value + interest;

    // Check if player has enough money
    if player_state.cash_balance < unmortgage_cost {
        return Err(GameError::InsufficientFunds.into());
    }

    // Update property state
    property_state.is_mortgaged = false;
    property_state.last_rent_paid = clock.unix_timestamp;

    // Update player cash balance and net worth
    player_state.cash_balance -= unmortgage_cost;
    player_state.net_worth += mortgage_value; // Restore net worth

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} unmortgaged property at position {} for ${} (mortgage: ${}, interest: ${})",
        player_pubkey,
        position,
        unmortgage_cost,
        mortgage_value,
        interest
    );

    Ok(())
}


// instructions/special_spaces.rs
use crate::error::GameError;
use crate::{constants::*, generate_card_index, send_player_to_jail_and_end_turn, ID};
use crate::{generate_random_seed, state::*};
use anchor_lang::prelude::*;
use ephemeral_vrf_sdk::anchor::vrf;
use ephemeral_vrf_sdk::instructions::create_request_randomness_ix;
use ephemeral_vrf_sdk::types::SerializableAccountMeta;

#[derive(Accounts)]
pub struct GoToJail<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn go_to_jail_handler(ctx: Context<GoToJail>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if !player_state.has_rolled_dice {
        return Err(GameError::HasNotRolledDice.into());
    }

    // Send player to jail
    player_state.in_jail = true;
    player_state.position = JAIL_POSITION;
    player_state.jail_turns = 0;
    player_state.doubles_count = 0; // Reset doubles count when going to jail

    // Clear any pending actions since player is going to jail
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} has been sent to jail at position {}!",
        player_pubkey,
        JAIL_POSITION
    );

    Ok(())
}

// -----------------------------------------------------------------------------
#[derive(Accounts)]
pub struct DrawChanceCard<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    /// CHECK: This is the recent blockhashes sysvar
    #[account(address = anchor_lang::solana_program::sysvar::recent_blockhashes::ID)]
    pub recent_blockhashes: UncheckedAccount<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn draw_chance_card_handler(
    ctx: Context<DrawChanceCard>,
    card_index: Option<u8>,
) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if !player_state.needs_chance_card {
        return Err(GameError::InvalidSpecialSpaceAction.into());
    }

    // Use provided card index for testing, otherwise generate random
    let card_index = if let Some(index) = card_index {
        index as usize
    } else {
        // Generate random card index using recent blockhash
        generate_card_index(
            &ctx.accounts.recent_blockhashes,
            clock.unix_timestamp,
            CHANCE_CARDS.len(),
        )?
    };

    if card_index >= CHANCE_CARDS.len() {
        return Err(GameError::InvalidParameter.into());
    }

    let card = &CHANCE_CARDS[card_index];

    emit!(ChanceCardDrawn {
        player: player_pubkey,
        game: game.key(),
        card_index: card_index as u8,
        effect_type: u8::from(card.effect_type),
        amount: card.amount,
        timestamp: clock.unix_timestamp,
    });

    player_state.card_drawn_at = Some(clock.unix_timestamp);

    // Execute card effect
    execute_chance_card_effect(game, player_state, card, clock)?;

    // Clear the chance card requirement
    player_state.needs_chance_card = false;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!("Player {} drew Chance card: {}", player_pubkey, card.id);

    Ok(())
}

#[vrf]
#[derive(Accounts)]
pub struct DrawCommunityChestCard<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    /// CHECK: This is the recent blockhashes sysvar
    #[account(address = anchor_lang::solana_program::sysvar::recent_blockhashes::ID)]
    pub recent_blockhashes: UncheckedAccount<'info>,

    pub clock: Sysvar<'info, Clock>,

    /// CHECK: The oracle queue (optional for VRF)
    #[account(mut, address = ephemeral_vrf_sdk::consts::DEFAULT_EPHEMERAL_QUEUE)]
    pub oracle_queue: AccountInfo<'info>,
}

pub fn draw_community_chest_card_handler(
    ctx: Context<DrawCommunityChestCard>,
    client_seed: Option<u8>,
    card_index: Option<u8>,
) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Find player index in game.players vector
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    // Verify it's the current player's turn
    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Check if player needs to draw a community chest card
    if !player_state.needs_community_chest_card {
        return Err(GameError::InvalidSpecialSpaceAction.into());
    }

    if let Some(seed) = client_seed {
        if card_index.is_none() {
            msg!("Requesting randomness for community chest card...");

            let ix = create_request_randomness_ix(
                ephemeral_vrf_sdk::instructions::RequestRandomnessParams {
                    payer: ctx.accounts.player.key(),
                    oracle_queue: ctx.accounts.oracle_queue.key(),
                    callback_program_id: ID,
                    callback_discriminator:
                        crate::instruction::CallbackDrawCommunityChestCard::DISCRIMINATOR.to_vec(),
                    caller_seed: [seed; 32],
                    accounts_metas: Some(vec![
                        // game
                        SerializableAccountMeta {
                            pubkey: ctx.accounts.game.key(),
                            is_signer: false,
                            is_writable: true,
                        },
                        // player state
                        SerializableAccountMeta {
                            pubkey: ctx.accounts.player_state.key(),
                            is_signer: false,
                            is_writable: true,
                        },
                        // clock
                        SerializableAccountMeta {
                            pubkey: ctx.accounts.clock.key(),
                            is_signer: false,
                            is_writable: false,
                        },
                    ]),
                    ..Default::default()
                },
            );

            ctx.accounts
                .invoke_signed_vrf(&ctx.accounts.player.to_account_info(), &ix)?;

            return Ok(());
        }
    }

    // Use provided card index for testing, otherwise generate random using recent blockhash
    let card_index = if let Some(index) = card_index {
        index as usize
    } else {
        // Generate random card index using recent blockhash
        generate_card_index(
            &ctx.accounts.recent_blockhashes,
            clock.unix_timestamp,
            COMMUNITY_CHEST_CARDS.len(),
        )?
    };

    if card_index >= COMMUNITY_CHEST_CARDS.len() {
        return Err(GameError::InvalidParameter.into());
    }

    let card = &COMMUNITY_CHEST_CARDS[card_index];

    emit!(CommunityChestCardDrawn {
        player: player_pubkey,
        game: game.key(),
        card_index: card_index as u8,
        effect_type: u8::from(card.effect_type),
        amount: card.amount,
        timestamp: clock.unix_timestamp,
    });

    player_state.card_drawn_at = Some(clock.unix_timestamp);

    // Execute card effect
    execute_community_chest_card_effect(game, player_state, card, clock)?;

    // Clear the community chest card requirement
    player_state.needs_community_chest_card = false;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} drew Community Chest card: {}",
        player_pubkey,
        card.id
    );

    Ok(())
}

// Helper function to execute chance card effects
fn execute_chance_card_effect(
    game: &mut GameState,
    player_state: &mut PlayerState,
    card: &ChanceCard,
    clock: &Sysvar<Clock>,
) -> Result<()> {
    match card.effect_type {
        CardEffectType::Money => {
            if card.amount > 0 {
                player_state.cash_balance += card.amount as u64;
            } else {
                let deduction = (-card.amount) as u64;
                if player_state.cash_balance >= deduction {
                    player_state.cash_balance -= deduction;
                } else {
                    // FIXME  có cần phải set balance = 0 k?
                    player_state.cash_balance = 0;
                    player_state.needs_bankruptcy_check = true;
                }
            }
        }
        CardEffectType::Move => {
            let new_position = if card.amount < 0 {
                // Handle "Go Back 3 Spaces" type cards
                let current_pos = player_state.position as i32;
                let new_pos = current_pos + card.amount;
                if new_pos < 0 {
                    (40 + new_pos) as u8
                } else {
                    new_pos as u8
                }
            } else {
                card.amount as u8
            };

            let old_position = player_state.position;

            // Check if passing GO (only for forward movement)
            if card.amount >= 0 && (new_position < old_position || new_position == 0) {
                player_state.cash_balance += GO_SALARY as u64;
            }

            player_state.position = new_position;

            // Set flags for handling the new space
            if is_property_purchasable(new_position) {
                if !player_state.properties_owned.contains(&new_position) {
                    player_state.needs_property_action = true;
                    player_state.pending_property_position = Some(new_position);
                }
            } else {
                player_state.needs_special_space_action = true;
                player_state.pending_special_space_position = Some(new_position);
            }
        }
        CardEffectType::MoveToNearest => {
            // Move to nearest memecoin property (BONK or WIF)
            let current_pos = player_state.position;
            let bonk_pos = 1; // BONK Avenue position
            let wif_pos = 3; // WIF Lane position

            // Calculate distances to both memecoin properties
            let dist_to_bonk = if bonk_pos > current_pos {
                bonk_pos - current_pos
            } else {
                40 - current_pos + bonk_pos
            };

            let dist_to_wif = if wif_pos > current_pos {
                wif_pos - current_pos
            } else {
                40 - current_pos + wif_pos
            };

            // Move to the nearest one
            let new_position = if dist_to_bonk <= dist_to_wif {
                bonk_pos
            } else {
                wif_pos
            };

            let old_position = player_state.position;

            // Check if passing GO
            if new_position < old_position {
                player_state.cash_balance += GO_SALARY as u64;
            }

            player_state.position = new_position;

            if !player_state.properties_owned.contains(&new_position) {
                player_state.needs_property_action = true;
                player_state.pending_property_position = Some(new_position);
                msg!(
                    "Player landed on unowned property at position {}",
                    new_position
                );
            }
        }
        CardEffectType::GoToJail => {
            send_player_to_jail_and_end_turn(game, player_state, clock);
            return Ok(()); // Early return since turn is ended
        }
        CardEffectType::GetOutOfJailFree => {
            player_state.get_out_of_jail_cards += 1;
        }
        CardEffectType::PayPerProperty => {
            // Calculate repair costs: $25 per house, $100 per hotel
            let mut total_cost = 0u64;

            // Count houses and hotels owned by player
            for &property_pos in &player_state.properties_owned {
                if let Some(property_data) = get_property_data(property_pos) {
                    if property_data.property_type == 0 {
                        // Street property
                        // This would need access to PropertyState to count actual houses/hotels
                        // For now, we'll use a simplified calculation
                        total_cost += 25; // Assume 1 house per property for simplification
                    }
                }
            }

            if player_state.cash_balance >= total_cost {
                player_state.cash_balance -= total_cost;
            } else {
                player_state.cash_balance = 0;
                player_state.needs_bankruptcy_check = true;
            }
        }
        CardEffectType::CollectFromPlayers => {
            // Collect money from all other players
            let amount_per_player = card.amount as u64;
            let total_players = game.players.len() as u64;
            let total_collected = amount_per_player * (total_players - 1); // Exclude current player

            player_state.cash_balance += total_collected;

            // Note: In a full implementation, you'd need to deduct from other players
            // This would require iterating through all player states
        }
        CardEffectType::RepairFree => {
            // Free repairs - no cost for property maintenance
            // This is a positive effect, so no action needed beyond logging
            msg!(
                "Player {} received free property repairs!",
                player_state.wallet
            );
        }
    }

    Ok(())
}

// Helper function to execute community chest card effects
fn execute_community_chest_card_effect(
    game: &mut GameState,
    player_state: &mut PlayerState,
    card: &CommunityChestCard,
    clock: &Sysvar<Clock>,
) -> Result<()> {
    match card.effect_type {
        CardEffectType::Money => {
            if card.amount > 0 {
                player_state.cash_balance += card.amount as u64;
            } else {
                let deduction = (-card.amount) as u64;
                if player_state.cash_balance >= deduction {
                    player_state.cash_balance -= deduction;
                } else {
                    // FIXME  có cần phải set balance = 0 k?
                    player_state.cash_balance = 0;
                    player_state.needs_bankruptcy_check = true;
                }
            }
        }
        CardEffectType::Move => {
            let new_position = card.amount as u8;
            let old_position = player_state.position;

            // Check if passing GO
            if new_position < old_position || new_position == 0 {
                player_state.cash_balance += GO_SALARY as u64;
            }

            player_state.position = new_position;

            // Set flags for handling the new space
            if is_property_purchasable(new_position) {
                player_state.needs_property_action = true;
                player_state.pending_property_position = Some(new_position);
            } else {
                player_state.needs_special_space_action = true;
                player_state.pending_special_space_position = Some(new_position);
            }
        }
        CardEffectType::MoveToNearest => {
            // Not used in community chest cards, but included for completeness
            msg!("MoveToNearest effect not implemented for community chest cards");
        }
        CardEffectType::GoToJail => {
            send_player_to_jail_and_end_turn(game, player_state, clock);
            return Ok(()); // Early return since turn is ended
        }
        CardEffectType::GetOutOfJailFree => {
            player_state.get_out_of_jail_cards += 1;
        }
        CardEffectType::PayPerProperty => {
            // Calculate street repair costs: $40 per house, $115 per hotel
            let mut total_cost = 0u64;

            // Count houses and hotels owned by player
            for &property_pos in &player_state.properties_owned {
                if let Some(property_data) = get_property_data(property_pos) {
                    if property_data.property_type == 0 {
                        // Street property
                        // This would need access to PropertyState to count actual houses/hotels
                        // For now, we'll use a simplified calculation
                        total_cost += 40; // Assume 1 house per property for simplification
                    }
                }
            }

            if player_state.cash_balance >= total_cost {
                player_state.cash_balance -= total_cost;
            } else {
                player_state.cash_balance = 0;
                player_state.needs_bankruptcy_check = true;
            }
        }
        CardEffectType::CollectFromPlayers => {
            // Collect money from all other players (birthday card)
            let amount_per_player = card.amount as u64;
            let total_players = game.players.len() as u64;
            let total_collected = amount_per_player * (total_players - 1); // Exclude current player

            player_state.cash_balance += total_collected;

            // Note: In a full implementation, you'd need to deduct from other players
            // This would require iterating through all player states
        }
        CardEffectType::RepairFree => {
            // Free repairs for all properties - DAO vote win effect
            msg!(
                "Player {} received free property repairs from DAO vote!",
                player_state.wallet
            );
        }
    }

    Ok(())
}

// -----------------------------------------------------------------------------
#[derive(Accounts)]
pub struct CollectFreeParking<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn collect_free_parking_handler(ctx: Context<CollectFreeParking>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Find player index in game.players vector
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    // Verify it's the current player's turn
    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Check if player has rolled dice this turn
    if !player_state.has_rolled_dice {
        return Err(GameError::HasNotRolledDice.into());
    }

    // Verify player is at Free Parking position
    if player_state.position != FREE_PARKING_POSITION {
        return Err(GameError::InvalidBoardPosition.into());
    }

    // Collect the free parking bonus (accumulated taxes and fees)
    let bonus_amount = game.free_parking_pool;
    player_state.cash_balance = player_state
        .cash_balance
        .checked_add(bonus_amount as u64)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Reset the free parking pool
    game.free_parking_pool = 0;

    // Clear pending special space action
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} collected ${} from Free Parking!",
        player_pubkey,
        bonus_amount
    );

    Ok(())
}

// -------------------------------------------------------------
#[derive(Accounts)]
pub struct VisitBeachResort<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn visit_beach_resort_handler(ctx: Context<VisitBeachResort>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Find player index in game.players vector
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    // Verify it's the current player's turn
    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Check if player has rolled dice this turn
    if !player_state.has_rolled_dice {
        return Err(GameError::HasNotRolledDice.into());
    }

    // Verify player is at Beach Resort position
    if player_state.position != FREE_PARKING_POSITION {
        return Err(GameError::InvalidBoardPosition.into());
    }

    // Calculate bonus based on properties owned
    let properties_owned = player_state.properties_owned.len() as u32;
    let bonus_amount = properties_owned * BEACH_RESORT_BONUS_PER_PROPERTY;

    player_state.cash_balance = player_state
        .cash_balance
        .checked_add(bonus_amount as u64)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Clear pending special space action
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} visited Beach Resort and earned ${} (${} per property x {} properties)!",
        player_pubkey,
        bonus_amount,
        BEACH_RESORT_BONUS_PER_PROPERTY,
        properties_owned
    );

    Ok(())
}

// -----------------------------------------------------------------------------

#[derive(Accounts)]
pub struct AttendFestival<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    /// CHECK: This is the recent blockhashes sysvar
    #[account(address = anchor_lang::solana_program::sysvar::recent_blockhashes::ID)]
    pub recent_blockhashes: UncheckedAccount<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn attend_festival_handler(ctx: Context<AttendFestival>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Find player index in game.players vector
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    // Verify it's the current player's turn
    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Check if player has rolled dice this turn
    if !player_state.has_rolled_dice {
        return Err(GameError::HasNotRolledDice.into());
    }

    // Verify player is at Festival position
    if player_state.position != FESTIVAL_POSITION {
        return Err(GameError::InvalidBoardPosition.into());
    }

    // Generate random festival effect
    let random_seed = generate_random_seed(&ctx.accounts.recent_blockhashes, clock.unix_timestamp)?;
    let effect_index = (random_seed % FESTIVAL_EFFECTS.len() as u64) as usize;
    let festival_effect = &FESTIVAL_EFFECTS[effect_index];

    // Apply the festival effect
    if festival_effect.is_positive {
        player_state.cash_balance = player_state
            .cash_balance
            .checked_add(festival_effect.amount as u64)
            .ok_or(GameError::ArithmeticUnderflow)?;
    } else {
        if player_state.cash_balance >= festival_effect.amount as u64 {
            player_state.cash_balance -= festival_effect.amount as u64;
        } else {
            player_state.cash_balance = 0;
        }
    }

    // Clear pending special space action
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} attended festival: {} - ${}{}",
        player_pubkey,
        festival_effect.id, // Changed from description to id
        if festival_effect.is_positive {
            "+"
        } else {
            "-"
        },
        festival_effect.amount
    );

    Ok(())
}

#[derive(Accounts)]
pub struct PayTax<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn pay_mev_tax_handler(ctx: Context<PayTax>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if player_state.position != MEV_TAX_POSITION {
        return Err(GameError::InvalidBoardPosition.into());
    }

    if player_state.cash_balance >= MEV_TAX as u64 {
        player_state.cash_balance = player_state
            .cash_balance
            .checked_sub(MEV_TAX as u64)
            .ok_or(GameError::ArithmeticUnderflow)?;

        player_state.needs_special_space_action = false;
        player_state.pending_special_space_position = None;

        msg!("Player {} paid MEV tax of ${}", player_pubkey, MEV_TAX);
    } else {
        // Player doesn't have enough money - trigger bankruptcy check
        player_state.needs_bankruptcy_check = true;

        msg!(
            "Player {} cannot afford MEV tax of ${}. Bankruptcy check required.",
            player_pubkey,
            MEV_TAX
        );

        return Ok(());
    }

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    Ok(())
}

pub fn pay_priority_fee_tax_handler(ctx: Context<PayTax>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Find player index in game.players vector
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    // Verify it's the current player's turn
    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Verify player is at the priority fee tax position
    if player_state.position != PRIORITY_FEE_TAX_POSITION {
        return Err(GameError::InvalidBoardPosition.into());
    }

    // Check if player has sufficient funds to pay priority fee tax
    if player_state.cash_balance >= PRIORITY_FEE_TAX as u64 {
        // Deduct priority fee tax from player's cash balance
        player_state.cash_balance = player_state
            .cash_balance
            .checked_sub(PRIORITY_FEE_TAX as u64)
            .ok_or(GameError::ArithmeticUnderflow)?;

        // Clear any pending special space action
        player_state.needs_special_space_action = false;
        player_state.pending_special_space_position = None;

        msg!(
            "Player {} paid priority fee tax of ${}",
            player_pubkey,
            PRIORITY_FEE_TAX
        );
    } else {
        // Player doesn't have enough money - trigger bankruptcy check
        player_state.needs_bankruptcy_check = true;

        msg!(
            "Player {} cannot afford priority fee tax of ${}. Bankruptcy check required.",
            player_pubkey,
            PRIORITY_FEE_TAX
        );

        return Err(GameError::InsufficientFunds.into());
    }

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    Ok(())
}

// VRF Implementation for Chance Card Drawing

#[vrf]
#[derive(Accounts)]
pub struct DrawChanceCardVrf<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,

    /// CHECK: The oracle queue
    #[account(mut, address = ephemeral_vrf_sdk::consts::DEFAULT_EPHEMERAL_QUEUE)]
    pub oracle_queue: AccountInfo<'info>,
}

pub fn draw_chance_card_vrf_handler(
    ctx: Context<DrawChanceCardVrf>,
    client_seed: u8,
    card_index: Option<u8>,
) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if !player_state.needs_chance_card {
        return Err(GameError::InvalidSpecialSpaceAction.into());
    }

    if card_index.is_none() {
        msg!("Requesting randomness for chance card...");

        let ix = create_request_randomness_ix(
            ephemeral_vrf_sdk::instructions::RequestRandomnessParams {
                payer: ctx.accounts.player.key(),
                oracle_queue: ctx.accounts.oracle_queue.key(),
                callback_program_id: ID,
                callback_discriminator: crate::instruction::CallbackDrawChanceCard::DISCRIMINATOR
                    .to_vec(),
                caller_seed: [client_seed; 32],
                accounts_metas: Some(vec![
                    // game
                    SerializableAccountMeta {
                        pubkey: ctx.accounts.game.key(),
                        is_signer: false,
                        is_writable: true,
                    },
                    // player state
                    SerializableAccountMeta {
                        pubkey: ctx.accounts.player_state.key(),
                        is_signer: false,
                        is_writable: true,
                    },
                    // clock
                    SerializableAccountMeta {
                        pubkey: ctx.accounts.clock.key(),
                        is_signer: false,
                        is_writable: false,
                    },
                ]),
                ..Default::default()
            },
        );

        ctx.accounts
            .invoke_signed_vrf(&ctx.accounts.player.to_account_info(), &ix)?;
    } else {
        // For testing - handle the card draw directly
        let card_index = card_index.unwrap() as usize;

        if card_index >= CHANCE_CARDS.len() {
            return Err(GameError::InvalidParameter.into());
        }

        let card = &CHANCE_CARDS[card_index];

        emit!(ChanceCardDrawn {
            player: player_pubkey,
            game: game.key(),
            card_index: card_index as u8,
            effect_type: u8::from(card.effect_type),
            amount: card.amount,
            timestamp: clock.unix_timestamp,
        });

        player_state.card_drawn_at = Some(clock.unix_timestamp);

        // Execute card effect
        execute_chance_card_effect(game, player_state, card, clock)?;

        // Clear the chance card requirement
        player_state.needs_chance_card = false;
        player_state.needs_special_space_action = false;
        player_state.pending_special_space_position = None;

        // Update game timestamp
        game.turn_started_at = clock.unix_timestamp;

        msg!(
            "Player {} drew Chance card (test): {}",
            player_pubkey,
            card.id
        );
    }

    Ok(())
}

#[derive(Accounts)]
pub struct CallbackDrawChanceCardCtx<'info> {
    /// This check ensure that the vrf_program_identity (which is a PDA) is a singer
    /// enforcing the callback is executed by the VRF program trough CPI
    #[account(address = ephemeral_vrf_sdk::consts::VRF_PROGRAM_IDENTITY)]
    pub vrf_program_identity: Signer<'info>,

    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", player_state.game.as_ref(), player_state.wallet.as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn callback_draw_chance_card(
    ctx: Context<CallbackDrawChanceCardCtx>,
    randomness: [u8; 32],
) -> Result<()> {
    let card_index =
        ephemeral_vrf_sdk::rnd::random_u8_with_range(&randomness, 0, CHANCE_CARDS.len() as u8 - 1)
            as usize;
    msg!("VRF generated chance card index: {}", card_index);

    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let clock = &ctx.accounts.clock;
    let player_pubkey = player_state.wallet;

    if card_index >= CHANCE_CARDS.len() {
        return Err(GameError::InvalidParameter.into());
    }

    let card = &CHANCE_CARDS[card_index];

    emit!(ChanceCardDrawn {
        player: player_pubkey,
        game: game.key(),
        card_index: card_index as u8,
        effect_type: u8::from(card.effect_type),
        amount: card.amount,
        timestamp: clock.unix_timestamp,
    });

    player_state.card_drawn_at = Some(clock.unix_timestamp);

    // Execute card effect
    execute_chance_card_effect(game, player_state, card, clock)?;

    // Clear the chance card requirement
    player_state.needs_chance_card = false;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} drew Chance card via VRF: {}",
        player_pubkey,
        card.id
    );

    Ok(())
}

#[derive(Accounts)]
pub struct CallbackDrawCommunityChestCardCtx<'info> {
    /// This check ensure that the vrf_program_identity (which is a PDA) is a singer
    /// enforcing the callback is executed by the VRF program trough CPI
    #[account(address = ephemeral_vrf_sdk::consts::VRF_PROGRAM_IDENTITY)]
    pub vrf_program_identity: Signer<'info>,

    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", player_state.game.as_ref(), player_state.wallet.as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn callback_draw_community_chest_card(
    ctx: Context<CallbackDrawCommunityChestCardCtx>,
    randomness: [u8; 32],
) -> Result<()> {
    let card_index = ephemeral_vrf_sdk::rnd::random_u8_with_range(
        &randomness,
        0,
        COMMUNITY_CHEST_CARDS.len() as u8 - 1,
    ) as usize;
    msg!("VRF generated community chest card index: {}", card_index);

    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let clock = &ctx.accounts.clock;
    let player_pubkey = player_state.wallet;

    if card_index >= COMMUNITY_CHEST_CARDS.len() {
        return Err(GameError::InvalidParameter.into());
    }

    let card = &COMMUNITY_CHEST_CARDS[card_index];

    emit!(CommunityChestCardDrawn {
        player: player_pubkey,
        game: game.key(),
        card_index: card_index as u8,
        effect_type: u8::from(card.effect_type),
        amount: card.amount,
        timestamp: clock.unix_timestamp,
    });

    player_state.card_drawn_at = Some(clock.unix_timestamp);

    // Execute card effect
    execute_community_chest_card_effect(game, player_state, card, clock)?;

    // Clear the community chest card requirement
    player_state.needs_community_chest_card = false;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} drew Community Chest card via VRF: {}",
        player_pubkey,
        card.id
    );

    Ok(())
}

// instructions/trading.rs
use crate::constants::*;
use crate::error::GameError;
use crate::state::*;
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct CreateTrade<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), proposer.key().as_ref()],
        bump
    )]
    pub proposer_state: Account<'info, PlayerState>,

    #[account(
        seeds = [b"player", game.key().as_ref(), receiver.key().as_ref()],
        bump
    )]
    pub receiver_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub proposer: Signer<'info>,

    /// CHECK: This is validated by the receiver_state account constraint
    pub receiver: UncheckedAccount<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn create_trade_handler(
    ctx: Context<CreateTrade>,
    trade_type: TradeType,
    proposer_money: u64,
    receiver_money: u64,
    proposer_property: Option<u8>,
    receiver_property: Option<u8>,
) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let proposer_state = &ctx.accounts.proposer_state;
    let receiver_state = &ctx.accounts.receiver_state;
    let clock = &ctx.accounts.clock;

    // Clean up expired trades first
    game.cleanup_expired_trades(clock.unix_timestamp);

    // Check if we can add a new trade
    require!(game.can_add_trade(), GameError::TooManyActiveTrades);

    // Validate trade parameters
    require!(
        proposer_money <= proposer_state.cash_balance,
        GameError::InsufficientFunds
    );

    // Validate proposer property ownership
    if let Some(prop_pos) = proposer_property {
        require!(
            proposer_state.properties_owned.contains(&prop_pos),
            GameError::PropertyNotOwned
        );
    }

    // Validate receiver property ownership
    if let Some(prop_pos) = receiver_property {
        require!(
            receiver_state.properties_owned.contains(&prop_pos),
            GameError::PropertyNotOwned
        );
    }

    // Validate trade type matches the provided parameters
    match trade_type {
        TradeType::MoneyOnly => {
            require!(
                proposer_property.is_none() && receiver_property.is_none(),
                GameError::InvalidTradeType
            );
            require!(
                proposer_money > 0 || receiver_money > 0,
                GameError::InvalidTradeType
            );
        }
        TradeType::PropertyOnly => {
            require!(
                proposer_money == 0 && receiver_money == 0,
                GameError::InvalidTradeType
            );
            require!(
                proposer_property.is_some() || receiver_property.is_some(),
                GameError::InvalidTradeType
            );
        }
        TradeType::MoneyForProperty => {
            require!(
                proposer_money > 0 && receiver_property.is_some(),
                GameError::InvalidTradeType
            );
            require!(
                proposer_property.is_none() && receiver_money == 0,
                GameError::InvalidTradeType
            );
        }
        TradeType::PropertyForMoney => {
            require!(
                proposer_property.is_some() && receiver_money > 0,
                GameError::InvalidTradeType
            );
            require!(
                proposer_money == 0 && receiver_property.is_none(),
                GameError::InvalidTradeType
            );
        }
    }

    // Create the trade
    let trade_id = game.get_next_trade_id();
    let trade = TradeInfo {
        id: trade_id,
        proposer: ctx.accounts.proposer.key(),
        receiver: ctx.accounts.receiver.key(),
        trade_type: trade_type.clone(),
        proposer_money,
        receiver_money,
        proposer_property,
        receiver_property,
        status: TradeStatus::Pending,
        created_at: clock.unix_timestamp,
        expires_at: clock.unix_timestamp + TRADE_EXPIRY_SECONDS,
    };

    game.active_trades.push(trade);

    emit!(TradeCreated {
        game: game.key(),
        trade_id,
        proposer: ctx.accounts.proposer.key(),
        receiver: ctx.accounts.receiver.key(),
        trade_type,
        proposer_money,
        receiver_money,
        proposer_property,
        receiver_property,
        expires_at: clock.unix_timestamp + TRADE_EXPIRY_SECONDS,
    });

    Ok(())
}

#[derive(Accounts)]
#[instruction(trade_id: u8)]
pub struct AcceptTrade<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), proposer_state.wallet.as_ref()],
        bump
    )]
    pub proposer_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), accepter.key().as_ref()],
        bump
    )]
    pub accepter_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub accepter: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn accept_trade_handler(ctx: Context<AcceptTrade>, trade_id: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let proposer_state = &mut ctx.accounts.proposer_state;
    let accepter_state = &mut ctx.accounts.accepter_state;
    let clock = &ctx.accounts.clock;

    // Clean up expired trades first
    // game.cleanup_expired_trades(clock.unix_timestamp);

    // Find the trade
    let trade = game
        .find_trade_by_id(trade_id)
        .ok_or(GameError::TradeNotFound)?
        .clone(); // Clone to avoid borrow checker issues

    // Validate trade
    require!(
        trade.status == TradeStatus::Pending,
        GameError::TradeNotPending
    );
    require!(
        trade.receiver == ctx.accounts.accepter.key(),
        GameError::NotTradeTarget
    );
    require!(
        trade.expires_at > clock.unix_timestamp,
        GameError::TradeExpired
    );

    // Validate funds and properties are still available
    require!(
        proposer_state.cash_balance >= trade.proposer_money,
        GameError::InsufficientFunds
    );
    require!(
        accepter_state.cash_balance >= trade.receiver_money,
        GameError::InsufficientFunds
    );

    if let Some(prop_pos) = trade.proposer_property {
        require!(
            proposer_state.properties_owned.contains(&prop_pos),
            GameError::PropertyNotOwned
        );
    }

    if let Some(prop_pos) = trade.receiver_property {
        require!(
            accepter_state.properties_owned.contains(&prop_pos),
            GameError::PropertyNotOwned
        );
    }

    // Execute the trade
    // Transfer money
    if trade.proposer_money > 0 {
        proposer_state.cash_balance -= trade.proposer_money;
        accepter_state.cash_balance += trade.proposer_money;
    }

    if trade.receiver_money > 0 {
        accepter_state.cash_balance -= trade.receiver_money;
        proposer_state.cash_balance += trade.receiver_money;
    }

    // Transfer properties
    if let Some(prop_pos) = trade.proposer_property {
        proposer_state.properties_owned.retain(|&x| x != prop_pos);
        accepter_state.properties_owned.push(prop_pos);
    }

    if let Some(prop_pos) = trade.receiver_property {
        accepter_state.properties_owned.retain(|&x| x != prop_pos);
        proposer_state.properties_owned.push(prop_pos);
    }

    // Update trade status and remove from active trades
    game.remove_trade_by_id(trade_id);

    emit!(TradeAccepted {
        game: game.key(),
        trade_id,
        proposer: trade.proposer,
        receiver: trade.receiver,
        accepter: ctx.accounts.accepter.key(),
    });

    Ok(())
}

#[derive(Accounts)]
#[instruction(trade_id: u8)]
pub struct RejectTrade<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
    )]
    pub game: Account<'info, GameState>,

    #[account(mut)]
    pub rejecter: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn reject_trade_handler(ctx: Context<RejectTrade>, trade_id: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let clock = &ctx.accounts.clock;

    // Clean up expired trades first
    // game.cleanup_expired_trades(clock.unix_timestamp);

    // Find the trade
    let trade = game
        .find_trade_by_id(trade_id)
        .ok_or(GameError::TradeNotFound)?
        .clone();

    // Validate trade
    require!(
        trade.status == TradeStatus::Pending,
        GameError::TradeNotPending
    );
    require!(
        trade.receiver == ctx.accounts.rejecter.key(),
        GameError::NotTradeTarget
    );

    // Remove the trade
    game.remove_trade_by_id(trade_id);

    emit!(TradeRejected {
        game: game.key(),
        trade_id,
        proposer: trade.proposer,
        receiver: trade.receiver,
        rejecter: ctx.accounts.rejecter.key(),
    });

    Ok(())
}

#[derive(Accounts)]
#[instruction(trade_id: u8)]
pub struct CancelTrade<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
    )]
    pub game: Account<'info, GameState>,

    #[account(mut)]
    pub canceller: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn cancel_trade_handler(ctx: Context<CancelTrade>, trade_id: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let clock = &ctx.accounts.clock;

    // Clean up expired trades first
    // game.cleanup_expired_trades(clock.unix_timestamp);

    // Find the trade
    let trade = game
        .find_trade_by_id(trade_id)
        .ok_or(GameError::TradeNotFound)?
        .clone();

    // Validate trade
    require!(
        trade.status == TradeStatus::Pending,
        GameError::TradeNotPending
    );
    require!(
        trade.proposer == ctx.accounts.canceller.key(),
        GameError::NotTradeProposer
    );

    // Remove the trade
    game.remove_trade_by_id(trade_id);

    emit!(TradeCancelled {
        game: game.key(),
        trade_id,
        proposer: trade.proposer,
        receiver: trade.receiver,
        canceller: ctx.accounts.canceller.key(),
    });

    Ok(())
}

// New instruction to clean up expired trades (can be called by anyone)
#[derive(Accounts)]
pub struct CleanupExpiredTrades<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
    )]
    pub game: Account<'info, GameState>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn cleanup_expired_trades_handler(ctx: Context<CleanupExpiredTrades>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let clock = &ctx.accounts.clock;

    let initial_count = game.active_trades.len();
    game.cleanup_expired_trades(clock.unix_timestamp);
    let final_count = game.active_trades.len();

    emit!(TradesCleanedUp {
        game: game.key(),
        trades_removed: (initial_count - final_count) as u8,
        remaining_trades: final_count as u8,
    });

    Ok(())
}

