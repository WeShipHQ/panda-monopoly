// lib.rs
#![allow(unexpected_cfgs)]
pub mod constants;
pub mod error;
pub mod instructions;
pub mod state;
pub mod utils;

use anchor_lang::prelude::*;
use ephemeral_rollups_sdk::anchor::ephemeral;

pub use constants::*;
pub use instructions::*;
pub use state::*;
pub use utils::*;

declare_id!("4vucUqMcXN4sgLsgnrXTUC9U7ACZ5DmoRBLbWt4vrnyR");

#[program]
#[ephemeral]
pub mod panda_monopoly {
    use super::*;

    // Game management instructions
    pub fn initialize_game(ctx: Context<InitializeGame>, entry_fee: u64) -> Result<()> {
        instructions::initialize::initialize_game_handler(ctx, entry_fee)
    }

    pub fn reset_game_handler<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, ResetGame<'info>>,
    ) -> Result<()> {
        instructions::initialize::reset_game_handler(ctx)
    }

    pub fn undelegate_game_handler<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, UndelegateGame<'info>>,
    ) -> Result<()> {
        instructions::initialize::undelegate_game_handler(ctx)
    }

    pub fn close_game_handler<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, CloseGame<'info>>,
    ) -> Result<()> {
        instructions::initialize::close_game_handler(ctx)
    }

    pub fn join_game(ctx: Context<JoinGame>) -> Result<()> {
        instructions::initialize::join_game_handler(ctx)
    }

    pub fn start_game<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, StartGame<'info>>,
    ) -> Result<()> {
        instructions::initialize::start_game_handler(ctx)
    }

    // Game ending instruction
    pub fn end_game(ctx: Context<EndGame>) -> Result<()> {
        instructions::end_game::end_game_handler(ctx)
    }

    // Dice and movement instructions
    pub fn roll_dice(ctx: Context<RollDice>, dice_roll: Option<[u8; 2]>) -> Result<()> {
        instructions::dice::roll_dice_handler(ctx, dice_roll)
    }

    pub fn roll_dice_vrf_handler(
        ctx: Context<RollDiceVrf>,
        seed: u8,
        dice_roll: Option<[u8; 2]>,
    ) -> Result<()> {
        instructions::dice::roll_dice_vrf_handler(ctx, seed, dice_roll)
    }

    pub fn callback_roll_dice(
        ctx: Context<CallbackRollDiceCtx>,
        randomness: [u8; 32],
    ) -> Result<()> {
        instructions::dice::callback_roll_dice(ctx, randomness)
    }

    pub fn draw_chance_card_vrf_handler(
        ctx: Context<DrawChanceCardVrf>,
        client_seed: u8,
        card_index: Option<u8>,
    ) -> Result<()> {
        instructions::special_spaces::draw_chance_card_vrf_handler(ctx, client_seed, card_index)
    }

    pub fn callback_draw_chance_card(
        ctx: Context<CallbackDrawChanceCardCtx>,
        randomness: [u8; 32],
    ) -> Result<()> {
        instructions::special_spaces::callback_draw_chance_card(ctx, randomness)
    }

    pub fn callback_draw_community_chest_card(
        ctx: Context<CallbackDrawCommunityChestCardCtx>,
        randomness: [u8; 32],
    ) -> Result<()> {
        instructions::special_spaces::callback_draw_community_chest_card(ctx, randomness)
    }

    pub fn end_turn(ctx: Context<EndTurn>) -> Result<()> {
        instructions::end_turn::end_turn_handler(ctx)
    }

    pub fn pay_jail_fine(ctx: Context<PayJailFine>) -> Result<()> {
        instructions::jail::pay_jail_fine_handler(ctx)
    }

    pub fn use_get_out_of_jail_card(ctx: Context<UseGetOutOfJailCard>) -> Result<()> {
        instructions::jail::use_get_out_of_jail_card_handler(ctx)
    }

    // Bankruptcy instruction
    pub fn declare_bankruptcy<'c: 'info, 'info>(
        ctx: Context<'_, '_, 'c, 'info, DeclareBankruptcy<'info>>,
    ) -> Result<()> {
        instructions::bankruptcy::declare_bankruptcy_handler(ctx)
    }

    // Tax instructions
    pub fn pay_mev_tax_handler(ctx: Context<PayTax>) -> Result<()> {
        instructions::special_spaces::pay_mev_tax_handler(ctx)
    }

    pub fn pay_priority_fee_tax_handler(ctx: Context<PayTax>) -> Result<()> {
        instructions::special_spaces::pay_priority_fee_tax_handler(ctx)
    }

    pub fn draw_chance_card(ctx: Context<DrawChanceCard>, card_index: Option<u8>) -> Result<()> {
        instructions::special_spaces::draw_chance_card_handler(ctx, card_index)
    }

    pub fn draw_community_chest_card(
        ctx: Context<DrawCommunityChestCard>,
        client_seed: Option<u8>,
        card_index: Option<u8>,
    ) -> Result<()> {
        instructions::special_spaces::draw_community_chest_card_handler(
            ctx,
            client_seed,
            card_index,
        )
    }

    pub fn collect_free_parking(ctx: Context<CollectFreeParking>) -> Result<()> {
        instructions::special_spaces::collect_free_parking_handler(ctx)
    }

    pub fn visit_beach_resort(ctx: Context<VisitBeachResort>) -> Result<()> {
        instructions::special_spaces::visit_beach_resort_handler(ctx)
    }

    pub fn attend_festival(ctx: Context<AttendFestival>) -> Result<()> {
        instructions::special_spaces::attend_festival_handler(ctx)
    }

    // Property instructions
    pub fn init_property_handler(
        ctx: Context<InitProperty>,
        game_key: Pubkey,
        position: u8,
    ) -> Result<()> {
        instructions::property::init_property_handler(ctx, game_key, position)
    }

    pub fn buy_property(ctx: Context<BuyProperty>, position: u8) -> Result<()> {
        instructions::property::buy_property_handler(ctx, position)
    }

    pub fn decline_property(ctx: Context<DeclineProperty>, position: u8) -> Result<()> {
        instructions::property::decline_property_handler(ctx, position)
    }

    pub fn pay_rent(ctx: Context<PayRent>, position: u8) -> Result<()> {
        instructions::property::pay_rent_handler(ctx, position)
    }

    pub fn build_house(ctx: Context<BuildHouse>, position: u8) -> Result<()> {
        instructions::property::build_house_handler(ctx, position)
    }

    pub fn build_hotel(ctx: Context<BuildHotel>, position: u8) -> Result<()> {
        instructions::property::build_hotel_handler(ctx, position)
    }

    pub fn sell_building(
        ctx: Context<SellBuilding>,
        position: u8,
        building_type: BuildingType,
    ) -> Result<()> {
        instructions::property::sell_building_handler(ctx, position, building_type)
    }

    pub fn mortgage_property(ctx: Context<MortgageProperty>, position: u8) -> Result<()> {
        instructions::property::mortgage_property_handler(ctx, position)
    }

    pub fn unmortgage_property(ctx: Context<UnmortgageProperty>, position: u8) -> Result<()> {
        instructions::property::unmortgage_property_handler(ctx, position)
    }

    // Trading instructions
    pub fn create_trade(
        ctx: Context<CreateTrade>,
        trade_type: TradeType,
        proposer_money: u64,
        receiver_money: u64,
        proposer_property: Option<u8>,
        receiver_property: Option<u8>,
    ) -> Result<()> {
        instructions::trading::create_trade_handler(
            ctx,
            trade_type,
            proposer_money,
            receiver_money,
            proposer_property,
            receiver_property,
        )
    }

    pub fn accept_trade(ctx: Context<AcceptTrade>, trade_id: u8) -> Result<()> {
        instructions::trading::accept_trade_handler(ctx, trade_id)
    }

    pub fn reject_trade(ctx: Context<RejectTrade>, trade_id: u8) -> Result<()> {
        instructions::trading::reject_trade_handler(ctx, trade_id)
    }

    pub fn cancel_trade(ctx: Context<CancelTrade>, trade_id: u8) -> Result<()> {
        instructions::trading::cancel_trade_handler(ctx, trade_id)
    }

    pub fn cleanup_expired_trades(ctx: Context<CleanupExpiredTrades>) -> Result<()> {
        instructions::trading::cleanup_expired_trades_handler(ctx)
    }
}


// utils.rs
use anchor_lang::prelude::*;

use crate::{
    error::GameError, ColorGroup, GameState, PlayerState, PropertyState, PropertyType,
    JAIL_POSITION,
};

// Helper function for rent calculation
pub fn calculate_rent_for_property(
    property_state: &PropertyState,
    owner_state: &PlayerState,
    dice_result: [u8; 2],
) -> Result<u64> {
    match property_state.property_type {
        PropertyType::Street => {
            if property_state.has_hotel {
                Ok(property_state.rent_with_hotel as u64)
            } else if property_state.houses > 0 {
                let house_index = (property_state.houses - 1) as usize;
                if house_index < property_state.rent_with_houses.len() {
                    Ok(property_state.rent_with_houses[house_index] as u64)
                } else {
                    Err(GameError::InvalidHouseCount.into())
                }
            } else {
                // Check for monopoly to double rent
                if has_color_group_monopoly(owner_state, property_state.color_group) {
                    Ok(property_state.rent_with_color_group as u64)
                } else {
                    Ok(property_state.rent_base as u64)
                }
            }
        }
        PropertyType::Railroad => {
            // Count railroads owned by the owner
            let railroads_owned = count_railroads_owned(owner_state);
            let base_rent = property_state.rent_base as u64;

            match railroads_owned {
                1 => Ok(base_rent),
                2 => Ok(base_rent * 2),
                3 => Ok(base_rent * 4),
                4 => Ok(base_rent * 8),
                _ => Ok(base_rent),
            }
        }
        PropertyType::Utility => {
            // Count utilities owned by the owner
            let utilities_owned = count_utilities_owned(owner_state);
            let dice_sum = (dice_result[0] + dice_result[1]) as u64;

            let multiplier = if utilities_owned == 1 { 4 } else { 10 };
            Ok(dice_sum * multiplier)
        }
        _ => Ok(0), // No rent for other property types
    }
}

// Helper function to check if owner has monopoly on color group
fn has_color_group_monopoly(owner_state: &PlayerState, color_group: ColorGroup) -> bool {
    let properties_in_group = get_color_group_properties(color_group);

    properties_in_group
        .iter()
        .all(|&position| owner_state.properties_owned.contains(&position))
}

// Helper function to count railroads owned
fn count_railroads_owned(owner_state: &PlayerState) -> u8 {
    let railroad_positions = [5, 15, 25, 35]; // Railroad positions on the board

    railroad_positions
        .iter()
        .filter(|&&pos| owner_state.properties_owned.contains(&pos))
        .count() as u8
}

// Helper function to count utilities owned
fn count_utilities_owned(owner_state: &PlayerState) -> u8 {
    let utility_positions = [12, 28]; // Electric Company and Water Works

    utility_positions
        .iter()
        .filter(|&&pos| owner_state.properties_owned.contains(&pos))
        .count() as u8
}

// Helper function to get properties in a color group
fn get_color_group_properties(color_group: ColorGroup) -> Vec<u8> {
    match color_group {
        ColorGroup::Brown => vec![1, 3],
        ColorGroup::LightBlue => vec![6, 8, 9],
        ColorGroup::Pink => vec![11, 13, 14],
        ColorGroup::Orange => vec![16, 18, 19],
        ColorGroup::Red => vec![21, 23, 24],
        ColorGroup::Yellow => vec![26, 27, 29],
        ColorGroup::Green => vec![31, 32, 34],
        ColorGroup::DarkBlue => vec![37, 39],
        ColorGroup::Railroad => vec![5, 15, 25, 35],
        ColorGroup::Utility => vec![12, 28],
        ColorGroup::Special => vec![], // No properties in special group
    }
}

// Helper functions for building validation
pub fn has_monopoly_for_player(player_state: &PlayerState, color_group: ColorGroup) -> bool {
    let properties_in_group = get_color_group_properties(color_group);

    properties_in_group
        .iter()
        .all(|&pos| player_state.properties_owned.contains(&pos))
}

pub fn can_build_evenly_for_player(
    _player_state: &PlayerState,
    color_group: ColorGroup,
    _target_position: u8,
    _target_houses: u8,
) -> bool {
    let _properties_in_group = get_color_group_properties(color_group);

    // For this simplified version, we'll assume even building is allowed
    // In a full implementation, you'd need to check other properties in the group
    // This would require additional property state lookups
    true
}

pub fn can_sell_evenly_for_player(
    _player_state: &PlayerState,
    color_group: ColorGroup,
    _target_position: u8,
    _target_houses: u8,
) -> bool {
    let _properties_in_group = get_color_group_properties(color_group);

    // For this simplified version, we'll assume even selling is allowed
    // In a full implementation, you'd need to check other properties in the group
    // This would require additional property state lookups
    true
}

// Helper function to generate random card index
pub fn generate_card_index(
    recent_blockhashes: &UncheckedAccount,
    timestamp: i64,
    deck_size: usize,
) -> Result<usize> {
    // Get recent blockhash data for randomness
    let data = recent_blockhashes.try_borrow_data()?;

    // Use a combination of blockhash and timestamp for randomness
    let mut seed_bytes = [0u8; 32];

    // Take first 24 bytes from recent blockhash data
    if data.len() >= 24 {
        seed_bytes[..24].copy_from_slice(&data[..24]);
    }

    // Add timestamp to last 8 bytes
    let timestamp_bytes = timestamp.to_le_bytes();
    seed_bytes[24..].copy_from_slice(&timestamp_bytes);

    // Generate random index
    let random_value =
        u32::from_le_bytes([seed_bytes[0], seed_bytes[1], seed_bytes[2], seed_bytes[3]]);

    Ok((random_value as usize) % deck_size)
}

// Helper function for generating random seed (similar to dice roll generation)
pub fn generate_random_seed(recent_blockhashes: &UncheckedAccount, timestamp: i64) -> Result<u64> {
    let recent_blockhashes_data = recent_blockhashes.try_borrow_data()?;

    if recent_blockhashes_data.len() < 8 {
        return Err(GameError::RandomnessUnavailable.into());
    }

    let mut seed_bytes = [0u8; 8];
    seed_bytes.copy_from_slice(&recent_blockhashes_data[0..8]);

    let blockhash_seed = u64::from_le_bytes(seed_bytes);
    let timestamp_seed = timestamp as u64;

    Ok(blockhash_seed.wrapping_mul(timestamp_seed))
}

pub fn xorshift64star(seed: u64) -> u64 {
    let mut x = seed;
    x ^= x << 12;
    x ^= x >> 25;
    x ^= x << 27;
    x = (x as u128 * 0x2545F4914F6CDD1D) as u64;
    x
}

// Replace the existing send_player_to_jail function with this enhanced version
pub fn send_player_to_jail_and_end_turn(
    game: &mut GameState,
    player_state: &mut PlayerState,
    clock: &Sysvar<Clock>,
) {
    // Send player to jail
    player_state.position = JAIL_POSITION;
    player_state.in_jail = true;
    player_state.jail_turns = 0;
    player_state.doubles_count = 0;

    // Clear any pending actions since player is going to jail
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;

    // Automatically end turn
    player_state.has_rolled_dice = false;

    // Advance to next player
    let next_turn = (game.current_turn + 1) % game.current_players;
    game.current_turn = next_turn;
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player sent to jail and turn ended automatically. Next turn: Player {}",
        next_turn
    );
}

pub fn send_player_to_jail(player_state: &mut PlayerState) {
    player_state.position = JAIL_POSITION;
    player_state.in_jail = true;
    player_state.jail_turns = 0;
    player_state.doubles_count = 0;

    // Clear any pending actions since player is going to jail
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;
}

pub fn force_end_turn(game: &mut GameState, player_state: &mut PlayerState, clock: &Sysvar<Clock>) {
    // Reset turn-specific flags
    player_state.has_rolled_dice = false;
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;

    // Reset doubles count when turn ends
    player_state.doubles_count = 0;

    // Advance to next player
    let next_turn = (game.current_turn + 1) % game.current_players;
    game.current_turn = next_turn;
    game.turn_started_at = clock.unix_timestamp;

    msg!("Turn automatically ended. Next turn: Player {}", next_turn);
}

// error.rs
use anchor_lang::prelude::*;

#[error_code]
pub enum GameError {
    
}


// constants.rs
use anchor_lang::prelude::*;

// Entry fee and vault constants
pub const GAME_AUTHORITY_SEED: &[u8] = b"game_authority";
pub const TOKEN_VAULT_SEED: &[u8] = b"token_vault";
pub const WINNER_PERCENTAGE: u16 = 9500; // 95%
pub const PLATFORM_PERCENTAGE: u16 = 100; // 1%

// Game configuration constants
pub const MAX_PLAYERS: u8 = 4;
pub const MIN_PLAYERS: u8 = 2;
pub const BOARD_SIZE: u8 = 40;
pub const STARTING_MONEY: u32 = 1500;
pub const GO_SALARY: u32 = 200;
pub const JAIL_FINE: u32 = 50;
pub const MAX_JAIL_TURNS: u8 = 3;

pub const MEV_TAX: u32 = 200;
pub const PRIORITY_FEE_TAX: u32 = 75;

pub const MEV_TAX_POSITION: u8 = 4;
pub const PRIORITY_FEE_TAX_POSITION: u8 = 38;

// Update existing constants
pub const BANKRUPTCY_THRESHOLD: u32 = 0;

// Railroad rent
pub const RAILROAD_BASE_RENT: u32 = 25;
pub const MAX_HOUSES_PER_PROPERTY: u8 = 4;
pub const TOTAL_HOUSES: u8 = 32;
pub const TOTAL_HOTELS: u8 = 12;

// Trading and auction constants
pub const MAX_PROPERTIES_IN_TRADE: usize = 10;
pub const TRADE_EXPIRY_SECONDS: i64 = 3600; // 1 hour
pub const MAX_ACTIVE_TRADES: usize = 20; // Maximum trades stored in GameState vector
pub const AUCTION_DURATION_SECONDS: i64 = 300; // 5 minutes

// Special space positions
pub const GO_POSITION: u8 = 0; // Solana Genesis
pub const JAIL_POSITION: u8 = 10; // Validator Jail
pub const GO_TO_JAIL_POSITION: u8 = 30; // Go To Validator Jail
pub const FREE_PARKING_POSITION: u8 = 20; // Free Airdrop Parking
                                          // pub const BEACH_RESORT_POSITION: u8 = 20; // Replaces Free Parking
pub const FESTIVAL_POSITION: u8 = 10; // Additional special space

// Chance and Community Chest positions (now themed)
pub const CHANCE_POSITIONS: [u8; 3] = [7, 22, 36]; // Pump.fun Surprise
pub const COMMUNITY_CHEST_POSITIONS: [u8; 3] = [2, 17, 33]; // Airdrop Chest

// Beach Resort and Festival positions (custom spaces)

// Seed for randomness
pub const RANDOMNESS_SEED: &[u8] = b"panda_monopoly_v1";
pub const BEACH_RESORT_BONUS_PER_PROPERTY: u32 = 10;
// pub const FREE_PARKING_POSITION: u8 = 20;
// pub const JAIL_POSITION: u8 = 10;

// Property Group Colors
pub const BROWN_GROUP: [u8; 2] = [1, 3];
pub const LIGHT_BLUE_GROUP: [u8; 3] = [6, 8, 9];
pub const PINK_GROUP: [u8; 3] = [11, 13, 14];
pub const ORANGE_GROUP: [u8; 3] = [16, 18, 19];
pub const RED_GROUP: [u8; 3] = [21, 23, 24];
pub const YELLOW_GROUP: [u8; 3] = [26, 27, 29];
pub const GREEN_GROUP: [u8; 3] = [31, 32, 34];
pub const DARK_BLUE_GROUP: [u8; 2] = [37, 39];
pub const RAILROAD_GROUP: [u8; 4] = [5, 15, 25, 35];
pub const UTILITY_GROUP: [u8; 2] = [12, 28];

// Property Data Structure
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, PartialEq)]
pub struct PropertyData {
    pub position: u8,
    pub price: u64,
    pub rent: [u64; 6], // Base rent, 1 house, 2 houses, 3 houses, 4 houses, hotel
    pub house_cost: u64,
    pub mortgage_value: u64,
    pub color_group: u8,
    pub property_type: u8, // 0: Street, 1: Railroad, 2: Utility, 3: Special
}

// Board Layout - All 40 spaces
pub const BOARD_SPACES: [PropertyData; 40] = [
    // info
];

// Helper functions
pub fn get_property_data(position: u8) -> Option<&'static PropertyData> {
    if position < BOARD_SIZE {
        Some(&BOARD_SPACES[position as usize])
    } else {
        None
    }
}

pub fn is_property_purchasable(position: u8) -> bool {
    if let Some(property) = get_property_data(position) {
        property.price > 0
    } else {
        false
    }
}

pub fn get_color_group_properties_enum(color_group: crate::state::ColorGroup) -> Vec<u8> {
    use crate::state::ColorGroup;
    match color_group {
        ColorGroup::Brown => BROWN_GROUP.to_vec(),
        ColorGroup::LightBlue => LIGHT_BLUE_GROUP.to_vec(),
        ColorGroup::Pink => PINK_GROUP.to_vec(),
        ColorGroup::Orange => ORANGE_GROUP.to_vec(),
        ColorGroup::Red => RED_GROUP.to_vec(),
        ColorGroup::Yellow => YELLOW_GROUP.to_vec(),
        ColorGroup::Green => GREEN_GROUP.to_vec(),
        ColorGroup::DarkBlue => DARK_BLUE_GROUP.to_vec(),
        ColorGroup::Railroad => RAILROAD_GROUP.to_vec(),
        ColorGroup::Utility => UTILITY_GROUP.to_vec(),
        ColorGroup::Special => vec![], // Special spaces don't form groups
    }
}

pub fn get_color_group_properties(color_group: u8) -> Vec<u8> {
    match color_group {
        1 => BROWN_GROUP.to_vec(),
        2 => LIGHT_BLUE_GROUP.to_vec(),
        3 => PINK_GROUP.to_vec(),
        4 => ORANGE_GROUP.to_vec(),
        5 => RED_GROUP.to_vec(),
        6 => YELLOW_GROUP.to_vec(),
        7 => GREEN_GROUP.to_vec(),
        8 => DARK_BLUE_GROUP.to_vec(),
        9 => RAILROAD_GROUP.to_vec(),
        10 => UTILITY_GROUP.to_vec(),
        _ => vec![],
    }
}

pub fn calculate_railroad_rent(railroads_owned: u8) -> u64 {
    match railroads_owned {
        1 => 25,
        2 => 50,
        3 => 100,
        4 => 200,
        _ => 0,
    }
}

pub fn calculate_utility_rent(dice_roll: u8, utilities_owned: u8) -> u64 {
    let multiplier = if utilities_owned == 1 { 4 } else { 10 };
    (dice_roll as u64) * multiplier
}

// Card effect types for Solana-themed cards
#[derive(Clone, Copy, PartialEq)]
pub enum CardEffectType {
    Money,
    Move,
    GoToJail,
    GetOutOfJailFree,
    PayPerProperty,
    CollectFromPlayers,
    MoveToNearest, // For moving to nearest memecoin/railroad/utility
    RepairFree,    // For free repairs
}

impl From<CardEffectType> for u8 {
    fn from(effect_type: CardEffectType) -> Self {
        match effect_type {
            CardEffectType::Money => 0,
            CardEffectType::Move => 1,
            CardEffectType::GoToJail => 2,
            CardEffectType::GetOutOfJailFree => 3,
            CardEffectType::PayPerProperty => 4,
            CardEffectType::CollectFromPlayers => 5,
            CardEffectType::MoveToNearest => 6,
            CardEffectType::RepairFree => 7,
        }
    }
}

// Chance card structure (Pump.fun Surprise)
#[derive(Clone)]
pub struct ChanceCard {
    pub id: u8,
    pub effect_type: CardEffectType,
    pub amount: i32,
}

// Community Chest card structure (Airdrop Chest)
#[derive(Clone)]
pub struct CommunityChestCard {
    pub id: u8,
    pub effect_type: CardEffectType,
    pub amount: i32,
}

// Festival effect structure
#[derive(Clone)]
pub struct FestivalEffect {
    pub id: u8,
    pub amount: u32,
    pub is_positive: bool,
}

// Pump.fun Surprise Cards (Chance cards)
pub const CHANCE_CARDS: [ChanceCard; 5] = [
    // info
];

// Airdrop Chest Cards (Community Chest cards)
pub const COMMUNITY_CHEST_CARDS: [CommunityChestCard; 5] = [
    // data
];

// Festival effects (keeping original structure but updating for Solana theme)
pub const FESTIVAL_EFFECTS: [FestivalEffect; 4] = [
    FestivalEffect {
        id: 1, // "Validator Performance Bonus"
        amount: 100,
        is_positive: true,
    },
    FestivalEffect {
        id: 2, // "Successful DeFi Yield"
        amount: 150,
        is_positive: true,
    },
    FestivalEffect {
        id: 3, // "NFT Royalty Income"
        amount: 75,
        is_positive: true,
    },
    FestivalEffect {
        id: 4, // "Ecosystem Grant Awarded"
        amount: 200,
        is_positive: true,
    },
    
];



// state/mod.rs
use anchor_lang::prelude::*;

mod events;
pub use events::*;

use crate::STARTING_MONEY;

#[account]
#[derive(InitSpace, Debug)]
pub struct PlatformConfig {
    pub id: Pubkey,
    pub fee_basis_points: u16, // 500 = 5%
    pub authority: Pubkey,
    pub fee_vault: Pubkey,
    pub total_games_created: u64,
    pub next_game_id: u64,
    pub bump: u8,
}

impl PlatformConfig {
    pub fn calculate_fee(&self, amount: u64) -> u64 {
        (amount * self.fee_basis_points as u64) / 10000
    }
}

#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq)]
pub enum GameStatus {
    WaitingForPlayers,
    InProgress,
    Finished,
}

#[derive(AnchorSerialize, AnchorDeserialize, Debug, InitSpace, Clone, PartialEq, Eq)]
pub enum TradeStatus {
    Pending,
    Accepted,
    Rejected,
    Cancelled,
    Expired,
}

#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone, Copy, PartialEq, Eq)]
pub enum ColorGroup {
    Brown,
    LightBlue,
    Pink,
    Orange,
    Red,
    Yellow,
    Green,
    DarkBlue,
    Railroad,
    Utility,
    Special,
}

#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq)]
pub enum PropertyType {
    Property,
    Street,
    Railroad,
    Utility,
    Corner,
    Chance,
    CommunityChest,
    Tax,
    Beach,
    Festival,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, PartialEq, Eq)]
pub enum BuildingType {
    House,
    Hotel,
}

// New simplified trade structure for storing in GameState vector
#[derive(Debug, InitSpace, AnchorSerialize, AnchorDeserialize, Clone)]
pub struct TradeInfo {
    pub id: u8,                        // Unique trade ID within the game
    pub proposer: Pubkey,              // Trade proposer
    pub receiver: Pubkey,              // Trade receiver
    pub trade_type: TradeType,         // Type of trade
    pub proposer_money: u64,           // Money offered by proposer
    pub receiver_money: u64,           // Money requested from receiver
    pub proposer_property: Option<u8>, // Property offered by proposer
    pub receiver_property: Option<u8>, // Property requested from receiver
    pub status: TradeStatus,           // Current trade status
    pub created_at: i64,               // Creation timestamp
    pub expires_at: i64,               // Expiration timestamp
}

#[account]
#[derive(Debug, InitSpace)]
pub struct GameState {
    pub game_id: u64,
    pub config_id: Pubkey,
    pub creator: Pubkey,   // 32 bytes - game creator
    pub bump: u8,            // 1 byte - PDA bump seed
    pub max_players: u8,     // 1 byte - maximum players (2-8)
    pub current_players: u8, // 1 byte - current player count
    pub current_turn: u8,    // 1 byte - whose turn (player index)
    #[max_len(4)]
    pub players: Vec<Pubkey>, // 32 * 8 = 256 bytes max
    pub created_at: i64,     // 8 bytes - game creation timestamp
    pub game_status: GameStatus, // 1 byte - current game status
    pub bank_balance: u64,   // 8 bytes - bank's money
    pub free_parking_pool: u64, // 8 bytes - parking pool
    pub houses_remaining: u8, // 1 byte - houses left in bank (32 total)
    pub hotels_remaining: u8, // 1 byte - hotels left in bank (12 total)
    pub time_limit: Option<i64>, // 9 bytes - optional time limit
    pub winner: Option<Pubkey>, // 33 bytes - game winner
    pub turn_started_at: i64, // 8 bytes - when current turn started

    // Entry fee fields
    pub entry_fee: u64, // 8 bytes - entry fee amount (0 for free games)
    pub token_mint: Option<Pubkey>, // 33 bytes - token mint for entry fee
    pub token_vault: Option<Pubkey>, // 33 bytes - vault holding entry fees
    pub total_prize_pool: u64, // 8 bytes - total collected fees

    #[max_len(20)]
    pub active_trades: Vec<TradeInfo>, // Vector of active trades
    pub next_trade_id: u8, // Next trade ID to assign

                           // #[max_len(40)]
                           // pub active_properties: Vec<PropertyState>, // Vector of active properties
                           // pub next_property_id: u8, // Next property ID to assign
}

impl GameState {
    pub fn cleanup_expired_trades(&mut self, current_time: i64) {
        self.active_trades.retain(|trade| {
            trade.expires_at > current_time && trade.status == TradeStatus::Pending
        });
    }

    pub fn find_trade_by_id(&self, trade_id: u8) -> Option<&TradeInfo> {
        self.active_trades.iter().find(|trade| trade.id == trade_id)
    }

    pub fn find_trade_by_id_mut(&mut self, trade_id: u8) -> Option<&mut TradeInfo> {
        self.active_trades
            .iter_mut()
            .find(|trade| trade.id == trade_id)
    }

    pub fn remove_trade_by_id(&mut self, trade_id: u8) -> bool {
        if let Some(pos) = self
            .active_trades
            .iter()
            .position(|trade| trade.id == trade_id)
        {
            self.active_trades.remove(pos);
            true
        } else {
            false
        }
    }

    pub fn can_add_trade(&self) -> bool {
        self.active_trades.len() < crate::constants::MAX_ACTIVE_TRADES
    }

    pub fn get_next_trade_id(&mut self) -> u8 {
        let id = self.next_trade_id;
        self.next_trade_id = self.next_trade_id.wrapping_add(1);
        id
    }
}

#[account]
#[derive(Debug, InitSpace)]
pub struct PlayerState {
    pub wallet: Pubkey,    // 32 bytes - player's wallet
    pub game: Pubkey,      // 32 bytes - game account
    pub cash_balance: u64, // 8 bytes - player's cash
    pub position: u8,      // 1 byte - board position (0-39)
    pub in_jail: bool,     // 1 byte - jail status
    pub jail_turns: u8,    // 1 byte - turns in jail
    pub doubles_count: u8, // 1 byte - consecutive doubles
    pub is_bankrupt: bool, // 1 byte - bankruptcy status
    #[max_len(50)]
    pub properties_owned: Vec<u8>, // variable - owned property positions
    pub get_out_of_jail_cards: u8, // 1 byte - jail cards owned
    pub net_worth: u64,    // 8 bytes - total asset value
    pub last_rent_collected: i64, // 8 bytes - last rent collection time
    pub festival_boost_turns: u8, // 1 byte - remaining festival boost turns

    pub has_rolled_dice: bool,       // 1 byte - has rolled dice this turn
    pub last_dice_roll: [u8; 2],     // 2 bytes - last dice roll
    pub needs_property_action: bool, // Player landed on property
    pub pending_property_position: Option<u8>, // Which property
    pub needs_chance_card: bool,     // Needs to draw chance card
    pub needs_community_chest_card: bool, // Needs to draw community chest
    pub needs_bankruptcy_check: bool, // Insufficient funds detected
    // pub can_end_turn: bool,          // All actions completed
    pub needs_special_space_action: bool, // Player landed on special space
    pub pending_special_space_position: Option<u8>, // Which special space

    pub card_drawn_at: Option<i64>, // Timestamp when card was drawn
}

impl PlayerState {
    pub fn initialize_player_state(
        self: &mut PlayerState,
        wallet: Pubkey,
        game: Pubkey,
        clock: &Sysvar<Clock>,
    ) {
        self.wallet = wallet;
        self.game = game;
        self.cash_balance = STARTING_MONEY as u64;
        self.position = 0;
        self.in_jail = false;
        self.jail_turns = 0;
        self.doubles_count = 0;
        self.is_bankrupt = false;
        self.properties_owned = Vec::new();
        self.get_out_of_jail_cards = 0;
        self.net_worth = STARTING_MONEY as u64;
        self.last_rent_collected = clock.unix_timestamp;
        self.festival_boost_turns = 0;
        self.has_rolled_dice = false;
        self.last_dice_roll = [0, 0];
        self.needs_property_action = false;
        self.pending_property_position = None;
        self.needs_chance_card = false;
        self.needs_community_chest_card = false;
        self.needs_bankruptcy_check = false;
        // self.can_end_turn = false;
        self.needs_special_space_action = false;
        self.pending_special_space_position = None;
        self.card_drawn_at = None;
    }
}

#[account]
#[derive(Debug, InitSpace)]
pub struct PropertyState {
    pub position: u8,                // 1 byte - board position (0-39)
    pub game: Pubkey,                // 32 bytes - game account
    pub owner: Option<Pubkey>,       // 33 bytes - property owner
    pub price: u16,                  // 2 bytes - purchase price
    pub color_group: ColorGroup,     // 1 byte - property color group
    pub property_type: PropertyType, // 1 byte - type of space
    pub houses: u8,                  // 1 byte - number of houses (0-4)
    pub has_hotel: bool,             // 1 byte - hotel status
    pub is_mortgaged: bool,          // 1 byte - mortgage status
    pub rent_base: u16,              // 2 bytes - base rent
    pub rent_with_color_group: u16,  // 2 bytes - rent with monopoly
    pub rent_with_houses: [u16; 4],  // 8 bytes - rent with 1-4 houses
    pub rent_with_hotel: u16,        // 2 bytes - rent with hotel
    pub house_cost: u16,             // 2 bytes - cost to build house
    pub mortgage_value: u16,         // 2 bytes - mortgage value
    pub last_rent_paid: i64,         // 8 bytes - last rent payment time
    pub init: bool,                  // 1 byte - init status
}

impl PropertyState {}

#[derive(AnchorSerialize, AnchorDeserialize, Debug, InitSpace, Clone, PartialEq, Eq)]
pub enum TradeType {
    MoneyOnly,
    PropertyOnly,
    MoneyForProperty,
    PropertyForMoney,
}

#[account]
#[derive(Debug, InitSpace)]
pub struct TradeState {
    pub game: Pubkey,
    pub proposer: Pubkey,
    pub receiver: Pubkey,
    pub trade_type: TradeType,

    // Money amounts
    pub proposer_money: u64,
    pub receiver_money: u64,

    // Single property (since you want 1 item per trade)
    pub proposer_property: Option<u8>, // property position
    pub receiver_property: Option<u8>, // property position

    pub status: TradeStatus,
    pub created_at: i64,
    pub expires_at: i64,
    pub bump: u8,
}

impl TradeState {}

#[account]
#[derive(Debug, InitSpace)]
pub struct AuctionState {
    pub game: Pubkey,
    pub property_position: u8,
    pub current_bid: u64,
    pub highest_bidder: Option<Pubkey>,
    pub started_at: i64,
    pub ends_at: i64,
    pub is_active: bool,
    pub bump: u8,
}

// state/events.rs
use anchor_lang::prelude::*;
use crate::state::TradeType;

#[event]
pub struct ChanceCardDrawn {
    pub player: Pubkey,
    pub game: Pubkey,
    pub card_index: u8,
    pub effect_type: u8, // 0=Money, 1=Move, 2=GoToJail, 3=GetOutOfJailFree, 4=PayPerProperty, 5=CollectFromPlayers
    pub amount: i32,
    pub timestamp: i64,
}

#[event]
pub struct CommunityChestCardDrawn {
    pub player: Pubkey,
    pub game: Pubkey,
    pub card_index: u8,
    pub effect_type: u8, // 0=Money, 1=Move, 2=GoToJail, 3=GetOutOfJailFree, 4=PayPerProperty, 5=CollectFromPlayers
    pub amount: i32,
    pub timestamp: i64,
}

#[event]
pub struct PlayerPassedGo {
    pub player: Pubkey,
    pub game_id: u64,
    pub salary_collected: u64,
    pub new_position: u8,
    pub timestamp: i64,
}

// Game ending event
#[event]
pub struct GameEnded {
    pub game_id: u64,
    pub winner: Option<Pubkey>,
    pub ended_at: i64,
}

// New trade events for vector-based trading
#[event]
pub struct TradeCreated {
    pub game: Pubkey,
    pub trade_id: u8,
    pub proposer: Pubkey,
    pub receiver: Pubkey,
    pub trade_type: TradeType,
    pub proposer_money: u64,
    pub receiver_money: u64,
    pub proposer_property: Option<u8>,
    pub receiver_property: Option<u8>,
    pub expires_at: i64,
}

#[event]
pub struct TradeAccepted {
    pub game: Pubkey,
    pub trade_id: u8,
    pub proposer: Pubkey,
    pub receiver: Pubkey,
    pub accepter: Pubkey,
}

#[event]
pub struct TradeRejected {
    pub game: Pubkey,
    pub trade_id: u8,
    pub proposer: Pubkey,
    pub receiver: Pubkey,
    pub rejecter: Pubkey,
}

#[event]
pub struct TradeCancelled {
    pub game: Pubkey,
    pub trade_id: u8,
    pub proposer: Pubkey,
    pub receiver: Pubkey,
    pub canceller: Pubkey,
}

#[event]
pub struct TradesCleanedUp {
    pub game: Pubkey,
    pub trades_removed: u8,
    pub remaining_trades: u8,
}


// instructions/bankruptcy.rs
use crate::error::GameError;
use crate::instructions::end_game::check_game_end_condition;
use crate::state::*;
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct DeclareBankruptcy<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump,
        constraint = !player_state.is_bankrupt @ GameError::BankruptcyAlreadyStarted
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn declare_bankruptcy_handler<'c: 'info, 'info>(
    ctx: Context<'_, '_, 'c, 'info, DeclareBankruptcy<'info>>,
) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Find player index in game.players vector
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    // Verify it's the player's turn or they need bankruptcy check
    if game.current_turn != player_index as u8 && !player_state.needs_bankruptcy_check {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Mark player as bankrupt
    player_state.is_bankrupt = true;

    // Calculate total liquidation value from properties
    let mut total_liquidation_value = 0u64;
    let mut houses_returned = 0u8;
    let mut hotels_returned = 0u8;

    // Get all property accounts from remaining accounts
    let remaining_accounts = &mut ctx.remaining_accounts.iter();

    for _i in 0..player_state.properties_owned.len() {
        let property_account_info = next_account_info(remaining_accounts)?;

        // let mut property_data = property_account_info.try_borrow_mut_data()?;

        let mut property_state: Account<PropertyState> =
            Account::try_from_unchecked(property_account_info)?;

        // Verify this property belongs to the bankrupt player
        if property_state.owner == Some(player_pubkey) {
            // Calculate building liquidation value
            let building_value = calculate_building_liquidation_value(&property_state)?;
            total_liquidation_value = total_liquidation_value
                .checked_add(building_value)
                .ok_or(GameError::ArithmeticOverflow)?;

            // Return buildings to bank
            if property_state.houses > 0 {
                houses_returned = houses_returned
                    .checked_add(property_state.houses)
                    .ok_or(GameError::ArithmeticOverflow)?;
                property_state.houses = 0;
            }

            if property_state.has_hotel {
                hotels_returned = hotels_returned
                    .checked_add(1)
                    .ok_or(GameError::ArithmeticOverflow)?;
                property_state.has_hotel = false;
            }

            // Calculate mortgage value if not already mortgaged
            if !property_state.is_mortgaged {
                let mortgage_value = property_state.mortgage_value as u64;
                total_liquidation_value = total_liquidation_value
                    .checked_add(mortgage_value)
                    .ok_or(GameError::ArithmeticOverflow)?;
            }

            // Clear ownership
            property_state.owner = None;
            property_state.is_mortgaged = false;
        }
    }

    // Return buildings to bank
    game.houses_remaining = game
        .houses_remaining
        .checked_add(houses_returned)
        .ok_or(GameError::ArithmeticOverflow)?;

    game.hotels_remaining = game
        .hotels_remaining
        .checked_add(hotels_returned)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Add liquidation value to bank
    game.bank_balance = game
        .bank_balance
        .checked_add(total_liquidation_value)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Clear bankruptcy check flag
    player_state.needs_bankruptcy_check = false;

    // Transfer all remaining cash to the bank
    let remaining_cash = player_state.cash_balance;
    game.bank_balance = game
        .bank_balance
        .checked_add(remaining_cash)
        .ok_or(GameError::ArithmeticOverflow)?;

    player_state.cash_balance = 0;
    player_state.net_worth = 0;

    // Clear all properties owned from player state
    player_state.properties_owned.clear();

    // Clear Get Out of Jail Free cards
    player_state.get_out_of_jail_cards = 0;

    // Clear all player flags and reset position
    reset_player_state_for_bankruptcy(player_state);

    // Remove player from active game
    remove_player_from_game(game, player_index as u8)?;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} declared bankruptcy. Liquidated ${} in assets, ${} cash transferred to bank. {} houses and {} hotels returned to bank.",
        player_pubkey,
        total_liquidation_value,
        remaining_cash,
        houses_returned,
        hotels_returned
    );

    // Check if game should end (only one player remaining)
    if check_game_end_condition(game) {
        game.game_status = GameStatus::Finished;

        // Find the remaining player and declare them winner
        if let Some(winner_pubkey) = game
            .players
            .iter()
            .find(|&&p| p != Pubkey::default())
            .copied()
        {
            game.winner = Some(winner_pubkey);
            msg!("Game ended. Winner: {}", winner_pubkey);

            emit!(GameEnded {
                game_id: game.game_id,
                winner: Some(winner_pubkey),
                ended_at: clock.unix_timestamp,
            });
        } else {
            // No players remaining (shouldn't happen in normal gameplay)
            msg!("Game ended with no remaining players");

            emit!(GameEnded {
                game_id: game.game_id,
                winner: None,
                ended_at: clock.unix_timestamp,
            });
        }
    } else {
        // Advance to next player's turn
        if game.current_turn >= game.current_players {
            game.current_turn = 0;
        }
    }

    Ok(())
}

fn calculate_building_liquidation_value(property_state: &PropertyState) -> Result<u64> {
    let mut value = 0u64;

    // Houses sell for half their cost
    if property_state.houses > 0 {
        let house_value = (property_state.house_cost as u64 / 2) * property_state.houses as u64;
        value = value
            .checked_add(house_value)
            .ok_or(GameError::ArithmeticOverflow)?;
    }

    // Hotels sell for half their cost (house_cost * 5 / 2)
    if property_state.has_hotel {
        let hotel_value = (property_state.house_cost as u64 * 5) / 2;
        value = value
            .checked_add(hotel_value)
            .ok_or(GameError::ArithmeticOverflow)?;
    }

    Ok(value)
}

fn reset_player_state_for_bankruptcy(player_state: &mut PlayerState) {
    player_state.has_rolled_dice = false;
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;
    player_state.needs_special_space_action = false;
    player_state.pending_special_space_position = None;
    player_state.doubles_count = 0;
    player_state.in_jail = false;
    player_state.jail_turns = 0;
    player_state.position = 0; // Reset to GO
    player_state.festival_boost_turns = 0;
    player_state.card_drawn_at = None;
}

fn remove_player_from_game(game: &mut GameState, player_index: u8) -> Result<()> {
    // Remove player from the players array by setting to default
    if (player_index as usize) < game.players.len() {
        game.players[player_index as usize] = Pubkey::default();
    }

    // Decrease current players count
    game.current_players = game
        .current_players
        .checked_sub(1)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Adjust current_turn if necessary
    if game.current_turn >= game.current_players && game.current_players > 0 {
        game.current_turn = 0;
    }

    msg!(
        "Player at index {} removed from game. Remaining players: {}",
        player_index,
        game.current_players
    );

    Ok(())
}


// instructions/dice.rs
use crate::error::GameError;
use crate::{constants::*, xorshift64star, ID};
use crate::{force_end_turn, send_player_to_jail_and_end_turn, state::*};
use anchor_lang::prelude::*;
use ephemeral_vrf_sdk::anchor::vrf;
use ephemeral_vrf_sdk::instructions::create_request_randomness_ix;
use ephemeral_vrf_sdk::types::SerializableAccountMeta;

#[derive(Accounts)]
pub struct RollDice<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    /// CHECK: This is the recent blockhashes sysvar
    #[account(address = anchor_lang::solana_program::sysvar::recent_blockhashes::ID)]
    pub recent_blockhashes: UncheckedAccount<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn roll_dice_handler(ctx: Context<RollDice>, dice_roll: Option<[u8; 2]>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if player_state.has_rolled_dice {
        return Err(GameError::AlreadyRolledDice.into());
    }

    if player_state.in_jail {
        return handle_jail_dice_roll(game, player_state, clock, &ctx.accounts.recent_blockhashes);
    }

    // Generate secure random dice roll using recent blockhash
    let dice_roll = dice_roll.unwrap_or_else(|| {
        generate_dice_roll(&ctx.accounts.recent_blockhashes, clock.unix_timestamp).unwrap()
    });

    player_state.last_dice_roll = dice_roll;
    game.turn_started_at = clock.unix_timestamp;

    let is_doubles = dice_roll[0] == dice_roll[1];
    if is_doubles {
        player_state.doubles_count += 1;

        // Three doubles in a row sends player to jail
        if player_state.doubles_count >= 3 {
            send_player_to_jail_and_end_turn(game, player_state, clock);

            msg!(
                "Player {} rolled three doubles and goes to jail! Turn ended automatically.",
                player_pubkey
            );
            return Ok(());
        }

        msg!(
            "Player {} rolled doubles ({}, {})! Gets another turn.",
            player_pubkey,
            dice_roll[0],
            dice_roll[1]
        );
    } else {
        // Reset doubles count if not doubles
        player_state.doubles_count = 0;
        player_state.has_rolled_dice = true;
    }

    msg!(
        "Player {} rolled: {} and {}",
        player_pubkey,
        dice_roll[0],
        dice_roll[1]
    );

    let dice_sum = dice_roll[0] + dice_roll[1];
    let old_position = player_state.position;
    let new_position = (old_position + dice_sum) % BOARD_SIZE;

    // Check if player passed GO
    if new_position < old_position {
        player_state.cash_balance += GO_SALARY as u64;

        emit!(PlayerPassedGo {
            player: player_pubkey,
            game_id: game.game_id,
            salary_collected: GO_SALARY as u64,
            new_position,
            timestamp: clock.unix_timestamp,
        });

        msg!(
            "Player {} passed GO and collected ${}",
            player_pubkey,
            GO_SALARY
        );
    }

    player_state.position = new_position;

    handle_space_landing(game, player_state, new_position, clock)?;

    msg!(
        "Player {} rolled: {} and {} - moved from {} to {}",
        player_pubkey,
        dice_roll[0],
        dice_roll[1],
        old_position,
        new_position
    );

    Ok(())
}

fn generate_dice_roll(recent_blockhashes: &UncheckedAccount, timestamp: i64) -> Result<[u8; 2]> {
    // Get recent blockhash data for randomness
    let data = recent_blockhashes.try_borrow_data()?;

    // Create a more diverse seed by combining multiple entropy sources
    let mut seed = 0u64;

    // Use blockhash data (take 8 bytes and convert to u64)
    if data.len() >= 8 {
        seed ^= u64::from_le_bytes([
            data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7],
        ]);
    }

    // Mix in timestamp
    seed ^= timestamp as u64;

    // Mix in more blockhash data from different positions if available
    if data.len() >= 16 {
        seed ^= u64::from_le_bytes([
            data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15],
        ]);
    }

    // Ensure seed is never zero (xorshift doesn't work with 0)
    if seed == 0 {
        seed = 0x123456789ABCDEF0u64;
    }

    // Generate first random number for dice1
    let rand1 = xorshift64star(seed);
    // Generate second random number for dice2 (use first result as seed)
    let rand2 = xorshift64star(rand1);

    // Convert to dice values (1-6)
    let dice1 = ((rand1 % 6) + 1) as u8;
    let dice2 = ((rand2 % 6) + 1) as u8;

    Ok([dice1, dice2])
}

fn handle_jail_dice_roll(
    game: &mut GameState,
    player_state: &mut PlayerState,
    clock: &Sysvar<Clock>,
    recent_blockhashes: &UncheckedAccount,
) -> Result<()> {
    player_state.jail_turns += 1;

    let dice_roll = generate_dice_roll(recent_blockhashes, clock.unix_timestamp)?;
    player_state.last_dice_roll = dice_roll;
    player_state.has_rolled_dice = true;

    let is_doubles = dice_roll[0] == dice_roll[1];
    let mut player_escaped = false;

    if is_doubles {
        player_state.in_jail = false;
        player_state.jail_turns = 0;
        player_state.doubles_count = 0;
        player_escaped = true;

        msg!("Player rolled doubles and escaped jail!");
    } else if player_state.jail_turns >= MAX_JAIL_TURNS {
        // Must pay fine after max turns
        if player_state.cash_balance >= JAIL_FINE as u64 {
            player_state.cash_balance -= JAIL_FINE as u64;
            player_state.in_jail = false;
            player_state.jail_turns = 0;
            player_escaped = true;

            msg!("Player paid jail fine and is released!");
        } else {
            // Player can't afford jail fine - declare bankruptcy and end turn
            player_state.cash_balance = 0;
            player_state.is_bankrupt = true;
            player_state.in_jail = false; // Remove from jail since they're bankrupt
            player_state.jail_turns = 0;

            force_end_turn(game, player_state, clock);

            msg!("Player cannot afford jail fine and is declared bankrupt. Turn ended automatically.");
            return Ok(());
        }
    } else {
        msg!("Player remains in jail. Turn {}/3", player_state.jail_turns);
        force_end_turn(game, player_state, clock);
        return Ok(());
    }

    if player_escaped {
        // Calculate movement
        let dice_sum = dice_roll[0] + dice_roll[1];
        let old_position = player_state.position;
        let new_position = (old_position + dice_sum) % BOARD_SIZE;

        if new_position < old_position {
            player_state.cash_balance += GO_SALARY as u64;

            emit!(PlayerPassedGo {
                player: player_state.wallet,
                game_id: game.game_id,
                salary_collected: GO_SALARY as u64,
                new_position,
                timestamp: clock.unix_timestamp,
            });

            msg!("Player passed GO and collected ${}", GO_SALARY);
        }

        player_state.position = new_position;

        handle_space_landing(game, player_state, new_position, clock)?;

        msg!(
            "Player escaped jail and moved from {} to {}",
            old_position,
            new_position
        );
    }

    game.turn_started_at = clock.unix_timestamp;
    Ok(())
}

fn handle_space_landing(
    game: &mut GameState,
    player_state: &mut PlayerState,
    position: u8,
    clock: &Sysvar<Clock>,
) -> Result<()> {
    let property_data = get_property_data(position);

    match property_data {
        Some(data) => {
            match data.property_type {
                0 | 1 | 2 => {
                    if player_state.properties_owned.contains(&position) {
                        return Ok(());
                    }

                    player_state.needs_property_action = true;
                    player_state.pending_property_position = Some(position);
                    msg!("Player landed on unowned property at position {}", position);
                }
                3 => {
                    // Special space
                    handle_special_space(game, player_state, position, clock)?;
                }
                _ => {}
            }
        }
        None => return Err(GameError::InvalidBoardPosition.into()),
    }

    Ok(())
}

fn handle_special_space(
    game: &mut GameState,
    player_state: &mut PlayerState,
    position: u8,
    clock: &Sysvar<Clock>,
) -> Result<()> {
    match position {
        GO_POSITION => {
            // Already handled in movement
        }
        JAIL_POSITION => {
            // Just visiting jail, no action needed
        }
        GO_TO_JAIL_POSITION => {
            send_player_to_jail_and_end_turn(game, player_state, clock);
        }
        MEV_TAX_POSITION | PRIORITY_FEE_TAX_POSITION => {
            player_state.needs_special_space_action = true;
            player_state.pending_special_space_position = Some(position);
        }
        pos if CHANCE_POSITIONS.contains(&pos) => {
            player_state.needs_chance_card = true;
        }
        pos if COMMUNITY_CHEST_POSITIONS.contains(&pos) => {
            player_state.needs_community_chest_card = true;
        }
        FREE_PARKING_POSITION => {
            // Free parking - no action
        }
        _ => {}
    }
    Ok(())
}

#[vrf]
#[derive(Accounts)]
pub struct RollDiceVrf<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,

    /// CHECK: The oracle queue
    #[account(mut, address = ephemeral_vrf_sdk::consts::DEFAULT_EPHEMERAL_QUEUE)]
    pub oracle_queue: AccountInfo<'info>,
}

pub fn roll_dice_vrf_handler(
    ctx: Context<RollDiceVrf>,
    client_seed: u8,
    dice_roll: Option<[u8; 2]>,
) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if player_state.has_rolled_dice {
        return Err(GameError::AlreadyRolledDice.into());
    }

    if dice_roll.is_none() {
        msg!("Requesting randomness...");

        let ix = create_request_randomness_ix(
            ephemeral_vrf_sdk::instructions::RequestRandomnessParams {
                payer: ctx.accounts.player.key(),
                oracle_queue: ctx.accounts.oracle_queue.key(),
                callback_program_id: ID,
                callback_discriminator: crate::instruction::CallbackRollDice::DISCRIMINATOR
                    .to_vec(),
                caller_seed: [client_seed; 32],
                accounts_metas: Some(vec![
                    // game
                    SerializableAccountMeta {
                        pubkey: ctx.accounts.game.key(),
                        is_signer: false,
                        is_writable: true,
                    },
                    // player state
                    SerializableAccountMeta {
                        pubkey: ctx.accounts.player_state.key(),
                        is_signer: false,
                        is_writable: true,
                    },
                    // clock
                    SerializableAccountMeta {
                        pubkey: ctx.accounts.clock.key(),
                        is_signer: false,
                        is_writable: false,
                    },
                ]),
                ..Default::default()
            },
        );

        ctx.accounts
            .invoke_signed_vrf(&ctx.accounts.player.to_account_info(), &ix)?;
    } else {
        // for test - handle the dice roll directly
        let dice_roll = dice_roll.unwrap();

        player_state.last_dice_roll = dice_roll;
        game.turn_started_at = clock.unix_timestamp;

        let is_doubles = dice_roll[0] == dice_roll[1];
        if is_doubles {
            player_state.doubles_count += 1;

            // Three doubles in a row sends player to jail
            if player_state.doubles_count >= 3 {
                send_player_to_jail_and_end_turn(game, player_state, clock);

                msg!(
                    "Player {} rolled three doubles and goes to jail! Turn ended automatically.",
                    player_pubkey
                );
                return Ok(());
            }

            msg!(
                "Player {} rolled doubles ({}, {})! Gets another turn.",
                player_pubkey,
                dice_roll[0],
                dice_roll[1]
            );
        } else {
            // Reset doubles count if not doubles
            player_state.doubles_count = 0;
            player_state.has_rolled_dice = true;
        }

        msg!(
            "Player {} rolled: {} and {}",
            player_pubkey,
            dice_roll[0],
            dice_roll[1]
        );

        let dice_sum = dice_roll[0] + dice_roll[1];
        let old_position = player_state.position;
        let new_position = (old_position + dice_sum) % BOARD_SIZE;

        // Check if player passed GO
        if new_position < old_position {
            player_state.cash_balance += GO_SALARY as u64;

            emit!(PlayerPassedGo {
                player: player_pubkey,
                game_id: game.game_id,
                salary_collected: GO_SALARY as u64,
                new_position,
                timestamp: clock.unix_timestamp,
            });

            msg!(
                "Player {} passed GO and collected ${}",
                player_pubkey,
                GO_SALARY
            );
        }

        player_state.position = new_position;

        handle_space_landing(game, player_state, new_position, clock)?;

        msg!(
            "Player {} rolled: {} and {} - moved from {} to {}",
            player_pubkey,
            dice_roll[0],
            dice_roll[1],
            old_position,
            new_position
        );
    }

    Ok(())
}

#[derive(Accounts)]
pub struct CallbackRollDiceCtx<'info> {
    /// This check ensure that the vrf_program_identity (which is a PDA) is a singer
    /// enforcing the callback is executed by the VRF program trough CPI
    #[account(address = ephemeral_vrf_sdk::consts::VRF_PROGRAM_IDENTITY)]
    pub vrf_program_identity: Signer<'info>,

    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", player_state.game.as_ref(), player_state.wallet.as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn callback_roll_dice(ctx: Context<CallbackRollDiceCtx>, randomness: [u8; 32]) -> Result<()> {
    let roll_1 = ephemeral_vrf_sdk::rnd::random_u8_with_range(&randomness, 1, 6);
    let roll_2 = ephemeral_vrf_sdk::rnd::random_u8_with_range(&randomness, 1, 6);
    msg!("Roll: {} - {}", roll_1, roll_2);

    let dice_roll = [roll_1, roll_2];

    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let clock = &ctx.accounts.clock;
    let player_pubkey = player_state.wallet;

    // Handle jail logic first if player is in jail
    if player_state.in_jail {
        return handle_jail_dice_roll_vrf(game, player_state, clock, dice_roll);
    }

    player_state.last_dice_roll = dice_roll;
    game.turn_started_at = clock.unix_timestamp;

    let is_doubles = dice_roll[0] == dice_roll[1];
    if is_doubles {
        player_state.doubles_count += 1;

        // Three doubles in a row sends player to jail
        if player_state.doubles_count >= 3 {
            send_player_to_jail_and_end_turn(game, player_state, clock);

            msg!(
                "Player {} rolled three doubles and goes to jail! Turn ended automatically.",
                player_pubkey
            );
            return Ok(());
        }

        msg!(
            "Player {} rolled doubles ({}, {})! Gets another turn.",
            player_pubkey,
            dice_roll[0],
            dice_roll[1]
        );
    } else {
        // Reset doubles count if not doubles
        player_state.doubles_count = 0;
        player_state.has_rolled_dice = true;
    }

    msg!(
        "Player {} rolled: {} and {}",
        player_pubkey,
        dice_roll[0],
        dice_roll[1]
    );

    let dice_sum = dice_roll[0] + dice_roll[1];
    let old_position = player_state.position;
    let new_position = (old_position + dice_sum) % BOARD_SIZE;

    // Check if player passed GO
    if new_position < old_position {
        player_state.cash_balance += GO_SALARY as u64;

        emit!(PlayerPassedGo {
            player: player_pubkey,
            game_id: game.game_id,
            salary_collected: GO_SALARY as u64,
            new_position,
            timestamp: clock.unix_timestamp,
        });

        msg!(
            "Player {} passed GO and collected ${}",
            player_pubkey,
            GO_SALARY
        );
    }

    player_state.position = new_position;

    handle_space_landing(game, player_state, new_position, clock)?;

    msg!(
        "Player {} rolled: {} and {} - moved from {} to {}",
        player_pubkey,
        dice_roll[0],
        dice_roll[1],
        old_position,
        new_position
    );

    Ok(())
}

fn handle_jail_dice_roll_vrf(
    game: &mut GameState,
    player_state: &mut PlayerState,
    clock: &Sysvar<Clock>,
    dice_roll: [u8; 2],
) -> Result<()> {
    player_state.jail_turns += 1;
    player_state.last_dice_roll = dice_roll;
    player_state.has_rolled_dice = true;

    let is_doubles = dice_roll[0] == dice_roll[1];
    let mut player_escaped = false;

    if is_doubles {
        player_state.in_jail = false;
        player_state.jail_turns = 0;
        player_state.doubles_count = 0;
        player_escaped = true;

        msg!("Player rolled doubles and escaped jail!");
    } else if player_state.jail_turns >= MAX_JAIL_TURNS {
        // Must pay fine after max turns
        if player_state.cash_balance >= JAIL_FINE as u64 {
            player_state.cash_balance -= JAIL_FINE as u64;
            player_state.in_jail = false;
            player_state.jail_turns = 0;
            player_escaped = true;

            msg!("Player paid jail fine and is released!");
        } else {
            // Player can't afford jail fine - declare bankruptcy and end turn
            player_state.cash_balance = 0;
            player_state.is_bankrupt = true;
            player_state.in_jail = false; // Remove from jail since they're bankrupt
            player_state.jail_turns = 0;

            force_end_turn(game, player_state, clock);

            msg!("Player cannot afford jail fine and is declared bankrupt. Turn ended automatically.");
            return Ok(());
        }
    } else {
        msg!("Player remains in jail. Turn {}/3", player_state.jail_turns);
        force_end_turn(game, player_state, clock);
        return Ok(());
    }

    if player_escaped {
        // Calculate movement
        let dice_sum = dice_roll[0] + dice_roll[1];
        let old_position = player_state.position;
        let new_position = (old_position + dice_sum) % BOARD_SIZE;

        if new_position < old_position {
            player_state.cash_balance += GO_SALARY as u64;

            emit!(PlayerPassedGo {
                player: player_state.wallet,
                game_id: game.game_id,
                salary_collected: GO_SALARY as u64,
                new_position,
                timestamp: clock.unix_timestamp,
            });

            msg!("Player passed GO and collected ${}", GO_SALARY);
        }

        player_state.position = new_position;

        handle_space_landing(game, player_state, new_position, clock)?;

        msg!(
            "Player escaped jail and moved from {} to {}",
            old_position,
            new_position
        );
    }

    game.turn_started_at = clock.unix_timestamp;
    Ok(())
}


// instructions/end_game.rs
use crate::error::GameError;
use crate::state::*;
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct EndGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn end_game_handler(ctx: Context<EndGame>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let clock = &ctx.accounts.clock;

    // Check if game should end (only one player remaining)
    let active_players = count_active_players(game);
    
    if active_players <= 1 {
        // End the game
        game.game_status = GameStatus::Finished;
        
        if active_players == 1 {
            // Find the remaining active player and declare them winner
            if let Some(winner_pubkey) = find_last_active_player(game) {
                game.winner = Some(winner_pubkey);
                msg!("Game ended. Winner: {}", winner_pubkey);
                
                emit!(GameEnded {
                    game_id: game.game_id,
                    winner: Some(winner_pubkey),
                    ended_at: clock.unix_timestamp,
                });
            }
        } else {
            // No players remaining (shouldn't happen in normal gameplay)
            msg!("Game ended with no remaining players");
            
            emit!(GameEnded {
                game_id: game.game_id,
                winner: None,
                ended_at: clock.unix_timestamp,
            });
        }
        
        msg!("Game {} has ended", game.game_id);
    } else {
        return Err(GameError::GameCannotEnd.into());
    }

    Ok(())
}

/// Count the number of active (non-bankrupt, non-default) players
fn count_active_players(game: &GameState) -> u8 {
    game.players
        .iter()
        .filter(|&&player| player != Pubkey::default())
        .count() as u8
}

/// Find the last remaining active player
fn find_last_active_player(game: &GameState) -> Option<Pubkey> {
    game.players
        .iter()
        .find(|&&player| player != Pubkey::default())
        .copied()
}

/// Check if the game should end based on current state
pub fn check_game_end_condition(game: &GameState) -> bool {
    count_active_players(game) <= 1
}

// instructions/end_turn.rs
use crate::error::GameError;
use crate::state::*;
use anchor_lang::prelude::*;

#[derive(Accounts)]
pub struct EndTurn<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn end_turn_handler(ctx: Context<EndTurn>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Find player index in game.players vector
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    // Verify it's the current player's turn
    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Verify player has rolled dice
    if !player_state.has_rolled_dice {
        return Err(GameError::HasNotRolledDice.into());
    }

    // Check if player has pending actions that must be completed
    if player_state.needs_property_action {
        return Err(GameError::MustHandleSpecialSpace.into());
    }

    if player_state.needs_chance_card {
        return Err(GameError::MustHandleSpecialSpace.into());
    }

    if player_state.needs_community_chest_card {
        return Err(GameError::MustHandleSpecialSpace.into());
    }

    if player_state.needs_bankruptcy_check {
        return Err(GameError::MustDeclareBankruptcy.into());
    }

    // Reset turn-specific flags
    player_state.has_rolled_dice = false;
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;
    player_state.needs_chance_card = false;
    player_state.needs_community_chest_card = false;
    player_state.needs_bankruptcy_check = false;
    // Advance to next player
    player_state.doubles_count = 0; // Reset doubles count
    let next_turn = (game.current_turn + 1) % game.current_players;
    game.current_turn = next_turn;
    game.turn_started_at = clock.unix_timestamp;

    msg!("Turn ended. Next turn: Player {}", next_turn);

    Ok(())
}


// instructions/initialize.rs
use crate::constants::*;
use crate::error::GameError;
use crate::state::*;
use anchor_lang::prelude::*;
use anchor_spl::{
    associated_token::AssociatedToken,
    token_interface::{transfer_checked, Mint, TokenAccount, TokenInterface, TransferChecked},
};
use ephemeral_rollups_sdk::anchor::{commit, delegate};
use ephemeral_rollups_sdk::cpi::DelegateConfig;
use ephemeral_rollups_sdk::ephem::commit_and_undelegate_accounts;

#[derive(Accounts)]
pub struct InitializeGame<'info> {
    #[account(
        init,
        payer = creator,
        space = 8 + GameState::INIT_SPACE,
        seeds = [
            b"game",
            config.id.as_ref(),
            &config.next_game_id.to_le_bytes()
            ],
        bump
    )]
    pub game: Account<'info, GameState>,

    #[account(
        init,
        payer = creator,
        space = 8 + PlayerState::INIT_SPACE + 64,
        seeds = [b"player", game.key().as_ref(), creator.key().as_ref()],
        bump,
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub creator: Signer<'info>,

    #[account(
        mut,
        seeds = [b"platform", config.id.as_ref()],
        bump = config.bump,
    )]
    pub config: Account<'info, PlatformConfig>,

    /// CHECK: game authority PDA
    pub game_authority: Option<UncheckedAccount<'info>>,

    #[account(
        mint::token_program = token_program,
    )]
    pub token_mint: Option<InterfaceAccount<'info, Mint>>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = creator,
        associated_token::token_program = token_program
    )]
    pub creator_token_account: Option<InterfaceAccount<'info, TokenAccount>>,

    #[account(
        init,
        payer = creator,
        associated_token::mint = token_mint,
        associated_token::authority = game_authority,
        associated_token::token_program = token_program
    )]
    pub token_vault: Option<InterfaceAccount<'info, TokenAccount>>,

    pub token_program: Option<Interface<'info, TokenInterface>>,
    pub associated_token_program: Option<Program<'info, AssociatedToken>>,

    pub system_program: Program<'info, System>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn initialize_game_handler(ctx: Context<InitializeGame>, entry_fee: u64) -> Result<()> {
    let config = &mut ctx.accounts.config;
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let clock = &ctx.accounts.clock;

    if entry_fee > 0 {
        require!(
            ctx.accounts.game_authority.is_some()
                && ctx.accounts.token_mint.is_some()
                && ctx.accounts.creator_token_account.is_some()
                && ctx.accounts.token_vault.is_some()
                && ctx.accounts.token_program.is_some()
                && ctx.accounts.associated_token_program.is_some(),
            GameError::MissingTokenAccounts
        );

        let token_mint = ctx.accounts.token_mint.as_ref().unwrap();
        let creator_token_account = ctx.accounts.creator_token_account.as_ref().unwrap();
        let token_vault = ctx.accounts.token_vault.as_ref().unwrap();
        let game_authority = ctx.accounts.game_authority.as_ref().unwrap();

        // Validate game authority PDA
        let (expected_game_authority, _) =
            Pubkey::find_program_address(&[GAME_AUTHORITY_SEED], ctx.program_id);

        require!(
            game_authority.key() == expected_game_authority,
            GameError::InvalidGameAuthority
        );

        require!(
            creator_token_account.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            creator_token_account.owner == ctx.accounts.creator.key(),
            GameError::InvalidTokenAccount
        );

        require!(
            token_vault.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            token_vault.owner == game_authority.key(),
            GameError::InvalidTokenAccount
        );

        // Transfer entry fee from creator to vault
        let transfer_accounts = TransferChecked {
            from: creator_token_account.to_account_info(),
            mint: token_mint.to_account_info(),
            to: token_vault.to_account_info(),
            authority: ctx.accounts.creator.to_account_info(),
        };

        let transfer_ctx = CpiContext::new(
            ctx.accounts
                .token_program
                .as_ref()
                .unwrap()
                .to_account_info(),
            transfer_accounts,
        );

        transfer_checked(transfer_ctx, entry_fee, token_mint.decimals)?;

        game.token_mint = Some(token_mint.key());
        game.token_vault = Some(token_vault.key());
        game.total_prize_pool = entry_fee;
    } else {
        game.token_mint = None;
        game.token_vault = None;
        game.total_prize_pool = 0;
    }

    let game_id = config.next_game_id;
    config.next_game_id += 1;
    config.total_games_created += 1;

    // Initialize game state
    game.game_id = game_id;
    game.config_id = config.id;
    game.creator = ctx.accounts.creator.key();
    game.bump = ctx.bumps.game;
    game.game_status = GameStatus::WaitingForPlayers;
    game.current_turn = 0;
    game.current_players = 0; // Initial player count
    game.max_players = MAX_PLAYERS;
    game.players = vec![];
    game.houses_remaining = TOTAL_HOUSES;
    game.hotels_remaining = TOTAL_HOTELS;
    game.created_at = clock.unix_timestamp;
    game.bank_balance = 1_000_000; // Initial bank balance
    game.time_limit = None;
    game.winner = None;
    game.turn_started_at = clock.unix_timestamp;
    game.active_trades = vec![];
    game.next_trade_id = 0;
    game.entry_fee = entry_fee;

    // Initialize player state
    player_state.initialize_player_state(ctx.accounts.creator.key(), game.key(), clock);

    // Add player to game
    game.players.push(player_state.wallet);
    game.current_players = game.players.len() as u8;

    msg!(
        "Game initialized by creator: {}",
        ctx.accounts.creator.key()
    );
    msg!("Game account: {}", game.key());
    msg!("Game created at timestamp: {}", game.created_at);

    Ok(())
}

#[derive(Accounts)]
pub struct JoinGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::WaitingForPlayers @ GameError::GameNotInProgress,
        constraint = game.current_players < MAX_PLAYERS @ GameError::MaxPlayersReached
    )]
    pub game: Account<'info, GameState>,

    #[account(
        init,
        payer = player,
        space = 8 + PlayerState::INIT_SPACE + 64,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    /// CHECK: game authority PDA - only required for paid games
    pub game_authority: Option<UncheckedAccount<'info>>,

    #[account(
        mint::token_program = token_program,
    )]
    pub token_mint: Option<InterfaceAccount<'info, Mint>>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = player,
        associated_token::token_program = token_program
    )]
    pub player_token_account: Option<InterfaceAccount<'info, TokenAccount>>,

    #[account(
        mut,
        associated_token::mint = token_mint,
        associated_token::authority = game_authority,
        associated_token::token_program = token_program
    )]
    pub token_vault: Option<InterfaceAccount<'info, TokenAccount>>,

    pub token_program: Option<Interface<'info, TokenInterface>>,
    pub associated_token_program: Option<Program<'info, AssociatedToken>>,

    pub system_program: Program<'info, System>,
    pub clock: Sysvar<'info, Clock>,
}

pub fn join_game_handler(ctx: Context<JoinGame>) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    msg!("Join game: {}", game.key());
    msg!("Player: {}", player_pubkey);

    // Check if player already exists in game
    for existing_player in &game.players {
        msg!("Existing player: {}", existing_player);
        if *existing_player == player_pubkey {
            return Err(GameError::PlayerAlreadyExists.into());
        }
    }

    // Handle entry fee payment if game has entry fee
    if game.entry_fee > 0 {
        require!(
            ctx.accounts.game_authority.is_some()
                && ctx.accounts.token_mint.is_some()
                && ctx.accounts.player_token_account.is_some()
                && ctx.accounts.token_vault.is_some()
                && ctx.accounts.token_program.is_some(),
            GameError::MissingTokenAccounts
        );

        let token_mint = ctx.accounts.token_mint.as_ref().unwrap();
        let player_token_account = ctx.accounts.player_token_account.as_ref().unwrap();
        let token_vault = ctx.accounts.token_vault.as_ref().unwrap();
        let game_authority = ctx.accounts.game_authority.as_ref().unwrap();

        // Validate game authority PDA
        let (expected_game_authority, _) =
            Pubkey::find_program_address(&[GAME_AUTHORITY_SEED], ctx.program_id);

        require!(
            game_authority.key() == expected_game_authority,
            GameError::InvalidGameAuthority
        );

        // Validate token accounts
        require!(
            player_token_account.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            player_token_account.owner == ctx.accounts.player.key(),
            GameError::InvalidTokenAccount
        );

        require!(
            token_vault.mint == token_mint.key(),
            GameError::InvalidTokenAccount
        );
        require!(
            token_vault.owner == game_authority.key(),
            GameError::InvalidTokenAccount
        );

        // Validate that the token accounts match the game's configuration
        require!(
            Some(token_mint.key()) == game.token_mint,
            GameError::InvalidTokenAccount
        );
        require!(
            Some(token_vault.key()) == game.token_vault,
            GameError::InvalidTokenAccount
        );

        // Transfer entry fee from player to vault
        let transfer_accounts = TransferChecked {
            from: player_token_account.to_account_info(),
            mint: token_mint.to_account_info(),
            to: token_vault.to_account_info(),
            authority: ctx.accounts.player.to_account_info(),
        };

        let transfer_ctx = CpiContext::new(
            ctx.accounts
                .token_program
                .as_ref()
                .unwrap()
                .to_account_info(),
            transfer_accounts,
        );

        transfer_checked(transfer_ctx, game.entry_fee, token_mint.decimals)?;

        // Update total prize pool
        game.total_prize_pool = game
            .total_prize_pool
            .checked_add(game.entry_fee)
            .ok_or(GameError::ArithmeticOverflow)?;

        msg!(
            "Entry fee {} paid by player {}",
            game.entry_fee,
            player_pubkey
        );
        msg!("Total prize pool: {}", game.total_prize_pool);
    } 
    // else {
    //     // For free games, ensure no token accounts are provided
    //     require!(
    //         ctx.accounts.game_authority.is_none()
    //             && ctx.accounts.token_mint.is_none()
    //             && ctx.accounts.player_token_account.is_none()
    //             && ctx.accounts.token_vault.is_none()
    //             && ctx.accounts.token_program.is_none(),
    //         GameError::UnexpectedTokenAccounts
    //     );
    // }

    // Initialize player state
    player_state.initialize_player_state(player_pubkey, game.key(), clock);

    // Add player to game
    game.players.push(player_pubkey);
    game.current_players = game.players.len() as u8;

    msg!(
        "Player {} joined game. Total players: {}",
        player_pubkey,
        game.current_players
    );

    // Auto-start game if we have minimum players and all slots filled
    if game.current_players >= MIN_PLAYERS {
        msg!("Minimum players reached. Game can be started.");
    }

    Ok(())
}

#[delegate]
#[derive(Accounts)]
pub struct StartGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump,
        constraint = game.game_status == GameStatus::WaitingForPlayers @ GameError::GameNotInProgress,
        constraint = game.current_players >= MIN_PLAYERS @ GameError::MinPlayersNotMet,
        constraint = authority.key() == game.creator @ GameError::Unauthorized,
        del
    )]
    pub game: Account<'info, GameState>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn start_game_handler<'c: 'info, 'info>(
    ctx: Context<'_, '_, 'c, 'info, StartGame<'info>>,
) -> Result<()> {
    {
        let game = &mut ctx.accounts.game;
        let clock = &ctx.accounts.clock;

        // Change game status to in progress
        game.game_status = GameStatus::InProgress;
        game.current_turn = 0; // First player starts
        game.turn_started_at = clock.unix_timestamp;

        msg!("Game started! Player {} goes first.", game.players[0]);
        msg!("Total players in game: {}", game.current_players);
    }

    {
        msg!("Start delegate");

        let authority = &ctx.accounts.authority;
        let owner_program = &ctx.accounts.owner_program;
        let delegation_program = &ctx.accounts.delegation_program;
        let game = &ctx.accounts.game;
        let game_key = game.key();
        let players = &game.players;

        game.exit(&crate::ID)?;
        ctx.accounts.delegate_game(
            &ctx.accounts.authority,
            &[
                b"game",
                game.config_id.as_ref(),
                &game.game_id.to_le_bytes(),
            ],
            DelegateConfig {
                commit_frequency_ms: 30_000,
                validator: Some(pubkey!("MAS1Dt9qreoRMQ14YQuhg8UTZMMzDdKhmkZMECCzk57")),
            },
        )?;

        let remaining_accounts_iter = &mut ctx.remaining_accounts.iter();

        // delegate player accounts
        for player_pubkey in players.iter() {
            let player_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;
            player_account.exit(&crate::ID)?;

            let player_buffer_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;

            let player_delegation_record_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;

            let player_delegation_metadata_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;

            let del_accounts = ephemeral_rollups_sdk::cpi::DelegateAccounts {
                payer: &authority.to_account_info(),
                pda: &player_account.to_account_info(),
                owner_program: &owner_program.to_account_info(),
                buffer: player_buffer_account,
                delegation_record: player_delegation_record_account,
                delegation_metadata: player_delegation_metadata_account,
                delegation_program: &delegation_program.to_account_info(),
                system_program: &ctx.accounts.system_program.to_account_info(),
            };

            let seeds = &[b"player", game_key.as_ref(), player_pubkey.as_ref()];

            let config = DelegateConfig {
                commit_frequency_ms: 30_000,
                validator: Some(pubkey!("MAS1Dt9qreoRMQ14YQuhg8UTZMMzDdKhmkZMECCzk57")),
            };

            ephemeral_rollups_sdk::cpi::delegate_account(del_accounts, seeds, config)?;

            msg!("Player {} delegated", player_pubkey);
        }
    }

    msg!("Game started!");

    Ok(())
}

#[commit]
#[derive(Accounts)]
pub struct UndelegateGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress,
        constraint = game.current_players >= MIN_PLAYERS @ GameError::MinPlayersNotMet,
        constraint = authority.key() == game.creator @ GameError::Unauthorized,
    )]
    pub game: Account<'info, GameState>,

    #[account(mut)]
    pub authority: Signer<'info>,
}

pub fn undelegate_game_handler<'c: 'info, 'info>(
    ctx: Context<'_, '_, 'c, 'info, UndelegateGame<'info>>,
) -> Result<()> {
    {
        let game = &mut ctx.accounts.game;
        // Change game status to in progress
        game.game_status = GameStatus::Finished;

        msg!("Game closed!");
    }

    {
        msg!("Start undelegate");

        let game = &ctx.accounts.game;
        let players = &game.players;

        game.exit(&crate::ID)?;
        commit_and_undelegate_accounts(
            &ctx.accounts.authority,
            vec![&game.to_account_info()],
            &ctx.accounts.magic_context,
            &ctx.accounts.magic_program,
        )?;

        let remaining_accounts_iter = &mut ctx.remaining_accounts.iter();

        // delegate player accounts
        for player_pubkey in players.iter() {
            let player_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;
            player_account.exit(&crate::ID)?;

            commit_and_undelegate_accounts(
                &ctx.accounts.authority,
                vec![&player_account.to_account_info()],
                &ctx.accounts.magic_context,
                &ctx.accounts.magic_program,
            )?;

            msg!("Player {} undelegated", player_pubkey);
        }
    }

    msg!("Game undelegated!");

    Ok(())
}

#[derive(Accounts)]
pub struct CloseGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress,
        constraint = game.current_players >= MIN_PLAYERS @ GameError::MinPlayersNotMet,
        constraint = authority.key() == game.creator @ GameError::Unauthorized,
        close = authority
    )]
    pub game: Account<'info, GameState>,

    #[account(mut)]
    pub authority: Signer<'info>,
}

pub fn close_game_handler<'c: 'info, 'info>(
    ctx: Context<'_, '_, 'c, 'info, CloseGame<'info>>,
) -> Result<()> {
    {
        msg!("Start close_game_handler");

        let remaining_accounts_iter = &mut ctx.remaining_accounts.iter();

        let game = &ctx.accounts.game;
        let authority = &ctx.accounts.authority;
        let players = &game.players;
        // delegate player accounts
        for player_pubkey in players.iter() {
            let player_account = remaining_accounts_iter
                .next()
                .ok_or(GameError::InvalidAccount)?;

            let pda_balance_before = player_account.get_lamports();

            msg!(
                "Player {} balance before: {}",
                player_pubkey,
                pda_balance_before
            );

            player_account.sub_lamports(pda_balance_before)?;
            authority.add_lamports(pda_balance_before)?;

            msg!("Player {} close", player_pubkey);
        }
    }

    msg!("Game closed!");

    Ok(())
}

#[derive(Accounts)]
pub struct ResetGame<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress,
        constraint = game.current_players >= MIN_PLAYERS @ GameError::MinPlayersNotMet,
        constraint = authority.key() == game.creator @ GameError::Unauthorized,
    )]
    pub game: Account<'info, GameState>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn reset_game_handler<'c: 'info, 'info>(
    ctx: Context<'_, '_, 'c, 'info, ResetGame<'info>>,
) -> Result<()> {
    {
        let game = &mut ctx.accounts.game;
        let clock = &ctx.accounts.clock;

        // Change game status to in progress
        game.game_status = GameStatus::InProgress;
        game.current_turn = 0; // First player starts
        game.houses_remaining = TOTAL_HOUSES; // First player starts
        game.hotels_remaining = TOTAL_HOTELS; // First player starts
        game.bank_balance = 1_000_000; // First player starts
        game.winner = None; // First player starts
        game.active_trades = vec![]; // First player starts
        game.next_trade_id = 0; // First player starts
        game.turn_started_at = clock.unix_timestamp;
    }

    {
        let remaining_accounts_iter = &mut ctx.remaining_accounts.iter();
        let game = &ctx.accounts.game;
        let clock = &ctx.accounts.clock;

        for _player_pubkey in game.players.iter() {
            let data_account_info = next_account_info(remaining_accounts_iter)?;
            require_eq!(data_account_info.is_writable, true);
            msg!(
                "Player data account: {} and {}",
                data_account_info.key(),
                _player_pubkey
            );

            let mut player_account = Account::<PlayerState>::try_from(data_account_info)?;

            player_account.cash_balance = STARTING_MONEY as u64;
            player_account.position = 0;
            player_account.in_jail = false;
            player_account.jail_turns = 0;
            player_account.doubles_count = 0;
            player_account.is_bankrupt = false;
            player_account.properties_owned = Vec::new();
            player_account.get_out_of_jail_cards = 0;
            player_account.net_worth = STARTING_MONEY as u64;
            player_account.last_rent_collected = clock.unix_timestamp;
            player_account.festival_boost_turns = 0;
            player_account.has_rolled_dice = false;
            player_account.last_dice_roll = [0, 0];
            player_account.needs_property_action = false;
            player_account.pending_property_position = None;
            player_account.needs_chance_card = false;
            player_account.needs_community_chest_card = false;
            player_account.needs_bankruptcy_check = false;
            player_account.needs_special_space_action = false;
            player_account.pending_special_space_position = None;
            player_account.card_drawn_at = None;

            player_account.exit(&crate::ID)?;

            msg!("Player {} reset", _player_pubkey);
        }
    }

    msg!("Game resetted!");

    Ok(())
}


// instructions/mod.rs
// pub mod auction;
pub mod bankruptcy;
pub mod dice;
pub mod end_game;
pub mod end_turn;
pub mod initialize;
pub mod jail;
pub mod property;
pub mod special_spaces;
pub mod trading;
pub mod platform;

// pub use auction::*;
pub use bankruptcy::*;
pub use dice::*;
pub use end_game::*;
pub use end_turn::*;
pub use initialize::*;
pub use jail::*;
pub use property::*;
pub use special_spaces::*;
pub use trading::*;
pub use platform::*;


// instructions/property.rs
use crate::constants::*;
use crate::error::GameError;
use crate::state::*;
use crate::utils::*;
use anchor_lang::prelude::*;
use ephemeral_rollups_sdk::cpi::DelegateConfig;

#[derive(Accounts)]
#[instruction(game_key: Pubkey, position: u8)]
pub struct InitProperty<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + PropertyState::INIT_SPACE,
        seeds = [b"property", game_key.as_ref(), position.to_le_bytes().as_ref()],
        bump
    )]
    pub property_state: Account<'info, PropertyState>,

    /// CHECK: Validate by CPI
    #[account(mut)]
    pub property_buffer_account: UncheckedAccount<'info>,

    /// CHECK: Validate by CPI
    #[account(mut)]
    pub property_delegation_record_account: UncheckedAccount<'info>,

    /// CHECK: Validate by CPI
    #[account(mut)]
    pub property_delegation_metadata_account: UncheckedAccount<'info>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub system_program: Program<'info, System>,

    /// CHECK: Validate by CPI
    pub delegation_program: UncheckedAccount<'info>,

    /// CHECK: Validate by CPI
    pub owner_program: UncheckedAccount<'info>,
}

pub fn init_property_handler(
    ctx: Context<InitProperty>,
    game_key: Pubkey,
    position: u8,
) -> Result<()> {
    msg!("Init property {} for game {}", position, game_key);
    msg!("property: {}", ctx.accounts.property_state.key());

    {
        let property = &mut ctx.accounts.property_state;
        property.position = position;
        property.game = game_key;
        property.init = false;
    }

    {
        let property = &ctx.accounts.property_state;
        property.exit(&crate::ID)?;

        let del_accounts = ephemeral_rollups_sdk::cpi::DelegateAccounts {
            payer: &ctx.accounts.authority.to_account_info(),
            pda: &property.to_account_info(),
            owner_program: &ctx.accounts.owner_program.to_account_info(),
            buffer: &ctx.accounts.property_buffer_account.to_account_info(),
            delegation_record: &ctx
                .accounts
                .property_delegation_record_account
                .to_account_info(),
            delegation_metadata: &ctx
                .accounts
                .property_delegation_metadata_account
                .to_account_info(),
            delegation_program: &ctx.accounts.delegation_program.to_account_info(),
            system_program: &ctx.accounts.system_program.to_account_info(),
        };

        let pos_seed = property.position.to_le_bytes();
        let seeds = &[b"property", property.game.as_ref(), pos_seed.as_ref()];

        msg!("seeds: {:?}", seeds);

        let config = DelegateConfig {
            commit_frequency_ms: 30_000,
            validator: Some(pubkey!("MAS1Dt9qreoRMQ14YQuhg8UTZMMzDdKhmkZMECCzk57")),
        };

        ephemeral_rollups_sdk::cpi::delegate_account(del_accounts, seeds, config)?;

        msg!("Property {} delegated");
    }

    Ok(())
}

#[derive(Accounts)]
pub struct BuyProperty<'info> {
    #[account(
        mut,
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", property_state.game.as_ref(), property_state.position.to_le_bytes().as_ref()],
        bump
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub system_program: Program<'info, System>,
    pub clock: Sysvar<'info, Clock>,
}

pub fn buy_property_handler(ctx: Context<BuyProperty>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if player_state.position != position {
        return Err(GameError::InvalidPropertyPosition.into());
    }

    if !is_property_purchasable(position) {
        return Err(GameError::PropertyNotPurchasable.into());
    }

    let property_data = get_property_data(position).ok_or(GameError::InvalidPropertyPosition)?;

    // Check if property is already owned
    if property_state.owner.is_some() {
        return Err(GameError::PropertyAlreadyOwned.into());
    }

    if player_state.cash_balance < property_data.price {
        return Err(GameError::InsufficientFunds.into());
    }

    // Initialize property state if needed
    if !property_state.init {
        // Not initialized
        property_state.init = true;
        property_state.price = property_data.price as u16;
        property_state.color_group = match property_data.color_group {
            1 => ColorGroup::Brown,
            2 => ColorGroup::LightBlue,
            3 => ColorGroup::Pink,
            4 => ColorGroup::Orange,
            5 => ColorGroup::Red,
            6 => ColorGroup::Yellow,
            7 => ColorGroup::Green,
            8 => ColorGroup::DarkBlue,
            9 => ColorGroup::Railroad,
            10 => ColorGroup::Utility,
            _ => ColorGroup::Special,
        };
        property_state.property_type = match property_data.property_type {
            0 => PropertyType::Street,
            1 => PropertyType::Railroad,
            2 => PropertyType::Utility,
            _ => PropertyType::Property,
        };
        property_state.houses = 0;
        property_state.has_hotel = false;
        property_state.is_mortgaged = false;
        property_state.rent_base = property_data.rent[0] as u16;
        property_state.rent_with_color_group = (property_data.rent[0] * 2) as u16;
        property_state.rent_with_houses = [
            property_data.rent[1] as u16,
            property_data.rent[2] as u16,
            property_data.rent[3] as u16,
            property_data.rent[4] as u16,
        ];
        property_state.rent_with_hotel = property_data.rent[5] as u16;
        property_state.house_cost = property_data.house_cost as u16;
        property_state.mortgage_value = property_data.mortgage_value as u16;
        property_state.last_rent_paid = 0;
    }

    // Transfer ownership
    property_state.owner = Some(player_pubkey);

    // Deduct money from player
    player_state.cash_balance = player_state
        .cash_balance
        .checked_sub(property_data.price)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Add property to player's owned properties
    if !player_state.properties_owned.contains(&position) {
        player_state.properties_owned.push(position);
    }

    // Update player's net worth
    player_state.net_worth = player_state
        .net_worth
        .checked_add(property_data.price)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Clear property action flag
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;

    // Update timestamps
    game.turn_started_at = clock.unix_timestamp;

    // In the buy_property_handler function, remove or update the msg! that references property_data.name:
    msg!(
        "Player {} purchased property at position {} for ${}",
        player_pubkey,
        position,
        property_data.price
    );

    Ok(())
}

// ---------------------------------------------------------------------------

#[derive(Accounts)]
pub struct DeclineProperty<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn decline_property_handler(ctx: Context<DeclineProperty>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Validate player is at the property position
    if player_state.position != position {
        return Err(GameError::InvalidPropertyPosition.into());
    }

    // Validate player has a pending property action
    if !player_state.needs_property_action {
        return Err(GameError::InvalidSpecialSpaceAction.into());
    }

    // Validate the pending property position matches
    if player_state.pending_property_position != Some(position) {
        return Err(GameError::InvalidPropertyPosition.into());
    }

    // Validate position is a purchasable property
    if !is_property_purchasable(position) {
        return Err(GameError::PropertyNotPurchasable.into());
    }

    // Get property data for logging
    let property_data = get_property_data(position).ok_or(GameError::InvalidPropertyPosition)?;

    // Clear property action flags
    player_state.needs_property_action = false;
    player_state.pending_property_position = None;

    // Allow player to end turn after declining
    // player_state.can_end_turn = true;

    // Update timestamps
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} declined to purchase property at position {} (${}) - property may go to auction",
        player_pubkey,
        position,
        property_data.price
    );

    // Note: In a full implementation, this would trigger an auction
    // The auction system would be implemented separately with its own instruction

    Ok(())
}

// ---------------------------------------------------------------------------

#[derive(Accounts)]
#[instruction(position: u8)]
pub struct PayRent<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), payer.key().as_ref()],
        bump
    )]
    pub payer_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), property_owner.key().as_ref()],
        bump
    )]
    pub owner_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub payer: Signer<'info>,

    /// CHECK: Property owner account - validated by property_state.owner
    pub property_owner: UncheckedAccount<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn pay_rent_handler(ctx: Context<PayRent>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let payer_state = &mut ctx.accounts.payer_state;
    let owner_state = &mut ctx.accounts.owner_state;
    let property_state = &mut ctx.accounts.property_state;
    let payer_pubkey = ctx.accounts.payer.key();
    let property_owner_pubkey = ctx.accounts.property_owner.key();
    let clock = &ctx.accounts.clock;

    let payer_index = game
        .players
        .iter()
        .position(|&p| p == payer_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != payer_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    if payer_state.position != position {
        return Err(GameError::InvalidPropertyPosition.into());
    }

    let property_owner = property_state.owner.ok_or(GameError::PropertyNotOwned)?;
    if property_owner != property_owner_pubkey {
        return Err(GameError::InvalidPropertyOwner.into());
    }

    // Can't pay rent to yourself
    if payer_pubkey == property_owner {
        return Ok(());
    }

    // Check if property is mortgaged (no rent if mortgaged)
    if property_state.is_mortgaged {
        return Ok(()); // No rent payment needed
    }

    let rent_amount =
        calculate_rent_for_property(&property_state, &owner_state, payer_state.last_dice_roll)?;

    // Check if payer has enough money
    if payer_state.cash_balance < rent_amount {
        // Set bankruptcy check flag
        payer_state.needs_bankruptcy_check = true;
        return Err(GameError::InsufficientFunds.into());
    }

    // Transfer rent from payer to owner
    payer_state.cash_balance = payer_state
        .cash_balance
        .checked_sub(rent_amount)
        .ok_or(GameError::ArithmeticUnderflow)?;

    owner_state.cash_balance = owner_state
        .cash_balance
        .checked_add(rent_amount)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Update net worth
    payer_state.net_worth = payer_state
        .net_worth
        .checked_sub(rent_amount)
        .ok_or(GameError::ArithmeticUnderflow)?;

    owner_state.net_worth = owner_state
        .net_worth
        .checked_add(rent_amount)
        .ok_or(GameError::ArithmeticOverflow)?;

    // FIXME
    payer_state.needs_property_action = false;

    // Update property rent tracking
    property_state.last_rent_paid = clock.unix_timestamp;
    owner_state.last_rent_collected = clock.unix_timestamp;

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} paid ${} rent to {} for property at position {}",
        payer_pubkey,
        rent_amount,
        property_owner,
        position
    );

    Ok(())
}

// ---------------------------------------------------------------------------
#[derive(Accounts)]
#[instruction(position: u8)]
pub struct BuildHouse<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump,
        constraint = property_state.owner == Some(player.key()) @ GameError::PropertyNotOwnedByPlayer,
        constraint = !property_state.is_mortgaged @ GameError::PropertyMortgaged,
        constraint = property_state.property_type == PropertyType::Street @ GameError::CannotBuildOnPropertyType,
        constraint = property_state.houses < MAX_HOUSES_PER_PROPERTY @ GameError::MaxHousesReached,
        constraint = !property_state.has_hotel @ GameError::PropertyHasHotel
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn build_house_handler(ctx: Context<BuildHouse>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Get property data
    // let property_data = get_property_data(position).ok_or(GameError::InvalidPropertyPosition)?;

    // Check monopoly requirement
    if !has_monopoly_for_player(player_state, property_state.color_group) {
        return Err(GameError::DoesNotOwnColorGroup.into());
    }

    // Check even building rule
    if !can_build_evenly_for_player(
        player_state,
        property_state.color_group,
        position,
        property_state.houses + 1,
    ) {
        return Err(GameError::MustBuildEvenly.into());
    }

    // Check if enough houses available
    if game.houses_remaining == 0 {
        return Err(GameError::NotEnoughHousesInBank.into());
    }

    // Check if player has enough money
    if player_state.cash_balance < property_state.house_cost as u64 {
        return Err(GameError::InsufficientFunds.into());
    }

    // Deduct money from player
    player_state.cash_balance = player_state
        .cash_balance
        .checked_sub(property_state.house_cost as u64)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Add house to property
    property_state.houses += 1;

    // Update game state
    game.houses_remaining -= 1;
    game.turn_started_at = clock.unix_timestamp;

    // Update player's net worth
    player_state.net_worth = player_state
        .net_worth
        .checked_add(property_state.house_cost as u64)
        .ok_or(GameError::ArithmeticOverflow)?;

    msg!(
        "Player {} built a house on property {} for ${}",
        player_pubkey,
        position,
        property_state.house_cost
    );

    Ok(())
}

// ---------------------------------------------------------------------------

#[derive(Accounts)]
#[instruction(position: u8)]
pub struct BuildHotel<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump,
        constraint = property_state.owner == Some(player.key()) @ GameError::PropertyNotOwnedByPlayer,
        constraint = !property_state.is_mortgaged @ GameError::PropertyMortgaged,
        constraint = property_state.property_type == PropertyType::Street @ GameError::CannotBuildOnPropertyType,
        constraint = property_state.houses == MAX_HOUSES_PER_PROPERTY @ GameError::InvalidHouseCount,
        constraint = !property_state.has_hotel @ GameError::PropertyHasHotel
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn build_hotel_handler(ctx: Context<BuildHotel>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Check monopoly requirement
    if !has_monopoly_for_player(player_state, property_state.color_group) {
        return Err(GameError::DoesNotOwnColorGroup.into());
    }

    // Check if enough hotels available
    if game.hotels_remaining == 0 {
        return Err(GameError::NotEnoughHotelsInBank.into());
    }

    // Check if player has enough money
    if player_state.cash_balance < property_state.house_cost as u64 {
        return Err(GameError::InsufficientFunds.into());
    }

    // Deduct money from player
    player_state.cash_balance = player_state
        .cash_balance
        .checked_sub(property_state.house_cost as u64)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Convert houses to hotel
    property_state.houses = 0;
    property_state.has_hotel = true;

    // Update game state - return houses to bank and take a hotel
    game.houses_remaining += MAX_HOUSES_PER_PROPERTY;
    game.hotels_remaining -= 1;
    game.turn_started_at = clock.unix_timestamp;

    // Update player's net worth
    player_state.net_worth = player_state
        .net_worth
        .checked_add(property_state.house_cost as u64)
        .ok_or(GameError::ArithmeticOverflow)?;

    msg!(
        "Player {} built a hotel on property {} for ${}",
        player_pubkey,
        position,
        property_state.house_cost
    );

    Ok(())
}

// ---------------------------------------------------------------------------

#[derive(Accounts)]
#[instruction(position: u8, building_type: BuildingType)]
pub struct SellBuilding<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump,
        constraint = property_state.owner == Some(player.key()) @ GameError::PropertyNotOwnedByPlayer,
        constraint = property_state.property_type == PropertyType::Street @ GameError::CannotBuildOnPropertyType
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn sell_building_handler(
    ctx: Context<SellBuilding>,
    position: u8,
    building_type: BuildingType,
) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    let sale_price = property_state.house_cost as u64 / 2; // Sell at half price

    match building_type {
        BuildingType::House => {
            // Check if property has houses to sell
            if property_state.houses == 0 {
                return Err(GameError::NoHousesToSell.into());
            }

            // Check even selling rule
            if !can_sell_evenly_for_player(
                player_state,
                property_state.color_group,
                position,
                property_state.houses - 1,
            ) {
                return Err(GameError::MustSellEvenly.into());
            }

            // Sell house
            property_state.houses -= 1;
            game.houses_remaining += 1;

            msg!(
                "Player {} sold a house from property {} for ${}",
                player_pubkey,
                position,
                sale_price
            );
        }
        BuildingType::Hotel => {
            // Check if property has hotel to sell
            if !property_state.has_hotel {
                return Err(GameError::NoHotelToSell.into());
            }

            // Check if there are enough houses in bank to convert hotel back
            if game.houses_remaining < MAX_HOUSES_PER_PROPERTY {
                return Err(GameError::NotEnoughHousesInBank.into());
            }

            // Sell hotel and convert back to houses
            property_state.has_hotel = false;
            property_state.houses = MAX_HOUSES_PER_PROPERTY;
            game.hotels_remaining += 1;
            game.houses_remaining -= MAX_HOUSES_PER_PROPERTY;

            msg!(
                "Player {} sold a hotel from property {} for ${}",
                player_pubkey,
                position,
                sale_price
            );
        }
    }

    // Add money to player
    player_state.cash_balance = player_state
        .cash_balance
        .checked_add(sale_price)
        .ok_or(GameError::ArithmeticOverflow)?;

    // Update player's net worth
    player_state.net_worth = player_state
        .net_worth
        .checked_sub(sale_price)
        .ok_or(GameError::ArithmeticUnderflow)?;

    // Update timestamp
    game.turn_started_at = clock.unix_timestamp;

    Ok(())
}

// ---------------------------------------------------------------------------

#[derive(Accounts)]
#[instruction(position: u8)]
pub struct MortgageProperty<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump,
        constraint = property_state.owner == Some(player.key()) @ GameError::PropertyNotOwnedByPlayer,
        constraint = !property_state.is_mortgaged @ GameError::PropertyAlreadyMortgaged,
        constraint = property_state.houses == 0 @ GameError::CannotMortgageWithBuildings,
        constraint = !property_state.has_hotel @ GameError::CannotMortgageWithBuildings
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn mortgage_property_handler(ctx: Context<MortgageProperty>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Validate position is a mortgageable property
    if !is_property_purchasable(position) {
        return Err(GameError::PropertyNotPurchasable.into());
    }

    // Calculate mortgage value (half of purchase price)
    let mortgage_value = property_state.mortgage_value as u64;

    // Update property state
    property_state.is_mortgaged = true;
    property_state.last_rent_paid = clock.unix_timestamp;

    // Update player cash balance
    player_state.cash_balance += mortgage_value;
    player_state.net_worth -= mortgage_value; // Reduce net worth by mortgage value

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} mortgaged property at position {} for ${}",
        player_pubkey,
        position,
        mortgage_value
    );

    Ok(())
}

#[derive(Accounts)]
#[instruction(position: u8)]
pub struct UnmortgageProperty<'info> {
    #[account(
        mut,
        // seeds = [b"game", game.authority.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        seeds = [b"game", game.config_id.as_ref(), &game.game_id.to_le_bytes().as_ref()],
        bump = game.bump,
        constraint = game.game_status == GameStatus::InProgress @ GameError::GameNotInProgress
    )]
    pub game: Account<'info, GameState>,

    #[account(
        mut,
        seeds = [b"player", game.key().as_ref(), player.key().as_ref()],
        bump
    )]
    pub player_state: Account<'info, PlayerState>,

    #[account(
        mut,
        seeds = [b"property", game.key().as_ref(), position.to_le_bytes().as_ref()],
        bump,
        constraint = property_state.owner == Some(player.key()) @ GameError::PropertyNotOwnedByPlayer,
        constraint = property_state.is_mortgaged @ GameError::PropertyNotMortgaged
    )]
    pub property_state: Account<'info, PropertyState>,

    #[account(mut)]
    pub player: Signer<'info>,

    pub clock: Sysvar<'info, Clock>,
}

pub fn unmortgage_property_handler(ctx: Context<UnmortgageProperty>, position: u8) -> Result<()> {
    let game = &mut ctx.accounts.game;
    let player_state = &mut ctx.accounts.player_state;
    let property_state = &mut ctx.accounts.property_state;
    let player_pubkey = ctx.accounts.player.key();
    let clock = &ctx.accounts.clock;

    // Validate it's the player's turn
    let player_index = game
        .players
        .iter()
        .position(|&p| p == player_pubkey)
        .ok_or(GameError::PlayerNotFound)?;

    if game.current_turn != player_index as u8 {
        return Err(GameError::NotPlayerTurn.into());
    }

    // Validate position is a mortgageable property
    if !is_property_purchasable(position) {
        return Err(GameError::PropertyNotPurchasable.into());
    }

    // Calculate unmortgage cost (mortgage value + 10% interest)
    let mortgage_value = property_state.mortgage_value as u64;
    let interest = mortgage_value / 10; // 10% interest
    let unmortgage_cost = mortgage_value + interest;

    // Check if player has enough money
    if player_state.cash_balance < unmortgage_cost {
        return Err(GameError::InsufficientFunds.into());
    }

    // Update property state
    property_state.is_mortgaged = false;
    property_state.last_rent_paid = clock.unix_timestamp;

    // Update player cash balance and net worth
    player_state.cash_balance -= unmortgage_cost;
    player_state.net_worth += mortgage_value; // Restore net worth

    // Update game timestamp
    game.turn_started_at = clock.unix_timestamp;

    msg!(
        "Player {} unmortgaged property at position {} for ${} (mortgage: ${}, interest: ${})",
        player_pubkey,
        position,
        unmortgage_cost,
        mortgage_value,
        interest
    );

    Ok(())
}


