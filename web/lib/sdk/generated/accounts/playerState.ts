/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type Option,
  type OptionOrNullable,
  type ReadonlyUint8Array,
} from '@solana/kit';

export const PLAYER_STATE_DISCRIMINATOR = new Uint8Array([
  56, 3, 60, 86, 174, 16, 244, 195,
]);

export function getPlayerStateDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    PLAYER_STATE_DISCRIMINATOR
  );
}

export type PlayerState = {
  discriminator: ReadonlyUint8Array;
  wallet: Address;
  game: Address;
  cashBalance: bigint;
  position: number;
  inJail: boolean;
  jailTurns: number;
  doublesCount: number;
  isBankrupt: boolean;
  propertiesOwned: ReadonlyUint8Array;
  getOutOfJailCards: number;
  netWorth: bigint;
  lastRentCollected: bigint;
  festivalBoostTurns: number;
  hasRolledDice: boolean;
  lastDiceRoll: ReadonlyUint8Array;
  needsPropertyAction: boolean;
  pendingPropertyPosition: Option<number>;
  needsChanceCard: boolean;
  needsCommunityChestCard: boolean;
  needsBankruptcyCheck: boolean;
  needsSpecialSpaceAction: boolean;
  pendingSpecialSpacePosition: Option<number>;
  cardDrawnAt: Option<bigint>;
};

export type PlayerStateArgs = {
  wallet: Address;
  game: Address;
  cashBalance: number | bigint;
  position: number;
  inJail: boolean;
  jailTurns: number;
  doublesCount: number;
  isBankrupt: boolean;
  propertiesOwned: ReadonlyUint8Array;
  getOutOfJailCards: number;
  netWorth: number | bigint;
  lastRentCollected: number | bigint;
  festivalBoostTurns: number;
  hasRolledDice: boolean;
  lastDiceRoll: ReadonlyUint8Array;
  needsPropertyAction: boolean;
  pendingPropertyPosition: OptionOrNullable<number>;
  needsChanceCard: boolean;
  needsCommunityChestCard: boolean;
  needsBankruptcyCheck: boolean;
  needsSpecialSpaceAction: boolean;
  pendingSpecialSpacePosition: OptionOrNullable<number>;
  cardDrawnAt: OptionOrNullable<number | bigint>;
};

export function getPlayerStateEncoder(): Encoder<PlayerStateArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['wallet', getAddressEncoder()],
      ['game', getAddressEncoder()],
      ['cashBalance', getU64Encoder()],
      ['position', getU8Encoder()],
      ['inJail', getBooleanEncoder()],
      ['jailTurns', getU8Encoder()],
      ['doublesCount', getU8Encoder()],
      ['isBankrupt', getBooleanEncoder()],
      [
        'propertiesOwned',
        addEncoderSizePrefix(getBytesEncoder(), getU32Encoder()),
      ],
      ['getOutOfJailCards', getU8Encoder()],
      ['netWorth', getU64Encoder()],
      ['lastRentCollected', getI64Encoder()],
      ['festivalBoostTurns', getU8Encoder()],
      ['hasRolledDice', getBooleanEncoder()],
      ['lastDiceRoll', fixEncoderSize(getBytesEncoder(), 2)],
      ['needsPropertyAction', getBooleanEncoder()],
      ['pendingPropertyPosition', getOptionEncoder(getU8Encoder())],
      ['needsChanceCard', getBooleanEncoder()],
      ['needsCommunityChestCard', getBooleanEncoder()],
      ['needsBankruptcyCheck', getBooleanEncoder()],
      ['needsSpecialSpaceAction', getBooleanEncoder()],
      ['pendingSpecialSpacePosition', getOptionEncoder(getU8Encoder())],
      ['cardDrawnAt', getOptionEncoder(getI64Encoder())],
    ]),
    (value) => ({ ...value, discriminator: PLAYER_STATE_DISCRIMINATOR })
  );
}

export function getPlayerStateDecoder(): Decoder<PlayerState> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['wallet', getAddressDecoder()],
    ['game', getAddressDecoder()],
    ['cashBalance', getU64Decoder()],
    ['position', getU8Decoder()],
    ['inJail', getBooleanDecoder()],
    ['jailTurns', getU8Decoder()],
    ['doublesCount', getU8Decoder()],
    ['isBankrupt', getBooleanDecoder()],
    [
      'propertiesOwned',
      addDecoderSizePrefix(getBytesDecoder(), getU32Decoder()),
    ],
    ['getOutOfJailCards', getU8Decoder()],
    ['netWorth', getU64Decoder()],
    ['lastRentCollected', getI64Decoder()],
    ['festivalBoostTurns', getU8Decoder()],
    ['hasRolledDice', getBooleanDecoder()],
    ['lastDiceRoll', fixDecoderSize(getBytesDecoder(), 2)],
    ['needsPropertyAction', getBooleanDecoder()],
    ['pendingPropertyPosition', getOptionDecoder(getU8Decoder())],
    ['needsChanceCard', getBooleanDecoder()],
    ['needsCommunityChestCard', getBooleanDecoder()],
    ['needsBankruptcyCheck', getBooleanDecoder()],
    ['needsSpecialSpaceAction', getBooleanDecoder()],
    ['pendingSpecialSpacePosition', getOptionDecoder(getU8Decoder())],
    ['cardDrawnAt', getOptionDecoder(getI64Decoder())],
  ]);
}

export function getPlayerStateCodec(): Codec<PlayerStateArgs, PlayerState> {
  return combineCodec(getPlayerStateEncoder(), getPlayerStateDecoder());
}

export function decodePlayerState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<PlayerState, TAddress>;
export function decodePlayerState<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<PlayerState, TAddress>;
export function decodePlayerState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<PlayerState, TAddress> | MaybeAccount<PlayerState, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getPlayerStateDecoder()
  );
}

export async function fetchPlayerState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<PlayerState, TAddress>> {
  const maybeAccount = await fetchMaybePlayerState(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybePlayerState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<PlayerState, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodePlayerState(maybeAccount);
}

export async function fetchAllPlayerState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<PlayerState>[]> {
  const maybeAccounts = await fetchAllMaybePlayerState(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybePlayerState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<PlayerState>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodePlayerState(maybeAccount));
}
